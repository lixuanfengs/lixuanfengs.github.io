{"pages":[],"posts":[{"title":"Docker 安装 fastdfs","text":"环境准备。 libfastcommonV1.0.7.tar.gz FastDFS_v5.05.tar.gz nginx-1.13.6.tar.gz fastdfs-nginx-module_v1.16.tar.gz 创建工作目录在 Linux 服务器上创建 /usr/local/docker/fastdfs/environmen 目录。 说明： /usr/local/docker/fastdfs：用于存放 docker-compose.yml 配置文件及 FastDFS 的数据卷 /usr/local/docker/fastdfs/environmen：用于存放 Dockerfile 镜像配置文件及 FastDFS 所需环境 docker-compose.yml123456789version: '3.1'services: fastdfs: # 服务名称，用户自定义 build: environment # Dockerfile restart: always # 默认开机自启动 container_name: fastdfs # 容器名称 volumes: # 目录挂咋 - ./storage:/fastdfs/storage network_mode: host # 网络模式 Dockerfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ROM ubuntu:xenialMAINTAINER 1183895890@qq.com# 更新数据源WORKDIR /etc/aptRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' &gt; sources.listRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' &gt;&gt; sources.listRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' &gt;&gt; sources.listRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' &gt;&gt; sources.listRUN apt-get update# 安装依赖RUN apt-get install make gcc libpcre3-dev zlib1g-dev --assume-yes# 复制工具包ADD FastDFS_v5.05.tar.gz /usr/local/srcADD fastdfs-nginx-module_v1.16.tar.gz /usr/local/srcADD libfastcommonV1.0.7.tar.gz /usr/local/srcADD nginx-1.16.1.tar.gz /usr/local/src# 安装 libfastcommonWORKDIR /usr/local/src/libfastcommon-1.0.7RUN ./make.sh &amp;&amp; ./make.sh install# 安装 FastDFSWORKDIR /usr/local/src/FastDFSRUN ./make.sh &amp;&amp; ./make.sh install# 配置 FastDFS 跟踪器ADD tracker.conf /etc/fdfsRUN mkdir -p /fastdfs/tracker# 配置 FastDFS 存储ADD storage.conf /etc/fdfsRUN mkdir -p /fastdfs/storage# 配置 FastDFS 客户端ADD client.conf /etc/fdfs# 配置 fastdfs-nginx-moduleADD config /usr/local/src/fastdfs-nginx-module/src# FastDFS 与 Nginx 集成WORKDIR /usr/local/src/nginx-1.16.1RUN ./configure --add-module=/usr/local/src/fastdfs-nginx-module/srcRUN make &amp;&amp; make installADD mod_fastdfs.conf /etc/fdfsWORKDIR /usr/local/src/FastDFS/confRUN cp http.conf mime.types /etc/fdfs/# 配置 NginxADD nginx.conf /usr/local/nginx/conf#建立软连接RUN ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.soRUN ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.soRUN ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.soRUN ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.soCOPY entrypoint.sh /usr/local/bin/ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]WORKDIR /EXPOSE 8888CMD [\"/bin/bash\"] entrypoint.sh1234#!/bin/shfdfs_trackerd /etc/fdfs/tracker.conffdfs_storaged /etc/fdfs/storage.conf/usr/local/nginx/sbin/nginx -g 'daemon off;' 注：Shell 创建后是无法直接使用的，需要赋予执行的权限，使用 chmod +x entrypoint.sh 命令 各种配置文件说明tracker.confFastDFS 跟踪器配置，容器中路径为：/etc/fdfs，修改为： 1base_path=/fastdfs/tracker storage.confFastDFS 存储配置，容器中路径为：/etc/fdfs，修改为： 1234base_path=/fastdfs/storagestore_path0=/fastdfs/storagetracker_server=192.168.33.10:22122http.server_port=8888 client.confFastDFS 客户端配置，容器中路径为：/etc/fdfs，修改为： 12ase_path=/fastdfs/trackertracker_server=192.168.33.10:22122 configfastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： 1234567# 修改前CORE_INCS=\"$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/\"CORE_LIBS=\"$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient\"# 修改后CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\"CORE_LIBS=\"$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient\" mod_fastdfs.conffastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： 1234connect_timeout=10tracker_server=192.168.33.10:22122url_have_group_name = truestore_path0=/fastdfs/storage nginx.confNginx 配置文件，容器中路径为：/usr/local/src/nginx-1.13.6/conf，修改为： 1234567891011121314151617181920212223242526272829user root;worker_processes 1;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8888; server_name localhost; location ~/group([0-9])/M00 { ngx_fastdfs_module; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }} 启动容器1docker-compose up -d 测试上传交互式进入容器1docker exec -it fastdfs /bin/bash 测试文件上传1/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/FastDFS/INSTALL 服务器反馈上传地址1group1/M00/00/00/wKhLi1oHVMCAT2vrAAAeSwu9TgM39767 测试 Nginx 访问1http://192.168.33.10:8888/group1/M00/00/00/wKhLi1oHVMCAT2vrAAAeSwu9TgM3976771","link":"/2020/04/01/Docker-%E5%AE%89%E8%A3%85-fastdfs/"},{"title":"Git安装配置","text":"在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads Linux 平台上安装Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：各 Linux 系统可以很简单多使用其安装包管理工具进行安装： Debian/UbuntuDebian/Ubuntu Git 安装命令为： 1234567$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git-core$ git --versiongit version 1.8.1.2 Centos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为： 1234567$ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel$ yum -y install git-core$ git --versiongit version 1.7.1 Windows 平台上安装在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：安装包下载地址：https://git-scm.com/downloads 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为： http://sourceforge.net/projects/git-osx-installer/安装界面如下所示： Git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 用户信息配置个人的用户名称和电子邮件地址： 12$ git config --global user.name \"lxf\"$ git config --global user.email lxf@php.cn 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：$ git config --global core.editor emacs 差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： $ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 当然，你也可以指定使用自己开发的工具 查看配置信息要检查已有的配置信息，可以使用git config --list 命令： 1234$ git config --listhttp.postbuffer=2Muser.name=lxfuser.email=lxf@java.cn 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。 这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到 如下所示：vim ~/.gitconfig 显示内容如下所示： 12345[http] postBuffer = 2M[user] name = lxf email = lxf@java.cn 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样： 1$ git config user.name lxf Git 工作流程 本节我们将为大家介绍Git的工作流程。 一般工作流程如下： 1.克隆Git 资源为工作目录。 2.在克隆的资源上添加或者是修改文件。 3.如果其他人修改了，你可以更新资源。 4.在提交修改前查看修改。 5.提交修改。 6.在修改完成后，如果发现错误，可以撤回提交并再次修改并体骄傲。 下图展示了Git 的工作流程： ![](Git安装配置/96f3b6_650x800.png) Git 快速设置 简易的命令行入门教程: Git 全局设置 12git config --global user.name \"用户名\"git config --global user.email \"邮箱\" 创建 git 仓库： 12345678mkdir tuolajicd tuolajigit inittouch README.mdgit add README.md //提交单个文件，如果想直接上传所有文件，请将'README.md改'为'.'git commit -m &quot;first commit&quot;git remote add origin https://gitee.com/liqingbo/test.gitgit push -u origin master 已有项目?123cd existing_git_repogit remote add origin https://gitee.com/liqingbo/test.gitgit push -u origin master 创建仓库 初始化 方式一：进入当前根目录初始化 1git init 方式二：指定目录作为Git 仓库 1git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 Git 使用 git init 命令初始化一个 Git 仓库，Git的很多命令都需要 Git 的仓库中运行，所以 git init 是使用 Git 的一个命令。 在执行完 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 提交 如果当前目录下有几个文件想要纳入版本控制，需要先用 `git add` 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 123$ git add *.c$ git add README$ git commit -m '初始化项目版本' 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。 1git clone 我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout)。 克隆仓库的命令格式为： 1git clone &lt;repo&gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式： 1git clone &lt;repo&gt; &lt;directory&gt; 参数说明： 参数 说明 repo Git 仓库 directory 本地目录 如： 1$ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字： 1$ git clone git://github.com/schacon/grit.git lxfgrit","link":"/2020/02/25/Git%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"Git实际操作","text":"Git 远程仓库地址变更 以下均以项目git_test为例： 12老地址：http://192.168.1.12:9797/john/git_test.git 新地址：http://192.168.100.235:9797/john/git_test.git 远程仓库名称： origin 方法一 通过命令直接修改远程地址进入git_test根目录git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 1git remote set-url origin http://192.168.100.235:9797/john/git_test.git 方法二 通过命令先删除再添加远程仓库进入git_test根目录 123git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址git remote rm origingit remote add origin http://192.168.100.235:9797/john/git_test.git 方法三 直接修改配置文件进入git_test/.gitvim config 1234567891011[core] repositoryformatversion = 0 filemode = true logallrefupdates = true precomposeunicode = true [remote \"origin\"] url = http://192.168.100.235:9797/shimanqiang/assistant.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master 修改 [remote “origin”]下面的url即可 方法四 通过第三方git客户端修改。以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件，同样可以完成方法三。 git回滚到任意版本回滚到指定的版本 1git reset --hard e377f60e28c8b84158 强制提交 1git push -f origin master 完美ba87f5b62d581d3a109a78982ca478643c4c6800 先显示提交的log 123456789101112131415161718$ git log -3commit 4dc08bb8996a6ee02fAuthor: Mark &lt;xxx@xx.com&gt;Date: Wed Sep 7 08:08:53 2016 +0800 xxxxxcommit 9cac9ba76574da2167Author: xxx&lt;xx@qq.com&gt;Date: Tue Sep 6 22:18:59 2016 +0800 improved the requstcommit e377f60e28c8b84158Author: xxx&lt;xxx@qq.com&gt;Date: Tue Sep 6 14:42:44 2016 +0800 changed the password from empty to max123 Git pull 强制覆盖本地文件远程获取最新版本到本地 1# git fetch --all 相当于是从远程获取最新版本到本地，不会自动merge只是下载远程的库的内容，不做任何的合并 彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 *慎用* ！ 1# git reset --hard origin/master 删除所有git add的文件（当然这不包括未置于版控制下的文件 untracked files）把HEAD指向刚刚下载的最新的版本 Git pull 强制覆盖本地文件强制覆盖远程分支 1git push origin branch-name --force Git 强制推送方法 1$ git push -u origin master -f （一般不建议使用） git丢弃本地修改的所有文件（新增、删除、修改）本地修改了许多文件，其中有些是新增的，因为开发需要这些都不要了，想要丢弃掉，可以使用如下命令： 本地所有修改的。没有的提交的，都返回到原来的状态 1git checkout . 把所有没有提交的修改暂存到stash里面。可用git stash pop回复。 1git stash # 返回到某个节点，不保留修改。 1git reset --hard HASH 返回到某个节点。保留修改 1git reset --soft HASH 返回到某个节点 1git clean -df git clean 123-n 显示 将要 删除的 文件 和 目录-f 删除 文件-df 删除 文件 和 目录 也可以使用： 1git checkout . &amp;&amp; git clean -xdf 把所有没有提交的修改暂存到stash里面。可用git stash pop回复。 1git stash # 返回到某个节点，不保留修改。 1git reset --hard HASH 返回到某个节点。保留修改 1git reset --soft HASH 返回到某个节点 1git clean -df git clean 123-n 显示 将要 删除的 文件 和 目录-f 删除 文件-df 删除 文件 和 目录 也可以使用： 1git checkout . &amp;&amp; git clean -xdf 配置仓库的SSH公钥你可以按如下命令来生成 sshkey: 12ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... 复制 按照提示完成三次回车，即可生成 ssh key。 通过查看~/.ssh/id_rsa.pub文件内容，获取到你的 public key 12cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 码云上添加SSH公钥一、打开终端输入12ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" #Generating public/private rsa key pair... 三次回车即可生成 ssh key 二、查看你的 public key12cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 三、码云上添加个人公钥复制以上公钥，添加到马云的个人私钥里面 四、查看状态添加后，在终端（Terminal）中输入 1ssh -T git@gitee.com 若返回以下信息，则证明添加成功。 1Hi liqingbo! You've successfully authenticated, but GITEE.COM does not provide shell access. 五、配置git pull/push 免密码进入项目根目录，也就是.git所在目录终端输入 1vi .git/config 文件代码 1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote \"origin\"] url = git@gitee.com:liqingbo/项目.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master 修改配置文件 HTTPS传输的地址，你需要改成SSH的传输地址 1url = https://@gitee.com/liqingbo/项目.git 改成 1url = git@gitee.com:liqingbo/项目.git 复制 注：https://改成git和gitee.com，后面的“/”改成“:” 这样使用命令 git pull/push 就不用输入密码了，这是因为刚才在生成公钥时，没有输入密码，所以当你选择SSH地址传输时，就可免密码使用命令 git pull/push。 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git checkout -b feature1Switched to a new branch 'feature1' 修改readme.txt最后一行，改为： 1Creating a new branch is quick AND simple. 在feature1分支上提交： 1234$ git add readme.txt$ git commit -m \"AND simple\"[feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： 1234$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： 1Creating a new branch is quick &amp; simple. 提交： 1234$ git add readme.txt $ git commit -m \"&amp; simple\"[master 5dc6824] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 12345$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 12345678910111213141516$ git statusOn branch masterYour branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits)You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge)Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: readme.txtno changes added to commit (use \"git add\" and/or \"git commit -a\") 我们可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 1Creating a new branch is quick and simple. 再提交： 12345$ git add readme.txt $ git commit -m \"conflict fixed\"[master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567891011121314$ git log --graph --pretty=oneline --abbrev-commit* cf810e4 (HEAD -&gt; master) conflict fixed|\\ | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/ * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was 14096d0). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 感觉本站内容不错，读后有收获？","link":"/2020/02/26/Git%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C/"},{"title":"Git分支管理","text":"几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。当你执行 git init 的时候，缺省情况下 Git 就会为你创建master分支。 合并冲突合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 12345$ git branch* master* $ cat test.txtw3cschool.cc 总结123456git branch //查看分支git branch &lt;name&gt; //创建分支git checkout &lt;name&gt; //切换分支git checkout -b &lt;name&gt; //创建+切换分支git merge &lt;name&gt; //合并某分支到当前分支git branch -d &lt;name&gt; //删除分支 查看分支1git branch 创建分支1git branch (branchname) 删除分支1git branch -d (branchname) 例如我们要删除”testing”分支： 123456789$ git branch* master testing $ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 切换1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了testing分支，Git 将还原你的工作目录到你创建分支时候的样子 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 123456789101112131415$ lsREADME$ echo 'w3cschool.cc' &gt; test.txt$ git add .$ git commit -m 'add test.txt'[master 048598f] add test.txt 2 files changed, 1 insertion(+), 3 deletions(-) delete mode 100644 hello.php create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch 'testing'$ lsREADME hello.java 当我们切换到testing分支的时候，我们添加的新文件test.txt被移除了,原来被删除的文件hello.php文件又出现了。切换回master分支的时候，它们有重新出现了。 12345$ git checkout masterSwitched to branch 'master'$ lsREADME test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 12345678910111213141516171819$ git checkout -b newtestSwitched to a new branch 'newtest'$ git rm test2.txt rm 'test2.txt'$ lsREADME test.txt$ git commit -am 'removed test2.txt'[newtest 556f0a0] removed test2.txt 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ git checkout masterSwitched to branch 'master'$ lsREADME test.txt test2.txt 如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。 合并1git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： 12345678910111213141516git merge$ git branch* master newtest $ lsREADME test.txt test2.txt$ git merge newtestUpdating 2e082b7..556f0a0Fast-forward test2.txt | 1 - 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ lsREADME test.txt 以上实例中我们将 newtest 分支合并到主分支去，test2.txt 文件被删除。 首先，我们创建一个叫做”change_site”的分支，切换过去，我们将内容改为 www.w3cschool.cc 。 12345678$ git checkout -b change_siteSwitched to a new branch 'change_site'$ vim test.txt $ head -1 test.txt www.w3cschool.cc$ git commit -am 'changed the site'[change_site d7e7346] changed the site 1 file changed, 1 insertion(+), 1 deletion(-) 将修改的内容提交到 “change_site” 分支中。 现在，假如切换回 “master” 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。 123456789$ git checkout masterSwitched to branch 'master'$ head -1 test.txt w3cschool.cc$ vim test.txt $ cat test.txtw3cschool.cc 新增加一行 1234567$ git diffdiff --git a/test.txt b/test.txtindex 704cce7..f84c2a4 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ w3cschool.cc +新增加一行 123$ git commit -am '新增加一行'[master 14b4dca] 新增加一行 1 file changed, 1 insertion(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 1234567891011$ git merge change_siteAuto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result.$ cat test.txt &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADw3cschool.cc新增加一行=======www.w3cschool.cc&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site 我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 12345678910111213$ vim test.txt $ cat test.txt www.w3cschool.cc新增加一行$ git diffdiff --cc test.txtindex f84c2a4,bccb7c2..0000000--- a/test.txt+++ b/test.txt@@@ -1,2 -1,1 +1,2 @@@- w3cschool.cc+ www.w3cschool.cc +新增加一行 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 1234567git status -sUU test.txt$ git add test.txt $ git status -sM test.txt$ git commit[master 88afe0e] Merge branch 'change_site' 现在我们成功解决了合并中的冲突，并提交了结果。 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 w3cschoolcc 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 1$ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了： 12345678910$ git log --oneline --decorate --graph* 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site'|\\ | * d7e7346 (change_site) changed the site* | 14b4dca 新增加一行|/ * 556f0a0 removed test2.txt* 2e082b7 add test2.txt* 048598f add test.txt* 85fc7e7 test comment from w3cschool.cc 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： 1234567891011$ git tag -a v0.9 85fc7e7$ git log --oneline --decorate --graph* 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site'|\\ | * d7e7346 (change_site) changed the site* | 14b4dca 新增加一行|/ * 556f0a0 removed test2.txt* 2e082b7 add test2.txt* 048598f add test.txt* 85fc7e7 (tag: v0.9) test comment from w3cschool.cc 如果我们要查看所有标签可以使用以下命令： 123$ git tagv0.9v1.0 指定标签信息命令： 1$ git tag -a v1.0 PGP签名标签命令： 1git tag -s &lt;tagname&gt; -m \"w3cschool.cc标签\"","link":"/2020/02/26/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"},{"title":"Git常用命令","text":"Git 常用命令速查 1234567891011121314git branch 查看本地所有分支git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支git branch -r 查看远程所有分支git commit -am \"init\" 提交并且加注释 git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支dev 123456789101112131415161718192021222324252627282930313233343536373839git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m \"This is the message describing the commit\" 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m \"remove\" 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来git remote add origin git@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中git pull 本地与服务器端同步git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranchgit fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hsgit branch 删除远程branchgit push origin :branch_remote_namegit branch -r -d branch_remote_name 初始化版本库，并提交到远程服务器端 1234567mkdir WebAppcd WebAppgit init 本地初始化touch READMEgit add README 添加文件git commit -m 'first commit'git remote add origin git@github.com:lixuanfengs/WebApp.git 增加一个远程服务器端 上面的命令会增加URL地址为‘git@github.com:lixuanfengs/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可 1、常用的Git命令 命令 简要说明 git add 添加至暂存区 git add–interactive 交互式添加 git apply 应用补丁 git am 应用邮件格式补丁 git annotate 同义词，等同于 git blame git archive 文件归档打包 git bisect 二分查找 git blame 文件逐行追溯 git branch 分支管理 git cat-file 版本库对象研究工具 git checkout 检出到工作区、切换或创建分支 git cherry-pick 提交拣选 git citool 图形化提交，相当于 git gui 命令 git clean 清除工作区未跟踪文件 git clone 克隆版本库 git commit 提交 git config 查询和修改配置 git describe 通过里程碑直观地显示提交ID git diff 差异比较 git difftool 调用图形化差异比较工具 git fetch 获取远程版本库的提交 git format-patch 创建邮件格式的补丁文件。参见 git am 命令 git grep 文件内容搜索定位工具 git gui 基于Tcl/Tk的图形化工具，侧重提交等操作 git help 帮助 git init 版本库初始化 git init-db* 同义词，等同于 git init git log 显示提交日志 git merge 分支合并 git mergetool 图形化冲突解决 git mv 重命名 git pull 拉回远程版本库的提交 git push 推送至远程版本库 git rebase 分支变基 git rebase–interactive 交互式分支变基 git reflog 分支等引用变更记录管理 git remote 远程版本库管理 git repo-config* 同义词，等同于 git config git reset 重置改变分支“游标”指向 git rev-parse 将各种引用表示法转换为哈希值等 git revert 反转提交 git rm 删除文件 git show 显示各种类型的对象 git stage* 同义词，等同于 git add git stash 保存和恢复进度 git status 显示工作区文件状态 git tag 里程碑管理 2、对象库操作相关命令 命令 简要说明 git commit-tree 从树对象创建提交 git hash-object 从标准输入或文件计算哈希值或创建对象 git ls-files 显示工作区和暂存区文件 git ls-tree 显示树对象包含的文件 git mktag 读取标准输入创建一个里程碑对象 git mktree 读取标准输入创建一个树对象 git read-tree 读取树对象到暂存区 git update-index 工作区内容注册到暂存区及暂存区管理 git unpack-file 创建临时文件包含指定 blob 的内容 git write-tree 从暂存区创建一个树对象 3、引用操作相关命令 命令 简要说明 git check-ref-format 检查引用名称是否符合规范 git for-each-ref 引用迭代器，用于shell编程 git ls-remote 显示远程版本库的引用 git name-rev 将提交ID显示为友好名称 git peek-remote* 过时命令，请使用 git ls-remote git rev-list 显示版本范围 git show-branch 显示分支列表及拓扑关系 git show-ref 显示本地引用 git symbolic-ref 显示或者设置符号引用 git update-ref 更新引用的指向 git verify-tag 校验 GPG 签名的Tag 4、版本库管理相关命令 命令 简要说明 git count-objects 显示松散对象的数量和磁盘占用 git filter-branch 版本库重构 git fsck 对象库完整性检查 git fsck-objects* 同义词，等同于 git fsck git gc 版本库存储优化 git index-pack 从打包文件创建对应的索引文件 git lost-found* 过时，请使用 git fsck –lost-found 命令 git pack-objects 从标准输入读入对象ID，打包到文件 git pack-redundant 查找多余的 pack 文件 git pack-refs 将引用打包到 .git/packed-refs 文件中 git prune 从对象库删除过期对象 git prune-packed 将已经打包的松散对象删除 git relink 为本地版本库中相同的对象建立硬连接 git repack 将版本库未打包的松散对象打包 git show-index 读取包的索引文件，显示打包文件中的内容 git unpack-objects 从打包文件释放文件 git verify-pack 校验对象库打包文件 4、版本库管理相关命令 命令 简要说明 git count-objects 显示松散对象的数量和磁盘占用 git filter-branch 版本库重构 git fsck 对象库完整性检查 git fsck-objects* 同义词，等同于 git fsck git gc 版本库存储优化 git index-pack 从打包文件创建对应的索引文件 git lost-found* 过时，请使用 git fsck –lost-found 命令 git pack-objects 从标准输入读入对象ID，打包到文件 git pack-redundant 查找多余的 pack 文件 git pack-refs 将引用打包到 .git/packed-refs 文件中 git prune 从对象库删除过期对象 git prune-packed 将已经打包的松散对象删除 git relink 为本地版本库中相同的对象建立硬连接 git repack 将版本库未打包的松散对象打包 git show-index 读取包的索引文件，显示打包文件中的内容 git unpack-objects 从打包文件释放文件 git verify-pack 校验对象库打包文件 6、邮件相关命令 命令 简要说明 git imap-send 将补丁通过 IMAP 发送 git mailinfo 从邮件导出提交说明和补丁 git mailsplit 将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件 git request-pull 创建包含提交间差异和执行PULL操作地址的信息 git send-email 发送邮件 7、协议相关命令 命令 简要说明 git daemon 实现Git协议 git http-backend 实现HTTP协议的CGI程序，支持智能HTTP协议 git instaweb 即时启动浏览器通过 gitweb 浏览当前版本库 git shell 受限制的shell，提供仅执行Git命令的SSH访问 git update-server-info 更新哑协议需要的辅助文件 git http-fetch 通过HTTP协议获取版本库 git http-push 通过HTTP/DAV协议推送 git remote-ext 由Git命令调用，通过外部命令提供扩展协议支持 git remote-fd 由Git命令调用，使用文件描述符作为协议接口 git remote-ftp 由Git命令调用，提供对FTP协议的支持 git remote-ftps 由Git命令调用，提供对FTPS协议的支持 git remote-http 由Git命令调用，提供对HTTP协议的支持 git remote-https 由Git命令调用，提供对HTTPS协议的支持 git remote-testgit 协议扩展示例脚本 8、版本库转换和交互相关命令 命令 简要说明 git archimport 导入Arch版本库到Git git bundle 提交打包和解包，以便在不同版本库间传递 git cvsexportcommit 将Git的一个提交作为一个CVS检出 git cvsimport 导入CVS版本库到Git。或者使用 cvs2git git cvsserver Git的CVS协议模拟器，可供CVS命令访问Git版本库 git fast-export 将提交导出为 git-fast-import 格式 git fast-import 其他版本库迁移至Git的通用工具 git svn Git 作为前端操作 Subversion 、合并相关的辅助命令 命令 简要说明 git merge-base 供其他脚本调用，找到两个或多个提交最近的共同祖先 git merge-file 针对文件的两个不同版本执行三向文件合并 git merge-index 对index中的冲突文件调用指定的冲突解决工具 git merge-octopus 合并两个以上分支。参见 git merge 的octopus合并策略 git merge-one-file 由 git merge-index 调用的标准辅助程序 git merge-ours 合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略 git merge-recursive 针对两个分支的三向合并。参见 git merge 的recursive合并策略 git merge-resolve 针对两个分支的三向合并。参见 git merge 的resolve合并策略 git merge-subtree 子树合并。参见 git merge 的 subtree 合并策略 git merge-tree 显式三向合并结果，不改变暂存区 git fmt-merge-msg 供执行合并操作的脚本调用，用于创建一个合并提交说明 git rerere 重用所记录的冲突解决方案 10、 杂项 命令 简要说明 git bisect–helper 由 git bisect 命令调用，确认二分查找进度 git check-attr 显示某个文件是否设置了某个属性 git checkout-index 从暂存区拷贝文件至工作区 git cherry 查找没有合并到上游的提交 git diff-files 比较暂存区和工作区，相当于 git diff –raw git diff-index 比较暂存区和版本库，相当于 git diff –cached –raw git diff-tree 比较两个树对象，相当于 git diff –raw A B git difftool–helper 由 git difftool 命令调用，默认要使用的差异比较工具 git get-tar-commit-id 从 git archive 创建的 tar 包中提取提交ID git gui–askpass 命令 git gui 的获取用户口令输入界面 git notes 提交评论管理 git patch-id 补丁过滤行号和空白字符后生成补丁唯一ID git quiltimport 将Quilt补丁列表应用到当前分支 git replace 提交替换 git shortlog 对 git log 的汇总输出，适合于产品发布说明 git stripspace 删除空行，供其他脚本调用 git submodule 子模组管理 git tar-tree 过时命令，请使用 git archive git var 显示 Git 环境变量 git web–browse 启动浏览器以查看目录或文件 git whatchanged 显示提交历史及每次提交的改动 git-mergetool–lib 包含于其他脚本中，提供合并/差异比较工具的选择和执行 git-parse-remote 包含于其他脚本中，提供操作远程版本库的函数 git-sh-setup 包含于其他脚本中，提供 shell 编程的函数库 git init初始化仓库 git statusgit-status - Show the working tree status git checkoutgit checkout命令用于切换分支或恢复工作树文件。git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。 使用语法 123456git checkout [-q] [-f] [-m] [&lt;branch&gt;]git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…git checkout [-p|--patch] [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…] 描述更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径git checkout还会更新HEAD，将指定的分支设置为当前分支。 示例示例-1以下顺序检查主分支，将Makefile还原为两个修订版本，错误地删除hello.c，并从索引中取回。 1234$ git checkout master #(1)$ git checkout master~2 Makefile #(2)$ rm -f hello.c$ git checkout hello.c #(3) (1) 切换分支(2) 从另一个提交中取出文件(3)从索引中恢复hello.c 如果想要检出索引中的所有C源文件，可以使用以下命令 - 1$ git checkout -- '*.c' 注意:*.c是使用引号的。 文件hello.c也将被检出，即使它不再在工作树中，因为文件globbing用于匹配索引中的条目(而不是在shell的工作树中)。 如果有一个分支也命名为hello.c，这一步将被混淆为一个指令切换到该分支。应该写： 1$ git checkout -- hello.c 示例-2 在错误的分支工作后，想切换到正确的分支，则使用： 1$ git checkout mytopic 但是，您的”错误”分支和正确的”mytopic”分支可能会在在本地修改的文件中有所不同，在这种情况下，上述检出将会失败： $ git checkout mytopicerror: You have local changes to ‘frotz’; not switching branches. 可以将-m标志赋给命令，这将尝试三路合并： $ git checkout -m mytopicAuto-merging frotz 在这种三路合并之后，本地的修改没有在索引文件中注册，所以git diff会显示从新分支的提示之后所做的更改。 示例-3 当使用-m选项切换分支时发生合并冲突时，会看到如下所示： 1234$ git checkout -m mytopicAuto-merging frotzERROR: Merge conflict in frotzfatal: merge program failed 此时，git diff会显示上一个示例中干净合并的更改以及冲突文件中的更改。 编辑并解决冲突，并用常规方式用git add来标记它： 12$ edit frotz # 编辑 frotz 文件中内容，然后重新添加$ git add frotz 其它示例 git checkout的主要功能就是迁出一个分支的特定版本。默认是迁出分支的HEAD版本一此用法示例： 1234$ git checkout master #//取出master版本的head。$ git checkout tag_name #//在当前分支上 取出 tag_name 的版本$ git checkout master file_name #//放弃当前对文件file_name的修改$ git checkout commit_id file_name #//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。 $ git checkout -b dev/1.5.4 origin/dev/1.5.4 从远程dev/1.5.4分支取得到本地分支/dev/1.5.412345$ git checkout -- hello.rb#这条命令把hello.rb从HEAD中签出.$ git checkout .#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。 git reset -–hard123$ git reset --hard HEAD^ 回退到上个版本$ git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前$ git reset --hard commit_id 退到/进到 指定commit的sha码 git reset -–hard彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！ git fsck –lost-found这个命令可以恢复git add过的文件 相关命令 git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git log1$ git log 123456789101112131415161718192021222324252627commit 88afe0e02adcdfea6844bb627de97da21eb10af1Merge: 14b4dca d7e7346Author: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 15:03:42 2015 +0800 Merge branch 'change_site' Conflicts: test.txtcommit 14b4dcadbdc847207651d5a9fae0d315057f346eAuthor: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 14:53:15 2015 +0800 新增加一行commit d7e734640da06055e107eaf29cf350b3f1de1c2cAuthor: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 14:48:57 2015 +0800 changed the sitecommit 556f0a0637978097b82287ac665a717623b21f3fAuthor: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 14:40:34 2015 +0800 removed test2.txt –oneline查看历史记录的简洁的版本。 12345678$ git log --oneline88afe0e Merge branch 'change_site'14b4dca 新增加一行d7e7346 changed the site556f0a0 removed test2.txt2e082b7 add test2.txt048598f add test.txt85fc7e7 test comment from w3cschool.cc 这告诉我们的是，此项目的开发历史。我们还可以用 ``选项，查看历史中什么时候出现了分支、合并。 –graph查看历史中什么时候出现了分支、合并。 12345678910$ git log --oneline --graph* 88afe0e Merge branch 'change_site'|\\ | * d7e7346 changed the site* | 14b4dca 新增加一行|/ * 556f0a0 removed test2.txt* 2e082b7 add test2.txt* 048598f add test.txt* 85fc7e7 test comment from w3cschool.cc 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。你也可以用 --reverse参数来逆向显示所有日志。 12345678$ git log --reverse --oneline85fc7e7 test comment from w3cschool.cc048598f add test.txt2e082b7 add test2.txt556f0a0 removed test2.txtd7e7346 changed the site14b4dca 新增加一行88afe0e Merge branch 'change_site' 如果只想查找指定用户的提交日志可以使用命令：git log --author例如，比方说我们要找 Git 源码中 Linus 提交的部分： 123456$ git log --author=Linus --oneline -581b50f3 Move 'builtin-*' into a 'builtin/' subdirectory3bb7256 make &quot;index-pack&quot; a built-in377d027 make &quot;git pack-redundant&quot; a built-inb532581 make &quot;git unpack-file&quot; a built-in112dd51 make &quot;mktag&quot; a built-in 如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）： 12345678910$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges5469e2d Git 1.7.1-rc2d43427d Documentation/remote-helpers: Fix typos and improve language272a36b Fixup: Second argument may be any arbitrary stringb6c8d2d Documentation/remote-helpers: Add invocation section5ce4f4e Documentation/urls: Rewrite to accomodate transport::address00b84e9 Documentation/remote-helpers: Rewrite description03aa87e Documentation: Describe other situations where -z affects git diff77bc694 rebase-interactive: silence warning when no commits rewritten636db2c t3301: add tests to use --format=&quot;%N&quot; 更多 git log 命令可查看：http://git-scm.com/docs/git-log","link":"/2020/02/26/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Git远程仓库","text":"Git 并不像 SVN 那样有个中心服务器。目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。 查看远程分支加上-a参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）： 1234$ git branch -a master* fenzhi remotes/origin/master 添加远程库要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下： 1git remote add [shortname] [url] 查看当前的远程库要查看当前配置有哪些远程仓库，可以用命令： 123456git remote$ git remoteorigin$ git remote -vorigin git@github.com:tianqixin/w3cschool.cc.git (fetch)origin git@github.com:tianqixin/w3cschool.cc.git (push) 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： 1$ git branch -av 提取远程仓库Git 有两个命令用来提取远程仓库的更新。1、从远程仓库下载新分支与数据： 1git fetch 该命令执行完后需要执行git merge 远程分支到你所在的分支。 2、从远端仓库提取数据并尝试合并到当前分支：git pull 该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。 假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。 推送到远程仓库推送你的新分支与数据到某个远端仓库命令: 1git push [alias] [branch] 以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。 12345678$ git merge origin/masterUpdating 7d2081c..f5f3dd5Fast-forward \"w3cschool\\350\\217\\234\\351\\270\\237\\346\\225\\231\\347\\250\\213\\346\\265\\213\\350\\257\\225.txt\" | 1 + 1 file changed, 1 insertion(+)bogon:w3cschoolcc tianqixin$ vim w3cschoolphp中文网测试.txt bogon:w3cschoolcc tianqixin$ git push origin masterEverything up-to-date 删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： 1$ git push origin --delete &lt;branchName&gt; 删除tag这么用： 1git push origin --delete tag &lt;tagname&gt; 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： 1git push origin :&lt;branchName&gt; 这是删除tag的方法，推送一个空tag到远程tag： 12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 两种语法作用完全相同。","link":"/2020/02/26/Git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"title":"Git服务器搭建","text":"Centos,win10,阿里云上搭建自己的git服务器. Centos 搭建git服务器1、安装Git1$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel 1$ yum install git 创建一个git用户组和用户，用来运行git服务： 1$ groupadd git 复制 1$ adduser git -g git win10生成SSH keysSSH key 可以让你在你的电脑和Code服务器之间建立安全的加密连接。 先执行以下语句来判断是否已经存在本地公钥： 1cat ~/.ssh/id_rsa.pub 如果出现类似一下字符串，表示你还没创建ssh key 如果你看到一长串以 ssh-rsa或 ssh-dsa开头的字符串, 你可以跳过 ssh-keygen的步骤。 提示: 最好的情况是一个密码对应一个ssh key，但是那不是必须的。你完全可以跳过创建密码这个步骤。请记住设置的密码并不能被修改或获取。 生成ssh key在git窗口输入 1ssh-keygen -t rsa -C \"1183895890@qq.com\" 然后一直回车这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击Enter键去使用默认值。如图： 查看生成的公钥 1cat ~/.ssh/id_rsa.pub 复制这个公钥放到你的个人设置中的SSH/My SSH Keys下请完整拷贝从ssh-开始直到你的用户名和主机名为止的内容。 到这里的时候，你的公钥已经创建成功了 扩展通过下面方法可以拷贝你的公钥到你的粘贴板下请参考你的操作系统使用以下的命令：Windows: 1clip &lt; ~/.ssh/id_rsa.pub Mac: 1pbcopy &lt; ~/.ssh/id_rsa.pub GNU/Linux (requires xclip): 1xclip -sel clip &lt; ~/.ssh/id_rsa.pub Applications Eclipse：如何在Eclipse中添加ssh key: https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_ConfigurationTip: Non-default OpenSSH key file names or locations 如果，不管你有什么理由，当你决定去用一个非默认的位置或文件名去存放你的ssh key。你必须配置好你的ssh客户端以找到你的ssh私钥去连接Code服务器，对于OpenSSH客户端，这个通常是在~/.ssh/config类似的位置配置的： 123456## Our company's internal GitLab server#Host my-git.company.comRSAAuthentication yesIdentityFile ~/my-ssh-key-directory/company-com-private-key-filename","link":"/2020/02/26/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"title":"IntelliJ IDEA 2019.3注册码+破解","text":"一、前言 ​ 笔者在网上找了一圈，各种方法都试过了，之前那种在网上随便找个注册码，就能激活成功的方式已经一去不返了~ 本文记录下个人 IntelliJ IDEA 2019.3激活破解教程~ 说实话，IDEA 更新是真滴快，还以为 IDEA 2019.2.4 后面会更新 IDEA 2019.2.5 版本，谁知道 11 月份刚结束，官方直接就上了 2019.3 版本 … 据官方说 IDEA 2019.3 版本在启动速度以及 UI 交互上做了很大优化。 二、下载最新的 IDEA 2019.3 其实也可以从老版本直接升级，这里为了照顾大部分人可能第一次安装，我们选择从官网下载，下载地址为: https://www.jetbrains.com/idea/download/ 等待下载完成~~ 三、点击启动 IDEA 2019.3 安装包 ### 这里本人的电脑是64位的，顺便将 64 位的 IDEA 启动图标生成到桌面上： 点击 NEXT ~~ 启动 IDEA 2019.3, 启动成功后，我们可以看到 IDEA 新的欢迎界面如下: 四、开始激活 IDEA 2019.3 如下图所示，我们先选择免费试用 30 天，先进去再说: 五、配置破解补丁 进去过后，我们随便建个项目，点击菜单栏 **Help -> Edit Custom VM Options**: 注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格了~ 下载破解补丁成功以后，笔者将它放置在了 IDEA 的安装目录 /bin 路径下，以防止后面被自己误删: 注意：补丁全路径中不要包含中文，否则，可能导致破解失败！ 页面提取人数太多，导致破解补丁容易被封，一直更换非常麻烦，为限制人数，目前暂不提供页面直接提取，改为从笔者微信号提取。 在 .vmoptions 文件中配置我们补丁放置的全路径位置。 1-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3\\bin\\jetbrains-agent.jar 注意，你的位置可能和我不一样，请自行修改。 六、重启 IDEA切记，一定要重启 IDEA. 七、填入激活码，激活重启完成后，开始填入激活码，点击菜单栏 Help -&gt; Register: 注意：激活码需搭配上面的破解补丁一起使用才有效！！！ 7.1 第一个激活码1A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 7.2 第二个激活码13AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 7.3 第三个激活码1KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 点击激活: 可以看到，已经激活到 2089 年了，开心编码吧~ 声明本教程只做个人学习使用，请勿用于商业用途！ 若资金允许，请点击 https://www.jetbrains.com/idea/buy/ 购买正版，谢谢合作！ 学生凭学生证可免费申请 https://sales.jetbrains.com/hc/zh-cn/articles/207154369-学生授权申请方式 正版授权！ 创业公司可5折购买 https://www.jetbrains.com/shop/eform/startup 正版授权！ 八、可能遇到的问题8.1 Your activation code could not be validated (error 1653219)https://www.exception.site/essay/your-activation-code-could-not-be-validated-error-1653219","link":"/2020/02/18/IntelliJ-IDEA-2019-3%E6%B3%A8%E5%86%8C%E7%A0%81-%E7%A0%B4%E8%A7%A3/"},{"title":"Java中常用类","text":"字符串相关的类，String 类及常用方法 StringBuffer、StringBuilder。JDK 8.0 之前的日期 API, System 静态方法，Date 类，calendar 类，SimpleDateFormat 类。JDK 8.0 中的时间 API, LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormat、其它类。Java 比较器，Comparable 接口，Comparator 接口，System 类，Math 类，BigInteger 与 BigDecimal。 字符串相关的类String 的特性 String 类：代表字符串。Java 程序中的所有字符串字面值（如”abc“）都作为此类的示的实例实现 String 是一个final 类，代表不可变的字符序列 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改 String对象的字符内容是存储在一个字符数组 value[] 中的 1234567public final class Stringimplements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {/** The value is used for character storage. */private final char value[];/** Cache the hash code for the string */private int hash; // Default to 0 String s1 = “abc”;//字面量的定义方式 String s2 = “abc”; s1 = “hello”; String 对象的创建 1234567891011String str = \"hello\";//本质上this.value = new char[0];String s1 = new String();//this.value = original.value;String s2 = new String(String original);//this.value = Arrays.copyOf(value, value.length);String s3 = new String(char[] a);String s4 = new String(char[] a,int startIndex,int count); String str1 = “abc”；与 String str2 = new String(”abc“); 的区别？ *str1 * 字符串常量存储在字符串常量池， 目的是共享 str2 字符串非常量对象存储在堆中 字符串对象是如何存储的 练习1 12345678String s1 = \"javaEE\";String s2 = \"javaEE\";String s3 = new String(\"javaEE\");String s4 = new String(\"javaEE\");System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//false System.out.println(s3 == s4);//false 练习2 123456789101112Person p1 = new Person(); p1.name = \"xianrenqiu\";Person p2 = new Person(); p2.name = \"xianrenqiu\";System.out.println(p1.name .equals( p2.name)); // trueSystem.out.println(p1.name == p2.name); // trueSystem.out.println(p1.name == \"xianrenqiu\"); // trueString s1 = new String(\"bcde\");String s2 = new String(\"bcde\");System.out.println(s1==s2); //false 1234Person p1 = new Person(\"Tom\",12);Person p2 = new Person(\"Tom\",12);System.out.println(p1.name == p2.name);//true 字符串的特性 结论： 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量 只要其中有一个是变量，结果就在堆中 如果拼接的结果调用intern()方法，返回值就在常量池中 String 使用的陷阱 String s1 = “a”; 说明：在字符串常量池中创建了一个字面量是 “a”的字符串 s1 = s1 + “b”; 说明：实际上原来的“a”字符对象已经丢弃了，现在在堆空间中产生了一个字符串 s1 + “b”(也就是“ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能 String s2 = “ab”; 说明：直接在字符串常量池中创建一个字面量为“ab”的字符串 String s3 = “a” + “b”; 说明：s3指向字符串常量池中已经创建的“ab”的字符串 String s4 = s1.intern(); 说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的“ab” 字符串赋值给s4 练习3 【面试题】 下列程序运行的结果： 12345678910111213141516public class StringTest {String str = new String(\"good\");char[] ch = { 't', 'e', 's', 't' };public void change(String str, char ch[]) { str = \"test ok\"; ch[0] = 'b';}public static void main(String[] args) { StringTest ex = new StringTest(); ex.change(ex.str, ex.ch); System.out.print(ex.str + \" and \");// good and System.out.println(ex.ch); // }} String 常用方法1 int length()：返回字符串的长度： return value.length char charAt(int index)： 返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空字符串：return value.length == 0 String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写 String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写 String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+” int compareTo(String anotherString)：比较两个字符串的大小 String substring(int beginIndex)： 返回一个新的字符串， 它是此字符串的从beginIndex开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串 String常用方法2 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf方法如果未找到都是返回-1 String常用方法3 String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String replace(CharSequence target, CharSequence replacement)： 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement) ： 使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement) ： 使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 12345678910111213141516171819202122232425String str = \"12hello34world5java7891mysql456\";//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉String string = str.replaceAll(\"\\\\d+\", \",\").replaceAll(\"^,|,$\", \"\");System.out.println(string);String str = \"12345\";//判断str字符串中是否全部有数字组成，即有1-n个数字组成boolean matches = str.matches(\"\\\\d+\");System.out.println(matches); String tel = \"0571-4534289\";//判断这是否是一个杭州的固定电话boolean result = tel.matches(\"0571-\\\\d{7,8}\");System.out.println(result);String str = \"hello|world|java\"; String[] strs = str.split(\"\\\\|\");for (int i = 0; i &lt; strs.length; i++) { System.out.println(strs[i]);}System.out.println();String str2 = \"hello.world.java\"; String[] strs2 = str2.split(\"\\\\.\");for (int i = 0; i &lt; strs2.length; i++) { System.out.println(strs2[i]);} String与基本数据类型转换 字符串 -&gt; 基本数据类型、包装类 integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。 类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应 的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。 基本数据类型、包装类 -&gt; 字符串 调用String类的public String valueOf(int n)可将int型转换为字符串 相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换 字符串数组 -&gt; 字符串 String 类的构造器：String(char[]) 和 String(char[], int offset, int length)分别用字符数组中的全部字符和部分字符创建字符串对象。 字符串 -&gt; 字符串数组 public char[] toCharArray(): 将字符串中的全部字符存放在一个字符数组中的方法。 public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin): 提供了将指定索引范围内的字符串存放到数组中的方法。 字节数组 -&gt; 字符串 String(byte[]): 通过使用平台的默认字符集解码指定的byte数组，构造一个新的 String。 String(byte[], int offset, int length): 用指定的字节数组的一部分， 即从数组起始位置offset开始取length个字节构造一个字符串对象。 字符串 -&gt; 字节数组 public byte[] getBytes(): 使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。 public byte[] getBytes(String charsetName): 使用指定的字符集将此String 编码到 byte 序列，并将结果存储到新的 byte 数组。 练习4 12345678String str = \"中\";System.out.println(str.getBytes(\"ISO8859-1\").length);// -128~127System.out.println(str.getBytes(\"GBK\").length); System.out.println(str.getBytes(\"UTF-8\").length);System.out.println(new String(str.getBytes(\"ISO8859-1\"),\"ISO8859-1\"));// 乱码，表示不了中文System.out.println(new String(str.getBytes(\"GBK\"), \"GBK\"));System.out.println(new String(str.getBytes(\"UTF-8\"), \"UTF-8\")); 练习5：常见算法题目 1. 模拟一个trim方法，去除字符串两端的空格。 2. 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class StringDemo { /* 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 方式一：转换为char[] */ public String reverse(String str,int startIndex,int endIndex){ if(str != null){ char[] arr = str.toCharArray(); for(int x = startIndex,y = endIndex;x &lt; y;x++,y--){ char temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; } return new String(arr); } return null; } //方式二：使用String的拼接 public String reverse1(String str,int startIndex,int endIndex){ if(str != null){ //第1部分 String reverseStr = str.substring(0,startIndex); //第2部分 for(int i = endIndex;i &gt;= startIndex;i--){ reverseStr += str.charAt(i); } //第3部分 reverseStr += str.substring(endIndex + 1); return reverseStr; } return null; } //方式三：使用StringBuffer/StringBuilder替换String public String reverse2(String str,int startIndex,int endIndex){ if(str != null){ StringBuilder builder = new StringBuilder(str.length()); //第1部分 builder.append(str.substring(0,startIndex)); //第2部分 for(int i = endIndex;i &gt;= startIndex;i--){ builder.append(str.charAt(i)); } //第3部分 builder.append(str.substring(endIndex + 1)); return builder.toString(); } return null; } @Test public void testReverse(){ String str = \"abcdefg\"; String reverse = reverse(str, 2, 5); System.out.println(reverse); }} 3. 获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在“abkkcadkabkebfkabkskab”中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class StringDemo1 { /* 获取一个字符串在另一个字符串中出现的次数。 比如：获取“ab”在 “abkkcadkabkebfkaabkskab” 中出现的次数 */ /** * 获取subStr在mainStr中出现的次数 * @param mainStr * @param subStr * @return */ public int getCount(String mainStr,String subStr){ int mainLength = mainStr.length(); int subLength = subStr.length(); int count = 0; int index = 0; if(mainLength &gt;= subLength){ //方式一：// while((index = mainStr.indexOf(subStr)) != -1){// count++;// mainStr = mainStr.substring(index + subStr.length());// } //方式二：对方式一的改进 while((index = mainStr.indexOf(subStr,index)) != -1){ count++; index += subLength; } return count; }else{ return 0; } } @Test public void testGetCount(){ String mainStr = \"abkkcadkabkebfkaabkskab\"; String subStr = \"ab\"; int count = getCount(mainStr, subStr); System.out.println(count); }} 4. 获取两个字符串中最大相同子串。比如： str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class StringDemo2 { /* 获取两个字符串中最大相同子串。比如： str1 = \"abcwerthelloyuiodefabcdef\";str2 = \"cvhellobnm\" 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 */ //前提：两个字符串中只有一个最大相同子串 public String getMaxSameString(String str1,String str2){ if(str1 != null &amp;&amp; str2 != null){ String maxStr = (str1.length() &gt;= str2.length())? str1 : str2; String minStr = (str1.length() &lt; str2.length())? str1 : str2; int length = minStr.length(); for(int i = 0;i &lt; length;i++){ for(int x = 0,y = length - i;y &lt;= length;x++,y++){ String subStr = minStr.substring(x,y); if(maxStr.contains(subStr)){ return subStr; } } } } return null; } // 如果存在多个长度相同的最大相同子串 // 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便 public String[] getMaxSameString1(String str1, String str2) { if (str1 != null &amp;&amp; str2 != null) { StringBuffer sBuffer = new StringBuffer(); String maxString = (str1.length() &gt; str2.length()) ? str1 : str2; String minString = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i &lt; len; i++) { for (int x = 0, y = len - i; y &lt;= len; x++, y++) { String subString = minString.substring(x, y); if (maxString.contains(subString)) { sBuffer.append(subString + \",\"); } }// System.out.println(sBuffer); if (sBuffer.length() != 0) { break; } } String[] split = sBuffer.toString().replaceAll(\",$\", \"\").split(\"\\\\,\"); return split; } return null; } @Test public void testGetMaxSameString(){ String str1 = \"abcwerthello1yuiodefabcdef\"; String str2 = \"cvhello1bnmabcdef\"; String[] maxSameStrings = getMaxSameString1(str1, str2); System.out.println(Arrays.toString(maxSameStrings)); }} 5. 对字符串中字符进行自然顺序排序。 提示： 1）字符串变成字符数组。 2）对数组排序，选择，冒泡，Arrays.sort(); 3）将排序后的数组变成字符串 StringBuffer类 java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。 很多方法与String相同。 作为参数传递时，方法内部可以改变值。 StringBuffer 类不同于String，其对象必须使用构造器生成。有三个构造器： StringBuffer(): 初始容量为16的字符串缓冲区 StringBuffer(int size): 构造指定容量的字符缓冲区 StringBufer(String str): 将内容初始化为指定字符串内容 123String s = new String(\"我喜欢学习\");StringBuffer buffer = new StringBuffer(\"我喜欢学习\");buffer.append(\"数学\"); StringBuffer类的常用方法 StringBuffer append(xxx): 提供了很多的append()方法，用于进行字符串拼接 StringBuffer delete(int start, int end): 删除指定位置的内容 StringBuffer raplace(int start, int end, String str): 把(start,end)位置替换为str StringBuffer insert(int offset, xxx): 在指定位置插入 xxx StringBuffer reverse(): 把当前字符序列逆转 当append和insert时，如果原来value数组长度不够，可扩容。 如上这些方法支持方法链操作。 方法链的原理： 此外，还定义了如下的方法： public int indexOf(String str) public String substring(int start,int end) public int length() public char charAt(int n ) public void setCharAt(int n ,char ch) StringBuilder类 StringBuilder 和 StringBuffer 北厂类似，均代表可变的字符序列，而且提供相关功能的方法也一样 面试题：对比String、StringBuffer、StringBuilder String(JDK1.0)：不可变字符序列 StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全 StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全 注意：作为参数传递的话，方法内部 String 不会改变其值，StringBuffer 和 StringBuilder会改变其值 三者效率测试 12345678910111213141516171819202122232425//初始设置long startTime = 0L;long endTime = 0L;String text = \"\";StringBuffer buffer = new StringBuffer(\"\");StringBuilder builder = new StringBuilder(\"\");//开始对比startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) { buffer.append(String.valueOf(i));}endTime = System.currentTimeMillis();System.out.println(\"StringBuffer的执行时间：\" + (endTime - startTime));startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) { builder.append(String.valueOf(i));}endTime = System.currentTimeMillis();System.out.println(\"StringBuilder的执行时间：\" + (endTime - startTime));startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) { text = text + i;}endTime = System.currentTimeMillis(); System.out.println(\"String的执行时间：\" + (endTime - startTime)); 【面试题】 程序输出： 1234567String str = null;StringBuffer sb = new StringBuffer();sb.append(str); System.out.println(sb.length());// 4System.out.println(sb);// nullStringBuffer sb1 = new StringBuffer(str);System.out.println(sb1);// java.lang.NullPointerException 【面试题2】程序输出： 1234567891011@Testpublic void testString (){ String a = \"123\"; String b = \"123\"; String c = new String(\"123\"); String d = new String(\"123\"); System.out.println(a.equals(b)); //true System.out.println(a == b); //true System.out.println(c.equals(d)); //true System.out.println(c == d); //false} JDK8 之前日期时间 API java.lang.System 类 System 类提供的 public static long currentTimeMillis())用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 此方法适于计算时间差。 计算世界时间的主要标准有： UTC(Coordinated Universal Time) GMT(Greenwich Mean Time) CST(Central Standard Time) java.util.Date 类 表示特定的瞬间，精确到毫秒 构造器： Date(): 使用无参构造器创建的对象可以获取本地当前时间 Date(long date) 常用方法 getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。 其它很多方法都过时了。 12345678Date date = new Date();System.out.println(date);System.out.println(System.currentTimeMillis());System.out.println(date.getTime()); Date date1 = new Date(date.getTime());System.out.println(date1.getTime()); System.out.println(date1.toString()); java.text.SimpleDateFormat 类 Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。 它允许进行格式化：日期 -&gt; 文本、解析：文本 -&gt; 日期 格式化： SimpleDateFormat(): 默认的模式和语言环境创建对象 public SimpleDateFormat(String pattern): 该构方法可以用参数 pattern指定的格式创建一个对象，该对象调用： public String format(Date date): 方法格式化时间对象 date 解析： public Date parse(String source): 从给定字符串的开始解析文本，以生成一个日期。 1234567891011121314Date date = new Date(); // 产生一个Date实例// 产生一个formater格式化的实例SimpleDateFormat formater = new SimpleDateFormat();System.out.println(formater.format(date));// 打印输出默认的格式SimpleDateFormat formater2 = new SimpleDateFormat(\"yyyy年MM月dd日EEEHH:mm:ss\");System.out.println(formater2.format(date));try { // 实例化一个指定的格式对象 Date date2 = formater2.parse(\"2008年08月08日 星期一 08:08:08\"); // 将指定的日期解析后格式化按指定的格式输出 System.out.println(date2.toString());} catch (ParseException e) { e.printStackTrace();} java.util.Calendar(日历) 类 Calendar 是一个抽象基类，主要用于完成日期字段之间的相互操作的功能。 获取 Calendar 实例的方法 使用 Calendar.getInstance() 方法 调用它的子类 GregorianCalendar 的构造器 一个 Calendar 的实例是系统时间的抽象表示，通过get(int field) 方法来取得想要的时间信息。比如l 比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND public void set(int field,int value) public void add(int field,int amount) public final Date getTime() public final void setTime(Date date) 注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2 ， 。。。。周六是7 123456789101112Calendar calendar = Calendar.getInstance();// 从一个 Calendar 对象中获取 Date 对象Date date = calendar.getTime();// 使用给定的 Date 设置此 Calendar 的时间date = new Date(234234235235L);calendar.setTime(date);calendar.set(Calendar.DAY_OF_MONTH, 8);System.out.println(\"当前时间日设置为8后,时间是:\" + calendar.getTime());calendar.add(Calendar.HOUR, 2);System.out.println(\"当前时间加2小时后,时间是:\" + calendar.getTime());calendar.add(Calendar.MONTH, -2);System.out.println(\"当前日期减2个月后,时间是:\" + calendar.getTime()); JDK8 中新日期时间 API新日期时间API出现的背景 如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中的年份是从1900开始的，而月份都从0开始。格式化：格式化只对Date有用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。 新时间日期 API 第三次引入的 API 是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。 Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime） 和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法， 用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。 java.time - 包含值对象的基础包 java.time.chrono - 提供对不同的日历系统访问 java.time.format - 格式化和解析时间和日期 java.time.temporal - 包括底层框架和扩展特性 java.time.zone - 包含时区支持类 说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。 LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。 LocalTime表示一个时间，而不是日期。 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。 方法 描述 now() / * now(ZoneId zone) 静态方法，根据当前时间创建对象/指定时区的对象 of() 静态方法，根据指定日期/时间创建对象 getDayOfMonth()/getDayOfYear() 获得月份天数(1-31) /获得年份天数(1-366) getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值) getMonth() 获得月份, 返回一个 Month 枚举值 getMonthValue() / getYear() 获得月份(1-12) /获得年份 getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒 withDayOfMonth()/withDayOfYear()/withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 plusDays(),plusWeeks(),plusMonths(),plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时 minusMonths()/minusWeeks()/minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时 瞬时：Instant Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是 时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中， 也是从1970年开始，但以毫秒为单位。 java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。 (1 ns = 10 ^-9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒 方法 描述 now() 静态方法，返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个 OffsetDateTime toEpochMilli() 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 格式化与解析日期或时间 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 方法 描述 ofPattern(String pattern) 静态方法 ，返回一个指定字符串格式的DateTimeFormatter format(TemporalAccessor t) 格式化一个日期、时间，返回字符串 parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间 其它 API ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等 Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 持续时间：Duration，用于计算两个“时间”间隔 日期间隔：Period，用于计算两个“日期”间隔 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。 TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。 12345678910111213141516//ZoneId:类中包含了所有的时区信息// ZoneId的getAvailableZoneIds():获取所有的ZoneIdSet&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();for (String s : zoneIds) {System.out.println(s);}// ZoneId的of():获取指定时区的时间LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of(\"Asia/Tokyo\"));System.out.println(localDateTime.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日EEEHH:mm:ss\")));//ZonedDateTime:带时区的日期时间// ZonedDateTime的now():获取本时区的ZonedDateTime对象ZonedDateTime zonedDateTime = ZonedDateTime.now();System.out.println(zonedDateTime);// ZonedDateTime的now(ZoneId id):获取指定时区的ZonedDateTime对象ZonedDateTime zonedDateTime1 = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));System.out.println(zonedDateTime1); 123456789101112131415//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准LocalTime localTime = LocalTime.now();LocalTime localTime1 = LocalTime.of(15, 23, 32);//between():静态方法，返回Duration对象，表示两个时间的间隔Duration duration = Duration.between(localTime1, localTime);System.out.println(duration);System.out.println(duration.getSeconds());System.out.println(duration.getNano());LocalDateTime localDateTime = LocalDateTime.of(2016, 6, 12, 15, 23, 32);LocalDateTime localDateTime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32);Duration duration1 = Duration.between(localDateTime1, localDateTime);System.out.println(duration1.toDays()); 123456789101112131415161718// TemporalAdjuster:时间校正器// 获取当前日期的下一个周日是哪天？TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY);LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster); System.out.println(localDateTime);// 获取下一个工作日是哪天？LocalDate localDate = LocalDate.now().with(new TemporalAdjuster() {@Overridepublic Temporal adjustInto(Temporal temporal) { LocalDate date = (LocalDate) temporal; if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) { return date.plusDays(3); } else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) { return date.plusDays(2); } else { return date.plusDays(1); } }});System.out.println(\"下一个工作日是：\" + localDate); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * jdk 8中日期时间API的测试 */public class JDK8DateTimeTest { @Test public void testDate(){ //偏移量 Date date1 = new Date(2020 - 1900,9 - 1,8); System.out.println(date1);//Tue Sep 08 00:00:00 GMT+08:00 2020 } /* LocalDate、LocalTime、LocalDateTime 的使用 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar */ @Test public void test1(){ //now():获取当前的日期、时间、日期+时间 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); //of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); //getXxx()：获取相关的属性 System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getMonthValue()); System.out.println(localDateTime.getMinute()); //体现不可变性 //withXxx():设置相关的属性 LocalDate localDate1 = localDate.withDayOfMonth(22); System.out.println(localDate); System.out.println(localDate1); LocalDateTime localDateTime2 = localDateTime.withHour(4); System.out.println(localDateTime); System.out.println(localDateTime2); //不可变性 LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime); System.out.println(localDateTime4); } /* Instant的使用 类似于 java.util.Date类 */ @Test public void test2(){ //now():获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant);//2019-02-18T07:29:41.719Z //添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2019-02-18T15:32:50.611+08:00 //toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long milli = instant.toEpochMilli(); System.out.println(milli); //ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 = Instant.ofEpochMilli(1550475314878L); System.out.println(instant1); } /* DateTimeFormatter:格式化或解析日期、时间 类似于SimpleDateFormat */ @Test public void test3(){// 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化:日期--&gt;字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1);//2019-02-18T15:42:18.797 //解析：字符串 --&gt;日期 TemporalAccessor parse = formatter.parse(\"2019-02-18T15:42:18.797\"); System.out.println(parse);// 方式二：// 本地化相关的格式。如：ofLocalizedDateTime()// FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); //格式化 String str2 = formatter1.format(localDateTime); System.out.println(str2);//2019年2月18日 下午03时47分16秒// 本地化相关的格式。如：ofLocalizedDate()// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); //格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);//2019-2-18// 重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\"); //格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2019-02-18 03:52:09 //解析 TemporalAccessor accessor = formatter3.parse(\"2019-02-18 03:52:09\"); System.out.println(accessor); } 类 To 遗留类 From 遗留类 java.time.Instant与java.util.Date Date.from(instant) date.toInstant() java.time.Instant与java.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTime与java.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDate与java.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTime与java.sql.Time Date.valueOf(localDate) date.toLocalTime() time.LocalDateTime与java.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneId与java.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatter与java.text.DateFormat formatter.toFormat() 无 Java 比较器 在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 Java实现对象排序的方式有两种： 自然排序：java.lang.Comparable 定制排序：java.lang.Comparator 方式一：自然排序：java.lang.Comparable Comparable 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 实现 Comparable 的类必须实现 compareTo(Object object) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象 this 大于形参对象 Obj, 则返回正整数，如果当前对象 this 小于形参对象obj, 则返回负整数，如果当前对象 this 等于形参对象 obj, 则返回零 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。 Comparable 的典型实现：（默认都是从小都大排列的） 12345678910111213public class ComparableTest{ public static void main(String[] args) { Goods[] all = new Goods[4]; all[0] = new Goods(\"《红楼梦》\", 100); all[1] = new Goods(\"《西游记》\", 80); all[2] = new Goods(\"《三国演义》\", 140); all[3] = new Goods(\"《水浒传》\", 120); Arrays.sort(all); System.out.println(Arrays.toString(all)); }} 方式二：定制排序：java.util.Comparator 当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口 的排序规则不适合当前操作，那么考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Goods implements Comparable{ private String name; private double price; public Goods() { } public Goods(String name, double price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \"Goods{\" + \"name='\" + name + '\\'' + \", price=\" + price + '}'; } //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序 @Override public int compareTo(Object o) {// System.out.println(\"**************\"); if(o instanceof Goods){ Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price){ return 1; }else if(this.price &lt; goods.price){ return -1; }else{// return 0; return -this.name.compareTo(goods.name); } //方式二：// return Double.compare(this.price,goods.price); }// return 0; throw new RuntimeException(\"传入的数据类型不一致！\"); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 一、说明：Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的 * 但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 * 如何实现？使用两个接口中的任何一个：Comparable 或 Comparator * * 二、Comparable接口与Comparator的使用的对比： * Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。 * Comparator接口属于临时性的比较。 */public class CompareTest { /* Comparable接口的使用举例： 自然排序 1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。 2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列 3. 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 在compareTo(obj)方法中指明如何排序 */ @Test public void test1(){ String[] arr = new String[]{\"AA\",\"CC\",\"KK\",\"MM\",\"GG\",\"JJ\",\"DD\"}; // Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } @Test public void test2(){ Goods[] arr = new Goods[5]; arr[0] = new Goods(\"lenovoMouse\",34); arr[1] = new Goods(\"dellMouse\",43); arr[2] = new Goods(\"xiaomiMouse\",12); arr[3] = new Goods(\"huaweiMouse\",65); arr[4] = new Goods(\"microsoftMouse\",43); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } /* Comparator接口的使用：定制排序 1.背景： 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作， 那么可以考虑使用 Comparator 的对象来排序 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 */ @Test public void test3(){ String[] arr = new String[]{\"AA\",\"CC\",\"KK\",\"MM\",\"GG\",\"JJ\",\"DD\"}; Arrays.sort(arr,new Comparator(){ //按照字符串从大到小的顺序排列 @Override public int compare(Object o1, Object o2) { if(o1 instanceof String &amp;&amp; o2 instanceof String){ String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2); }// return 0; throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); } @Test public void test4(){ //定制排序 Goods[] arr = new Goods[6]; arr[0] = new Goods(\"lenovoMouse\",34); arr[1] = new Goods(\"dellMouse\",43); arr[2] = new Goods(\"xiaomiMouse\",12); arr[3] = new Goods(\"huaweiMouse\",65); arr[4] = new Goods(\"huaweiMouse\",224); arr[5] = new Goods(\"microsoftMouse\",43); Arrays.sort(arr, new Comparator() { //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序 @Override public int compare(Object o1, Object o2) { if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods){ Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName())){ return -Double.compare(g1.getPrice(),g2.getPrice()); }else{ return g1.getName().compareTo(g2.getName()); } } throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); }} System 类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流（键盘输入），标准输出流（显示器）和标准错误输出流（显示器）。 成员方法 native long currentTimeMillis(): 该方法的作用是返回当前的计算机时间，时间的表达式格式为当前计算机时间和 GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status): 该方法的作用时退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出共功能等。 void gc(): 该方法的作用是请求系统进行垃圾回收。至于系统是否立即回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key): 该方法的作用是获取系统中属性名为 key 的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 属性名 属性说明 java.version java 运行时环境版本 java.home java 安装目录 os.name 操作系统的名称 os.version 操作系统的版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 1234567891011121314151617181920212223@Testpublic void test1() { String javaVersion = System.getProperty(\"java.version\"); System.out.println(\"java的version:\" + javaVersion); String javaHome = System.getProperty(\"java.home\"); System.out.println(\"java的home:\" + javaHome); String osName = System.getProperty(\"os.name\"); System.out.println(\"os的name:\" + osName); String osVersion = System.getProperty(\"os.version\"); System.out.println(\"os的version:\" + osVersion); String userName = System.getProperty(\"user.name\"); System.out.println(\"user的name:\" + userName); String userHome = System.getProperty(\"user.home\"); System.out.println(\"user的home:\" + userHome); String userDir = System.getProperty(\"user.dir\"); System.out.println(\"user的dir:\" + userDir);} Math 类java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为 double 型。 方法 描述 abs 绝对值 acos, asin, cos, sin, tan 三角函数 sqrt 平方根 pow(double a,double b) a的b次幂 log 自然对数 exp e为底指数 max(double a, double b) 求两个数中的最大的值 min(double a, double b) 求两个数中的最小的值 random() 返回0.0 到1.0的随机数 long round(double a） double 型数据a转换为long类型（四舍五入） toDegrees(double angrad) 弧度 -&gt; 角度 toRadians(double angdeg) 角度 -&gt; 弧度 BigInteger 与 BigDecimal Integer类作为int的包装类，能存储的最大整型值为2的31次方-1，Long类也是有限的， 最大为2的63次方-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 java.math包的BigInteger 可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val): 根据字符串构建 BigInteger对象 常用方法 public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger。 BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger。 BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger。 BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。 BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 BigInteger[] divideAndRemainde r(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。 BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。 BigDecimal 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中， 要求数字精度比较高，故用到java.math.BigDecimal类。 BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 public BigDecimal(double val) public BigDecimal(String val) 常用方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 12345678910@Testpublic void test2() { BigInteger bi = new BigInteger(\"1243324112234324324325235245346567657653\"); BigDecimal bd = new BigDecimal(\"12435.351\"); BigDecimal bd2 = new BigDecimal(\"11\"); System.out.println(bi); System.out.println(bd.divide(bd2)); System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_DOWN)); System.out.println(bd.divide(bd2, 25, BigDecimal.ROUND_HALF_DOWN));}","link":"/2020/03/02/Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/"},{"title":"Java泛型","text":"为什么要有泛型 在集合中使用泛型 自定义泛型结构 泛型在继承上的体现 通配符的使用 泛型应用举例 为什么要有泛型(Generic)? 泛型：标签 举例： 中药店，每个抽屉外面贴着标签 超市购物架上很多瓶子，每个瓶子装的是什么，有标签 泛型的设计背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个&lt;E&gt;就是类型参数，即泛型。 泛型的概念 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如， 继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念， 允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持， 从而可以在声明集合变量、创建集合对象时传入类型实参。 那么为什么要有泛型呢，直接Object不是也可以存储数据吗？ 解决元素存储安全性问题，好比商品、药品标签，不会弄错。 解决获取数据元素时，需要类型强制转换问题，好比不用每回拿商品、药品都要辨别。 在集合中没有反泛型时 任何类型都可以添加到集合中：类型不安全 读取出来的对象需要强转：繁琐可能有 ClassCastException 在集合中有泛型时 只有指定类型才可以添加到集合中：类型安全 读取出来的对象不需要强转：便捷 Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 在集合中使用泛型123456789101112131415ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();//类型推断list.add(78);list.add(88);list.add(77);list.add(66);//遍历方式一：//for(Integer i : list){ //不需要强转 //System.out.println(i);//}//遍历方式二：Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext()){ System.out.println(iterator.next());} 1234567891011121314151617Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();map.put(\"Tom1\",34);map.put(\"Tom2\",44);map.put(\"Tom3\",33);map.put(\"Tom4\",32);//添加失败//map.put(33, \"Tom\");Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();while(iterator.hasNext()){Entry&lt;String,Integer&gt; entry = iterator.next(); System.out.println(entry.getKey() + \"---&gt;\" + entry.getValue());} 自定义泛型结构 自定义泛型类 自定义泛型接口 自定义泛型方法 泛型的声明： interface List 和 class GenTest&lt;K,V&gt; 其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。 常用T表示，是Type的缩写。 泛型的实例化： 一定要在类名后面指定类型参数值（类型）。如： List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); Iterator&lt;Customer&gt; iterator = customers.iterator(); T 只能时类，不能用基本数据类型填充。但可以使用包装类填充 把一个集合中的内容限制为一个特定的数据类型，这就是 generics背后的人核心思想 Comparable c = new Date();System.out.println(c.compareTo(&quot;red&quot;)); JDK1.5 之前 Comparable&lt;Date&gt; c = new Date();System.out.println(c.compareTo(&quot;red&quot;)); JDK1.5 体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误 自定义泛型结构：泛型类、泛型接口 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 泛型类的构造器如下：public GenericClass(){}。 而下面是错误的：public GenericClass(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致 泛型不同的引用不能相互赋值。 尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象 jdk1.7 泛型的简化操作：ArrayList &lt;Fruit&gt; first = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换 1234567891011121314151617181920class GenericTest { public static void main(String[] args) { // 1、使用时：类似于Object，不等同于Object ArrayList list = new ArrayList(); // list.add(new Date());//有风险 list.add(\"hello\"); test(list);// 泛型擦除，编译不会类型检查 // ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;(); // test(list2);//一旦指定Object，编译会类型检查，必须按照Object处理 } public static void test(ArrayList&lt;String&gt; list) { String str = \"\"; for (String s : list) { str += s + \",\"; } System.out.println(\"元素:\" + str); }} 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。 异常类不能时泛型。 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 没有类型 擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型 12345678910111213141516class Father&lt;T1, T2&gt; {}// 子类不保留父类的泛型// 1)没有类型 擦除class Son1 extends Father {// 等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型class Son2 extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; {} 12345678910111213141516class Father&lt;T1, T2&gt; {}// 子类不保留父类的泛型// 1)没有类型 擦除class Son&lt;A, B&gt; extends Father{//等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; {} 1234567891011121314151617181920212223242526272829Class Person&lt;T&gt; { // 使用T类型定义变量 private T info; // 使用T类型定义一般方法 public T getInfo() { return info; } public void setInfo(T info) { this.info = info; } // 使用T类型定义构造器 public Person() { } public Person(T info) { this.info = info; } // static的方法中不能声明泛型 //public static void show(T t) { // //} // 不能在try-catch中使用泛型定义 public void test() { //try { // //} catch (MyException&lt;T&gt; ex) { //} //} // }} 自定义泛型结构：泛型方法 方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。 泛型方法的格式：泛型方法的格式： [访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常 泛型方法声明泛型时也可以指定上限(在12.5中讲) 123456789public class DAO { public &lt;E&gt; E get(int id, E e) { E result = null; return result; }} 123456789101112131415161718192021public static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c) { for (T o : a) { c.add(o); }}public static void main(String[] args) { Object[] ao = new Object[100]; Collection&lt;Object&gt; co = new ArrayList&lt;Object&gt;(); fromArrayToCollection(ao, co); String[] sa = new String[20]; Collection&lt;String&gt; cs = new ArrayList&lt;&gt;(); fromArrayToCollection(sa, cs); Collection&lt;Double&gt; cd = new ArrayList&lt;&gt;(); // 下面代码中T是Double类，但sa是String类型，编译错误。 // fromArrayToCollection(sa, cd); // 下面代码中T是Object类型，sa是String类型，可以赋值成功。 fromArrayToCollection(sa, co);} 12345678910111213141516class Creature{}class Person extends Creature{} class Man extends Person{} class PersonTest { public static &lt;T extends Person&gt; void test(T t){ System.out.println(t); } public static void main(String[] args) { test(new Person()); test(new Man()); //The method test(T) in the type PersonTest is not //applicable for the arguments (Creature) test(new Creature()); }} 泛型在继承上的体现请输出如下的两段代码有何不同 123456public void printCollection(Collection c) { Iterator i = c.iterator(); for (int k = 0; k &lt; c.size(); k++) { System.out.println(i.next()); }} 12345public void printCollection(Collection&lt;Object&gt; c) { for (Object e : c) { System.out.println(e); }} 如果 B 是 A 的一个子类（子类或者子类接口），而G是具有泛型声明的类或接口，G&lt;B&gt;并不是G&lt;A&gt;的子类型！ 比如：String是Object的子类，但是List&lt;String &gt;并不是List&lt;Object&gt;的子类 123456789101112public void testGenericAndSubClass() { Person[] persons = null; Man[] mans = null; // 而 Person[] 是 Man[] 的父类. persons = mans; Person p = mans[0]; // 在泛型的集合上 List&lt;Person&gt; personList = null; List&lt;Man&gt; manList = null; // personList = manList;(报错)} 通配符的使用 使用类型 通配符：? 比如：List&lt;?&gt; , Map&lt;? , ?&gt; List&lt;?&gt;是List、List等各种泛型List的父类。 读取 List&lt;?&gt; 的对象 list 中的元素时，永远时安全的，因为不管 list 的真实类型是什么，它包含的都是 Object。 写入 list 中的元素时，不行。因为我们不知道 c 的元素类型，我们不能向其中添加对象。 唯一的例外时 null，它是所有类型的成员。 将任意元素加入到其中不是类型安全的： Collection&lt;?&gt; c = new ArrayList&lt;String&gt;(); c.add(new Object()); // 编译时错误 因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。 唯一的例外的是 null，它是所有类型的成员。 另一方面，我们可以调用 get() 方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个 Object 。 12345678910111213141516171819public static void main(String[] args) { List&lt;?&gt; list = null; list = new ArrayList&lt;String&gt;(); list = new ArrayList&lt;Double&gt;(); // list.add(3);//编译不通过list.add(null); List&lt;String&gt; l1 = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); l1.add(\"尚硅谷\"); l2.add(15); read(l1); read(l2);}public static void read(List&lt;?&gt; list) { for (Object o : list) { System.out.println(o); }} 通配符的使用：注意点//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?public static &lt;?&gt; void test(ArrayList&lt;?&gt; list){ } //注意点2：编译错误：不能用在泛型类的声明上class GenericTypeClass&lt;?&gt;{ } /注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象 ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;() 通配符的使用：有限制的通配符 &lt;?&gt; 允许所有泛型的引用调用 通配符指定上限 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 通配符指定下限 下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例： &lt;? extends Number&gt; (无穷小 , Number] 只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt; [Number , 无穷大) 只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt; 只允许泛型为实现Comparable接口的实现类的引用调用 123456789101112131415public static void printCollection3(Collection&lt;? extends Person&gt; coll) { //Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why? Iterator&lt;?&gt; iterator = coll.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }}public static void printCollection4(Collection&lt;? super Person&gt; coll) {//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why? Iterator&lt;?&gt; iterator = coll.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }} 练习题：为什么编译如下的操作会报错？ 泛型应用举例12345678910111213141516public static void main(String[] args) { HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = new HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;(); ArrayList&lt;Citizen&gt; list = new ArrayList&lt;Citizen&gt;(); list.add(new Citizen(\"刘恺威\")); list.add(new Citizen(\"杨幂\")); list.add(new Citizen(\"小糯米\")); map.put(\"刘恺威\", list); Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator(); while (iterator.hasNext()) { Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next(); String key = entry.getKey(); ArrayList&lt;Citizen&gt; value = entry.getValue(); System.out.println(\" 户 主 ：\" + key); System.out.println(\"家庭成员：\" + value); }} 泛型应用举例：实际案例用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。","link":"/2020/03/13/Java%E6%B3%9B%E5%9E%8B/"},{"title":"Java多线程","text":"本章节主要介绍线程的基本概念， 线程的创建和使用 ，线程的生命周期 ，线程的同步 ，线程的通信以及 JDK5.0 新增线程创建方式。 基本概念：程序、进程、线程程序程序（program）是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程进程（process）是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程：有它本身的产生、存在和消亡的过程。——生命周期 运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配单位，系统在运行时会为每个进程分配不同的内存区域 线程线程（thread）进程可以进一步细化为线程，是一个程序内部测一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和从程序计数器（pc），线程切换的开销小 一个进程中的多个线程共享相同的内存单元/内存地址空间 ——》它们从堆中分配对象，可以访问相同变量和对象。这就使得线程间通信更简单、高效。但多个线程操作共享的系统资源可能就会带来安全隐患。 单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。 使用多线程的优点背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 1.提高应用程序的响应。对图形化界面更有意义，可以增强用户体验。 2.提高计算机系统CPU的利用率。 3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程？ 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如果用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时。 线程的创建和使用 注意 ：上图里的程序不是多线程！ 线程的创建和启动 Java语言的JVM允许程序运行多个线程，它通过 java.lang.Thread 类来体现。 Thread 类的特性 每个线程都是通过某个特定 Thread 对象的 Run() 方法来完成操作的，经常把 run() 方法的主体称为线程体 通过该 Thread 对象的 start() 方法来启动这个线程，而非直接调用 run() Thread类 构造器 Thread(): 创建新的 Thread 对象 Thread(String threadname): 创建线程并指定线程的实例名 Thread(Runnable target): 指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法 Thread(Runnable target,String name): 创建新的 Thread 对象 API 中创建线程的两种方式 JDK 1.5 之前创建新执行线程有两种方法： 继承 Thread 类的方式 实现 Runnable 接口的方式 方式一：继承 Thread 类 定义子类继承 Thread 类 子类中重写 Thread 类中的 run 方法 创建 Thread 子类对象，即创建了线程对象 调用线程对象 start 方法：启动线程，调用 run 方法 MyThread 子线程的创建和启动过程 注意点： 如果自己手动调用 run() 方法，那么就只是普通方法，没有启动多线程模式。 run() 方法是油 JVM 调用，什么时候调用，执行的过程控制都有操作系统 CPU 调度决定。 想要启动多线程，必须调用 start 方法。 一个线程对象只能调用一次 start() 方法启动，如果重复调用了，则将抛出异常 “IllegalThreadStateException”。 方式二：实现 Runnable 接口 定义子类，实现 Runnable 接口。 子类中重写 Runnable 接口中的 run 方法。 通过 Thread 类含参构造器创建线程对象。 将 Runnable 接口的子类对象作为实际参数传递给 Thread 类的构造器中。 调用 Thread 类中的 start 方法：开启线程，调用 Runnable 子类接口的 run 方法。 继承方式和实现方式的联系与区别 public class Thread extends Object implements Runnable 区别 继承Thread: 线程代码存放Thread子类run方法中。 实现Runnable：线程代码存在接口的子类的run方法。 实现方式的好处 避免了单继承的局限性 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。 Thread类的有关方法 void start(): 启动线程，并执行对象的run()方法 run(): 线程在被调度时执行的操作 String getName(): 返回线程的名称 void setName(String name): 设置该线程名称 static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 Thread类的有关方法（2） static void yield(): 线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若对列中没有同优先级的线程，忽略此方法 join(): 当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis): (指定时间：毫秒) 令当前活动线程在指定的时间段内放弃对 CPU 控制，使其他线程有机会被执行，时间到后重排队。 抛出 InterruptedException 异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive(): 返回 boolean ,判断线程是否还活着 线程的调度 调度策略 时间片 抢占式：高优先级的线程抢占 CPU Java 的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级 线程的优先等级 MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5 涉及的方法 getPriority(): 返回线程优先值 setPriority(int newPriority): 改变线程的优先级 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 补充：线程的分类 Java中的线程分为两类：一种是守护线程，一种是用户线程。 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 Java 垃圾回收就是一个典型的守护线程。 若 JVM 中都是守护线程，当前JVM将退出。 形象理解：兔死狗烹，鸟尽弓藏 12345678910111213141516171819202122232425262728/** * 测试Thread中的常用方法： * 1. start():启动当前线程；调用当前线程的run() * 2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 * 3. currentThread():静态方法，返回执行当前代码的线程 * 4. getName():获取当前线程的名字 * 5. setName():设置当前线程的名字 * 6. yield():释放当前cpu的执行权 * 7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 * 结束阻塞状态。 * 8. stop():已过时。当执行此方法时，强制结束当前线程。 * 9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。 * 10. isAlive():判断当前线程是否存活 * * * 线程的优先级： * 1. * MAX_PRIORITY：10 * MIN _PRIORITY：1 * NORM_PRIORITY：5 --&gt;默认优先级 * 2.如何获取和设置当前线程的优先级： * getPriority():获取线程的优先级 * setPriority(int p):设置线程的优先级 * * 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 * 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 * */ 线程的生命周期JDK 中用 Thread.State 类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五中状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 堵塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程的同步 问题提出 多个线程执行的不确定性引起执行结果的不稳定 多个线程对账本的共享，会造成操作的不完整性，会破坏数据 例题 模拟火车站售票程序，开启三个窗口售票。 多线程出现安全问题 问题原因： 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。 解决办法 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 Synchronized 的使用方法 JAVA 对于多线程的安全问题提供了专业的解决方式：同步机制 同步代码块 synchronized(对象){ ​ //需要被同步的代码 } synchronized 还可以放在方法声明中，表示整个方法为同步方法例如： public synchronized void show (String name){ ​ … } 分析同步原理 同步机制中的锁 同步锁机制： 在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。 synchronized 的锁是什么？ 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 同步方法的锁：静态方法（类名.class）、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为this或类名.class 注意： 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this) ,同步代码块（指定需谨慎） 同步范围 如何找问题，即代码是否存在线程安全？(非常重要) 明确哪些代码是多线程运行的代码 明确多个线程是否有共享数据 明确多线程运行代码中是否有多条语句操作共享数据 如何解决呢？（非常重要） 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中。 切记： 范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能 释放锁操作 当前线程的同步方法、同步代码块执行结束。 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁 不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。 应尽量避免使用suspend()和resume()来控制线程 单例设计模式之懒汉式（线程安全） 1234567891011121314151617181920class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.Class){ if(instance == null){ instance = new Singleton(); } } } }}public calss SingletonTest{ public static void main(String[] args){ Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.printIn(s1 == s2); }} 线程的死锁问题 死锁 不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都出处于阻塞状态，无法继续 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.demo.test;class A { public synchronized void foo(B b) { System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 进入了A实例的foo方法\"); // ① try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 企图调用B实例的last方法\"); // ③ b.last(); } public synchronized void last() { System.out.println(\"进入了A类的last方法内部\"); }}class B { public synchronized void bar(A a) { System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 进入了B实例的bar方法\"); // ② try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 企图调用A实例的last方法\"); // ④ a.last(); } public synchronized void last() { System.out.println(\"进入了B类的last方法内部\"); }}public class DeadLock implements Runnable { A a = new A(); B b = new B(); public void init() { Thread.currentThread().setName(\"主线程\"); // 调用a对象的foo方法 a.foo(b); System.out.println(\"进入了主线程之后\"); } public void run() { Thread.currentThread().setName(\"副线程\"); // 调用b对象的bar方法 b.bar(a); System.out.println(\"进入了副线程之后\"); } public static void main(String[] args) { DeadLock dl = new DeadLock(); new Thread(dl).start(); dl.init(); }} Lock(锁)1234567891011Class A{ private final ReentrantLock lock = new ReentrantLock(); public void m(){ lock.lock(); try{ //保证线程安全代码； } finally { lock.unlock(); } }} 注意：如果同步代码有异常，要将 unlock() 写入 finally 语句块 Synchronized 与 Lock 的对比 Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是 隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序： Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源）-&gt; 同步方法（在方法体之外） 练习 银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 问题：该程序是否有安全问题，如果有，如何解决？ 【提示】 明确哪些代码式多线程运行代码，须写入 run() 方法 明确什么是共享数据 明确多线程运行代码中那些语句是操作共享数据的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 银行有一个账户。 有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 分析： 1.是否是多线程问题？ 是，两个储户线程 2.是否有共享数据？ 有，账户（或账户余额） 3.是否有线程安全问题？有 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。 * @author shkstart * @create 2019-02-15 下午 3:54 */class Account{ private double balance; public Account(double balance) { this.balance = balance; } //存钱 public synchronized void deposit(double amt){ if(amt &gt; 0){ balance += amt; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":存钱成功。余额为：\" + balance); } }}class Customer extends Thread{ private Account acct; public Customer(Account acct) { this.acct = acct; } @Override public void run() { for (int i = 0; i &lt; 3; i++) { acct.deposit(1000); } }}public class AccountTest { public static void main(String[] args) { Account acct = new Account(0); Customer c1 = new Customer(acct); Customer c2 = new Customer(acct); c1.setName(\"甲\"); c2.setName(\"乙\"); c1.start(); c2.start(); }} 拓展问题：可否实现两个储户交替存钱操作 线程的通信例题：使用两个线程打印 1-100。线程1，线程2交替打印 wait() 与 notify() 和 notifyAll() wait(): 令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用 notify（）或者 notifyAll（）方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。 notify(): 唤醒正在排队等待同步资源的线程中优先级最高者结束等待。 notifyAll(): 唤醒正在排队等待资源的所有线程结束等待。 这三个方法只有在 synchronized 方法或 synchronized 代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException 异常。 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。 wait() 方法 在当前线程中调用方法：对象名.wait() 使当前线程进入等待（某对象）状态，直到另一线程对该对象发出 notify (或者是 notifyAll) 为止 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 调用此方法后，当前线程将释放对象监控权，然后进入等待 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行 notify() / notifyAll() 在当前线程中调用方法：对象名.notify() 功能：唤醒等待该对象监控权的一个 / 所有线程 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 经典例题：生产者 / 消费者问题 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 这里可能出现两个问题： 生产者比消费者快时，消费者会漏掉一些数据没有取到 消费者比生产者快时，消费者会取相同的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.example.demo.test;class Clerk { //售货员 private int product = 0; public synchronized void addProduct() { if(product &gt;= 20) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { product++; System.out.println(\"生产者生产了第\" + product + \"个产品\"); notifyAll(); } } public synchronized void getProduct() { if(this.product &lt;= 0) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { System.out.println(\"消费者取走了第\" +product + \"个产品\"); product--; notifyAll(); } }}class Productor implements Runnable { //生产者 Clerk clerk; public Productor(Clerk clerk) { this.clerk = clerk; } public void run() { System.out.println(\"生产者开始生产产品。。。\"); while (true) { try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.addProduct(); } }}class Consumer implements Runnable {//消费者 Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } public void run() { System.out.println(\"消费者开始取走产品\"); while (true) { try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.getProduct(); } }}public class BankTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Thread productorThread = new Thread(new Productor(clerk)); Thread consumerThread = new Thread(new Consumer(clerk)); productorThread.start(); consumerThread.start(); }} 练习 模拟银行取钱问题 定义一个Account类 该Account类封装了账户编号（String）和余额（double）两个属性 设置相应属性的getter和setter方法 提供无参和有两个参数的构造器 系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写 提供两个取钱的线程类：小明、小明’s wife 提供了Account类的account属性和double类的取款额的属性 提供带线程名的构造器 run()方法中提供取钱的操作 在主类中创建线程进行测试，考虑线程安全问题 JDK5.0 新增线程创建方式新增方式一：实现 Callable 接口 与使用Runnable相比， Callable功能更强大些 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future 接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等 FutrueTask是Futrue接口的唯一的实现类 FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 新增方式二：使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 … 线程池 API JDK 5.0 起提供了线程池相关API：ExecutorService 和 Executors ExecutorService: 真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable Future submit(Callable task)：执行任务，有返回值，一般用来执行Callable void shutdown() ：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。","link":"/2020/02/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"git扩展知识","text":"Git 的诞生，集中式 vs 分布式，工作区、暂存区和版本库，Git 与 SVN 的区别。 Git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 集中式vs分布式Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 基本概念我们先来理解下Git 工作区、暂存区和版本库概念工作区： 就是你在电脑里能看到的目录。暂存区： 英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。版本库： 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 左侧为工作区，右侧为版本库 在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 .git/objects目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作git commit时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm --cached命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout -- 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行git checkout HEAD . 或者 git checkout HEAD命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别点： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 常见问题1234567891011gitThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; merged0.9.6 新建本地分支后将本地分支推送到远程库, 使用git pull 或者 git push 的时候报错 是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .根据命令行提示只需要执行以下命令即可 git branch –set-upstream-to=origin/远程分支的名字 本地分支的名字如： 1git branch --set-upstream master origin/master Please move or remove them before you can merge在使用git pull时,经常会遇到报错:Please move or remove them before you can merge 这是因为本地有修改,与云端别人提交的修改冲突,又没有merge. 如果确定使用云端的代码,最方便的解决方法是删除本地修改,可以使用以下命令: 1234git clean -d -fx \"\"d -----删除未被添加到git的路径中的文件f -----强制运行x -----删除忽略文件已经对git来说不识别的文件 注意:该命令会删除本地的修改,最好先备份再使用 1234567git clean 参数 -n 显示 将要 删除的 文件 和 目录 -f 删除 文件，-df 删除 文件 和 目录git clean -ngit clean -dfgit clean -f the branch XXX is not fully merged 提示: the branch XXX is not fully merged 解决方法： 使用大写的D 强制删除 git branch -D XXX .gitignore配置语法： 123456以斜杠“/”开头表示目录；以星号“*”通配多个字符；以问号“?”通配单个字符以方括号“[]”包含单个字符的匹配列表；以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 此外，git 对于.gitignore配置文件是按行从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效； 示例：忽略目录 fd1 下的全部内容 1fd1/* 注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； *忽略根目录下的 /fd1/ 目录的全部内容* 1/fd1/* 要注意以上两个示例的区别 1234/*!.gitignore!/fw/bin/!/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录 过滤整个文件夹 1/mtk/ 过滤所有.zip文件 1*.zip 过滤某个具体文件 1/mtk/do.c 注意事项如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。 不要误解了 .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效。 重置.gitignore规则123git rm -r --cached .git add .git commit -m 'update .gitignore' 《Pro Git》学习笔记","link":"/2020/02/26/git%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"},{"title":"io流","text":"File类的使用，File类的使用，File类的使用，缓冲流，转换流，标准输入、输出流，打印流，数据流，对象流，随机存取文件流，NIO.2中Path、Paths、Files类的使用。 File类的使用 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关","link":"/2020/03/17/io%E6%B5%81/"},{"title":"java集合类","text":"本章主要介绍 Java集合框架概述，Collection接口方法，Iterator迭代器接口，Collection子接口一：List，Collection子接口二：Set，Map接口，Collections工具类的使用方法以及相关的 API。 Java集合框架概述 一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。 数组在内存存储方面的特点： 数组初始化以后，长度就确定了。 数组声明的类型，就决定了进行元素初始化时的类型 数组在存储数据方面的弊端： 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数 数组存储的数据是有序的、可以重复的。 &gt;存储数据的特点单一 Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。 Java 集合框架概述：集合的使用场景 Java 集合可分为 Collection 和 Map 两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 Set：元素无序、不可重复的集合 Set：元素无序、不可重复的集合 Java 集合框架概述：Collection接口继承树 JDK提供的集合API位于java.util包内 Java 集合框架概述：Map接口继承树 Collection接口方法Collection 接口 Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。 JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。 添加 add(Object obj) addAll(Collection coll) 获取有效元素的个数 int size() 清空集合 void clear() 是否是空集合 boolean isEmpty() 是否包含某个元素 boolean contains(Object obj)：是通过元素的equals方法来判断是否 是同一个对象 boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。 删除 boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 boolean removeAll(Collection coll)：取当前集合的差集 取两个集合的交集 boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c 集合是否相等 boolean equals(Object obj) 转成对象数组 Object[] toArray() 获取集合对象的哈希值 hashCode() 遍历 iterator()：返回迭代器对象，用于集合遍历 Iterator迭代器接口Iterator迭代器接口 Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 Iterator接口的方法 在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。 Iterator接口remove()方法 1234567Iterator iter = coll.iterator();//回到起点while(iter.hasNext()){ Object obj = iter.next(); if(obj.equals(\"Tom\")){ iter.remove(); }} 注意： Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。 使用 foreach 循环遍历集合元素 Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。 遍历集合的底层调用Iterator完成操作。 foreach还可以用来遍历数组。 练习：判断输出结果为何？ 123456789101112public class ForTest { public static void main(String[] args) { String[] str = new String[5]; for (String myStr : str) { myStr = \"xianrenqiu ....\"; System.out.println(myStr); // xianrenqiu .... } for (int i = 0; i &lt; str.length; i++) { System.out.println(str[i]); // null .... } }} Collection子接口之一：List接口List接口概述 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 List接口方法 List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。 void add(int index, Object ele):在index位置插入ele元素 boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 Object get(int index):获取指定index位置的元素 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 List实现类之一：ArrayList ArrayList 是 List 接口的典型实现类、主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 ArrayList的JDK1.8之前与之后的实现区别？ JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 【面试题】 1234567891011121314151617/*** 注意 remove(int index) 和 remove(Object obj);**/@Testpublic void testListRemove() { List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list);// [1,2]}private static void updateList(List list) { list.remove(2); //list.remove(new Integer(2));} List实现类之二：LinkedList 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。 新增方法： void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last， 用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基 本结构。Node除了保存数据，还定义了两个变量： prev变量记录前一个元素的位置 next变量记录下一个元素的位置 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} List 实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用 新增方法： void addElement(Object obj) void insertElementAt(Object obj,int index) void setElementAt(Object obj,int index) void removeElement(Object obj) void removeAllElements() 【面试题】： 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? ArrayList和LinkedList的异同 二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。 ArrayList和Vector的区别 Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。 Collection子接口之二：Set接口Set 接口概述 Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法 Set实现类之一：HashSet HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 HashSet 具有以下特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。 向HashSet中添加元素的过程： 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散 列函数设计的越好） 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128 等） 重写 hashCode() 方法的基本原则 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 重写 equals() 方法的基本原则 以自定义的Customer类为例，何时需要重写equals()？ 当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不 同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法， 它们仅仅是两个对象。 因此，违反了“相等的对象必须具有相等的散列码”。 结论：复写 equals 方法的时候一般都需要同时腹泻 hashCode 方法。通常参与计算机 hashCode 的对象的属性也应该参与到 equals() 中进行计算。 Eclipse/IDEA 工具里 hashCode() 的重写 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突） 并且31只占用5bits,相乘造成数据溢出的概率较小。 31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率） 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置， 但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。 LinkedHashSet 不允许集合元素重复。 12345Set set = new LinkedHashSet(); set.add(new String(\"AA\")); set.add(456);set.add(456);set.add(new Customer(\"刘德华\", 1001)); LinkedHashSet底层结构 Set实现类之三：TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。 TreeSet底层使用红黑树结构存储数据 新增的方法如下：（了解） Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。 TreeSet 和后面要讲的TreeMap采用红黑树的存储结构 特点：有序，查找速度比List 快 排序-自然排序 自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable接口。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 Comparable 的典型实现： BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较 Character：按字符的 unicode值来进行比较 Boolean：true 对应的包装类实例大于 false 对应的包装类实例 String：按字符串中字符的 unicode 值进行比较 Date、Time：后边的时间、日期比前面的时间、日期大 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。 排序-定制排序 TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。 【面试题】 12345678910111213141516171819202122/** * 注意先 用 hashCode 判断 hash 值是否相等， 然后再用 equals 作比较。 */@Testpublic void test3(){ HashSet set = new HashSet(); Person p1 = new Person(1001,\"AA\"); Person p2 = new Person(1002,\"BB\"); set.add(p1); set.add(p2); System.out.println(set); p1.name = \"CC\"; set.remove(p1); System.out.println(set); set.add(new Person(1001,\"CC\")); System.out.println(set); set.add(new Person(1001,\"AA\")); System.out.println(set);} 练习：在List内去除重复数字值，要求尽量简单 123456789101112131415161718//在List内去除重复数字值，要求尽量简单public static List duplicateList(List list) { HashSet set = new HashSet(); set.addAll(list); return new ArrayList(set);}public static void main(String[] args) { List list = new ArrayList(); list.add(new Integer(1)); list.add(new Integer(2)); list.add(new Integer(2)); list.add(new Integer(4)); list.add(new Integer(4)); List list2 = duplicateList(list); for (Object integer : list2) { System.out.println(integer); }} Map接口 Map接口概述 y=f(x) (x1,y1) (x2,y2),… Map与Collection并列存在。用于保存具有映射关系的数据:key-value Map 中的 key 和 value 都可以是任何引用类型的数据 Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法 常用String类作为Map的“键” key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类 Map 接口：常用方法 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对，存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value Int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法: Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 12345678910111213141516171819202122Map map = new HashMap();//map.put(..,..)省略System.out.println(\"map的所有key:\"); Set keys = map.keySet();// HashSetfor (Object key : keys) { System.out.println(key + \"-&gt;\" + map.get(key));}------------------------------------------------------------System.out.println(\"map的所有的value：\"); Collection values = map.values();Iterator iter = values.iterator();while (iter.hasNext()) { System.out.println(iter.next());}-------------------------------------------------------------System.out.println(\"map所有的映射关系：\");// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口Set mappings = map.entrySet();for (Object mapping : mappings) { Map.Entry entry = (Map.Entry) mapping; System.out.println(\"key是：\" + entry.getKey() + \"，value是：\" + entry.getValue());} Map实现类之一：HashMap HashMap是 Map 接口使用频率最高的实现类。 允许使用null键和null值，与HashSet一样，不保证映射的顺序。 所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode() 所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals() 一个key-value构成一个entry 所有的entry构成的集合是Set:无序的、不可重复的 HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true， hashCode 值也相等。 HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。 HashMap的存储结构 JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。 HashMap源码中的重要常量 DEFAULT_INITIAL_CAPACITY : HashMap 的默认容量，16 MAXIMUM_CAPACITY ： HashMap 的最大支持容量 ，2^30 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树 UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。） table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数。 threshold：扩容的临界值，=容量*填充因子 HashMap的存储结构：JDK 1.8之前 HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时， 系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时， 系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引 用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。 添加的元素过程： 向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。 HashMap的扩容: 当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么HashMap什么时候进行扩容呢？ 当HashMap 中的元素个数超过数组大小( 数组总大小length, 不是数组中个数size) * loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况 下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16 * 0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能。 HashMap的存储结构：JDK 1.8 HashMap 的内部存储结构其实是 数组+链表+树的结合。当实例化一个 HashMap 时，会初始化 initl ialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为 “桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。 那么HashMap什么时候进行扩容和树形化呢？ 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) * loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认 情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中 元素个数超过16 * 0.75=12（这个值就是代码中的threshold值，也叫做临界值） 的时候，就把数组的大小扩展为 2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。 关于映射关系的key是否可以修改？answer：不要修改 映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关 系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。 总结：JDK1.8相较于之前的变化： HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组 当首次调用map.put()时，再创建长度为16的数组 .数组为Node类型，在jdk7中称为Entry类型 形成链表结构时，新添加的key-value对在链表的尾部（七上八下） 当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储 【面试题：】 谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244/** * 一、Map的实现类的结构： * |----Map:双列数据，存储key-value对的数据 ---类似于高中的函数：y = f(x) * |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value * |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 * 原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 * 对于频繁的遍历操作，此类执行效率高于HashMap。 * |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 * 底层使用红黑树 * |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value * |----Properties:常用来处理配置文件。key和value都是String类型 * * * HashMap的底层：数组+链表 （jdk7及之前） * 数组+链表+红黑树 （jdk 8） * * * 面试题： * 1. HashMap的底层实现原理？ * 2. HashMap 和 Hashtable的异同？ * 3. CurrentHashMap 与 Hashtable的异同？（暂时不讲） * * 二、Map结构的理解： * Map中的key:无序的、不可重复的，使用Set存储所有的key ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例） * Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals() * 一个键值对：key-value构成了一个Entry对象。 * Map中的entry:无序的、不可重复的，使用Set存储所有的entry * * 三、HashMap的底层实现原理？以jdk7为例说明： * HashMap map = new HashMap(): * 在实例化以后，底层创建了长度是16的一维数组Entry[] table。 * ...可能已经执行过多次put... * map.put(key1,value1): * 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 * 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1 * 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据 * 的哈希值： * 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2 * 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： * 如果equals()返回false:此时key1-value1添加成功。----情况3 * 如果equals()返回true:使用value1替换value2。 * * 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 * * 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 * * jdk8 相较于jdk7在底层实现方面的不同： * 1. new HashMap():底层没有创建一个长度为16的数组 * 2. jdk 8底层的数组是：Node[],而非Entry[] * 3. 首次调用put()方法时，底层创建长度为16的数组 * 4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 * 4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 * * DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 * DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 * threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 * TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 * MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 * * 四、LinkedHashMap的底层实现原理（了解） * 源码中： * static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } * * * 五、Map中定义的方法： 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 *总结：常用方法： * 添加：put(Object key,Object value) * 删除：remove(Object key) * 修改：put(Object key,Object value) * 查询：get(Object key) * 长度：size() * 遍历：keySet() / values() / entrySet() * * * @author shkstart * @create 2019 上午 11:15 */public class MapTest { /* 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 */ @Test public void test5(){ Map map = new HashMap(); map.put(\"AA\",123); map.put(45,1234); map.put(\"BB\",56); //遍历所有的key集：keySet() Set set = map.keySet(); Iterator iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } System.out.println(); //遍历所有的value集：values() Collection values = map.values(); for(Object obj : values){ System.out.println(obj); } System.out.println(); //遍历所有的key-value //方式一：entrySet() Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext()){ Object obj = iterator1.next(); //entrySet集合中的元素都是entry Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + \"----&gt;\" + entry.getValue()); } System.out.println(); //方式二： Set keySet = map.keySet(); Iterator iterator2 = keySet.iterator(); while(iterator2.hasNext()){ Object key = iterator2.next(); Object value = map.get(key); System.out.println(key + \"=====\" + value); } } /* 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 */ @Test public void test4(){ Map map = new HashMap(); map.put(\"AA\",123); map.put(45,123); map.put(\"BB\",56); // Object get(Object key) System.out.println(map.get(45)); //containsKey(Object key) boolean isExist = map.containsKey(\"BB\"); System.out.println(isExist); isExist = map.containsValue(123); System.out.println(isExist); map.clear(); System.out.println(map.isEmpty()); } /* 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 */ @Test public void test3(){ Map map = new HashMap(); //添加 map.put(\"AA\",123); map.put(45,123); map.put(\"BB\",56); //修改 map.put(\"AA\",87); System.out.println(map); Map map1 = new HashMap(); map1.put(\"CC\",123); map1.put(\"DD\",123); map.putAll(map1); System.out.println(map); //remove(Object key) Object value = map.remove(\"CC\"); System.out.println(value); System.out.println(map); //clear() map.clear();//与map = null操作不同 System.out.println(map.size()); System.out.println(map); } @Test public void test2(){ Map map = new HashMap(); map = new LinkedHashMap(); map.put(123,\"AA\"); map.put(345,\"BB\"); map.put(12,\"CC\"); System.out.println(map); } @Test public void test1(){ Map map = new HashMap();// map = new Hashtable(); map.put(null,123); }} 负载因子值的大小，对HashMap有什么影响？ 负载因子的大小决定了HashMap的数据密度。 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序 与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致 HashMap中的内部类：Node 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next;} LinkedHashMap中的内部类：Entry 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after;s Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} Map实现类之三：TreeMap TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。 TreeMap底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 Map实现类之四：Hashtable Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 Map实现类之五：Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 1234Properties pros = new Properties();pros.load(new FileInputStream(\"jdbc.properties\")); String user = pros.getProperty(\"user\"); System.out.println(user); Collections工具类 Collections 是一个操作 Set、List 和 Map 等集合的工具类 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 排序操作：（均为static方法） reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 Collections常用方法查找、替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值 Collections常用方法：同步控制 Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 补充：Enumeration Enumeration 接口是 Iterator 迭代器的 “古老版本” 12345Enumeration stringEnum = new StringTokenizer(\"a-b*c-d-e-g\", \"-\");while(stringEnum.hasMoreElements()){ Object obj = stringEnum.nextElement(); System.out.println(obj);} 练习 请从键盘随机输入10个整数保存到List中，并按倒序、从大到小的顺序显示出来。 请把学生名与考试分数录入到集合中，并按分数显示前三名成绩学员的名字。 练习 练习 对一个Java源文件中的关键字进行计数。 提示：Java源文件中的每一个单词，需要确定该单词是否是一个关键字。为了高效处理这个问题，将所有的关键字保存在一个HashSet中。用contains() 来测试。 123456File file = new File(\"Test.java\"); Scanner scanner = new Scanner(file); while(scanner.hasNext()){ String word = scanner.next(); System.out.println(word);}","link":"/2020/03/09/java%E9%9B%86%E5%90%88%E7%B1%BB/"},{"title":"枚举类与注解","text":"主要记录枚举类与注解使用的方法，及相关使用的 API。 枚举类的使用主要内容 如何自定义枚举类 如何使用关键字enum定义枚举类 Enum类的主要方法 实现接口的枚举类 常见的使用方式及场景： 类的对象只有有限个，确定的。举例如下： 星期：Monday(星期一)、…、Sunday(星期天) 性别：Man(男)、Woman(女) 季节：Spring(春节). Winter(冬天) 支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银 行卡)、CreditCard(信用卡) 就职状态：Busy、Free、Vocation、Dimission 订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、Return（退货）、Checked（已确认）Fulfilled（已配货） 线程状态：创建、就绪、运行、阻塞、死亡 当需要定义一组常量时，强烈建议使用枚举类 枚举类的实现 JDK1.5之前需要自定义枚举类 JDK 1.5 新增的 enum 关键字用于定义枚举类 若枚举只有一个对象, 则可以作为一种单例模式的实现方式。 枚举类的属性 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 自定义枚举类 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：public static final 对象如果有实例变量，应该声明为private final，并在构造器中初始化 123456789101112class Season{ private final String SEASONNAME;//季节的名称 private final String SEASONDESC;//季节的描述 private Season(String seasonName,String seasonDesc){ this.SEASONNAME = seasonName; this.SEASONDESC = seasonDesc; } public static final Season SPRING = new Season(\"春天\", \"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\", \"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\", \"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\", \"白雪皑皑\");} 使用enum定义枚举类 使用说明 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类 枚举类的构造器只能使用 private 权限修饰符 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰 必须在枚举类的第一行声明枚举类对象 JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。 123456789101112131415161718public enum SeasonEnum { SPRING(\"春天\",\"春风又绿江南岸\"), SUMMER(\"夏天\",\"映日荷花别样红\"), AUTUMN(\"秋天\",\"秋水共长天一色\"), WINTER(\"冬天\",\"窗含西岭千秋雪\"); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) { this.seasonName =seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; }} 测试使用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 一、枚举类的使用 * 1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 * 2.当需要定义一组常量时，强烈建议使用枚举类 * 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 * * 二、如何定义枚举类 * 方式一：jdk5.0之前，自定义枚举类 * 方式二：jdk5.0，可以使用enum关键字定义枚举类 * * 三、Enum类中的常用方法： * values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 * valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 * toString()：返回当前枚举类对象常量的名称 * * 四、使用enum关键字定义的枚举类实现接口的情况 * 情况一：实现接口，在enum类中实现抽象方法 * 情况二：让枚举类的对象分别实现接口中的抽象方法 */public class SeasonTest { public static void main(String[] args) { Season spring = Season.SPRING; System.out.println(spring); }}//自定义枚举类class Season{ //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(\"春天\",\"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\",\"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\",\"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\",\"冰天雪地\"); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求1：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; }} 方法名 详细描述 valueOf 传递枚举类型的Class对象和枚举常量名称給静态方法valueOf,会得到与参数匹配的枚举常量。 toString 得到当前枚举常量的名称。你可以通过重写这个方法来使得到的结果更易读。 equals 在枚举类型中可以直接使用”==”来比较两个枚举常量是否相等。Enum提供的这个equals0方法，也是直接使用“==“实现的。它的存在是为了在Set、List和Map中使用。注意，equals()是不 可变的。 hashCode Enum实现了hashCode0来和equals0保持一致。 它也是不可变的。 getDeclaringClass getDeclaringClass得到枚举 常量所属枚举类型的Class 对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。 name 得到当前枚举常量的名称。建议优先使用toString0。 ordinal 得到当前枚举常量的次序。 compareTo 枚举类型实现了Comparable接口，这样可以比较两个枚举常量的大小(按照声明的顺序排列) clone 枚举类型不能被Clone.为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException 异常的不变Clone0。 Enum类的主要方法： values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 使用enum关键字定义枚举类 * 说明：定义的枚举类默认继承于java.lang.Enum类 * * @author shkstart * @create 2019 上午 10:35 */public class SeasonTest1 { public static void main(String[] args) { Season1 summer = Season1.SUMMER; //toString():返回枚举类对象的名称 System.out.println(summer.toString());// System.out.println(Season1.class.getSuperclass()); System.out.println(\"****************\"); //values():返回所有的枚举类对象构成的数组 Season1[] values = Season1.values(); for(int i = 0;i &lt; values.length;i++){ System.out.println(values[i]); values[i].show(); } System.out.println(\"****************\"); Thread.State[] values1 = Thread.State.values(); for (int i = 0; i &lt; values1.length; i++) { System.out.println(values1[i]); } //valueOf(String objName):返回枚举类中对象名是objName的对象。 Season1 winter = Season1.valueOf(\"WINTER\"); //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException// Season1 winter = Season1.valueOf(\"WINTER1\"); System.out.println(winter); winter.show(); }}interface Info{ void show();}//使用enum关键字枚举类enum Season1 implements Info{ //1.提供当前枚举类的对象，多个对象之间用\",\"隔开，末尾对象\";\"结束 SPRING(\"春天\",\"春暖花开\"){ @Override public void show() { System.out.println(\"春天在哪里？\"); } }, SUMMER(\"夏天\",\"夏日炎炎\"){ @Override public void show() { System.out.println(\"宁夏\"); } }, AUTUMN(\"秋天\",\"秋高气爽\"){ @Override public void show() { System.out.println(\"秋天不回来\"); } }, WINTER(\"冬天\",\"冰天雪地\"){ @Override public void show() { System.out.println(\"大约在冬季\"); } }; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; }// //4.其他诉求1：提供toString()//// @Override// public String toString() {// return \"Season1{\" +// \"seasonName='\" + seasonName + '\\'' +// \", seasonDesc='\" + seasonDesc + '\\'' +// '}';// }// @Override// public void show() {// System.out.println(\"这是一个季节\");// }} 注解（Annotation）主要内容： 注解(Annotation)概述 常见的Annotation示例 自定义Annotation JDK中的元注解 利用反射获取注解信息（在反射部分涉及） JDK 8中注解的新特性 从 JDK 5.0 开始，java 增加了对元数据（MetaData）的支持也就是Annotation(注解) Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于 修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在 Annotation的“name = value” 对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能， 忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 使用 Annotation 时要在其前面增加 @符号，并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。 示例一：生成文档相关的注解 @author 标明开发该类模块的作者，多个作者之间使用,分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写 其中：@param @return 和 @exception 这三个标记都是只用于方法的。 ​ @param的格式要求：@param 形参名形参类型 形参说明 ​ @return 的格式要求：@return 返回值类型返回值说明 ​ @exception的格式要求：@exception 异常类型 异常说明 ​ @param和@exception可以并列多个 12345678910111213141516171819202122package com.annotation.javadoc;/***@author 仙人球*@version 1.0*@see Math.java*/public class JavadocTest { /** *程序的主方法，程序的入口 *@param args String[] 命令行参数 */ public static void main(String[] args) { } /** *求圆面积的方法 *@param radius double 半径值 *@return double 圆的面积 */ public static double getArea(double radius){ return Math.PI * radius * radius; }} 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 12345678910111213141516package com.annotation.javadoc;public class AnnotationTest{ public static void main(String[] args) { @SuppressWarnings(\"unused\") int a = 10; } @Deprecated public void print(){ System.out.println(\"过时的方法\"); } @Override public String toString() { return \"重写的toString方法()\"; }} 示例三：跟踪代码依赖性，实现替代配置文件功能 Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。 12345678910111213141516@WebServlet(&quot;/login&quot;)public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response);}&lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; spring框架中关于“事务”的管理 1234567891011121314151617@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)public void buyBook(String username, String isbn) { //1.查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); //2. 更新库存 bookShopDao.updateBookStock(isbn); //3. 更新用户的余额 bookShopDao.updateUserAccount(username, price);}&lt;!-- 配置事务属性 --&gt;&lt;tx:advice transaction-manager=\"dataSourceTransactionManager\" id=\"txAdvice\"&gt;&lt;tx:attributes&gt;&lt;!-- 配置每个方法使用的事务属性--&gt;&lt;tx:method name=\"buyBook\" propagation=\"REQUIRES_NEW\" isolation=\"READ_COMMITTED\" read-only=\"false\" timeout=\"3\" /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt; 自定义 Annotation 定义新的 Annotation 类型使用 @interface 关键字 自定义注解自动继承了 java.lang.annotation.Annotation 接口 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 可以在定义 Annotation 的成员变量时为其指定初始值，指定成员变量的初始值可以使用 default 关键字 如果 只有一个参数成员，建议使用参数名为 value 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value， 可以省略“value=” 没有成员定义的 Annotation 称为标记；包含成员变量的 Annotation 称为元数据 Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义。 1234567891011121314151617@MyAnnotation(value=\"尚硅谷\")public class MyAnnotationTest { public static void main(String[] args) { Class clazz = MyAnnotationTest.class; Annotation a = clazz.getAnnotation(MyAnnotation.class); MyAnnotation m = (MyAnnotation) a; String info = m.value(); System.out.println(info); }}---------------------------------------------------------@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE) @interface MyAnnotation{ String value() default \"xianrenqiu\";} JDK 中的元注解 JDK 的元 Annotation 用于修饰其他 Annotation 定义 JDK5.0 提供了4个标准的 meta-annotation 类型，分别是： Retention Target Documented Inherited 元数据的理解：String name = “xianrenqiu”; @Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: RetentionPolicy.SOURCE: 在源文件中有效（即源文件保留），编译器直接丢弃这种策略的 RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值 RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。 12345678910public enum RetentionPolicy{ SOURCE, CLASS, RUNTIME}@Retention(RetentionPolicy.SOURCE)@interface MyAnnotation1{ }@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2{ } @Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。@Target 也包含一个名为 value 的成员变量。 取值(ElementType) 取值(ElementType) CONSTRUCTOR 用于描述构造器 PACKAGE 用于描述包 FIELD 用于描述域 PARAMETER 用于描述参数 LOCAL_ VARIABLE 用于描述局部变量 TYPE 用于描述类、接口(包括注解类型)或enum声明 METHOD 用于描述方法 @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为RUNTIME。 @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解 实际应用中，使用较少 练习 编写一个Person类，使用Override注解它的toString方法 自定义一个名为“MyTiger”的注解类型，它只可以使用在方法上，带一个String类型的value属性，然后第1题中的Person类上正确使用。 利用反射获取注解信息 JDK 5.0 在 java.lang.reflect 包下新增了AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素 当一个Annotation 类型被定义为运行时Annotation 后, 该注解才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取 程序可以调用 AnnotatedElement对象的如下方法来访问 Annotation 信息 JDK8 中注解的特新性Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外， 反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。 可重复注解示例： 类型注解： JDK1.8之后,关于元注解@Target的参数类型ElementType枚举值多了两:TYPE_PARAMETER,TYPE_USE。 在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 123456789public class TestTypeDefine&lt;@TypeDefine() U&gt; { private U u; public &lt;@TypeDefine() T&gt; void test(T t){ }}-----------------------------------------------@Target({ElementType.TYPE_PARAMETER})@interface TypeDefine{} 123456789101112131415161718192021@MyAnnotationpublic class AnnotationTest&lt;U&gt; { @MyAnnotation private String name; public static void main(String[] args) { AnnotationTest&lt;@MyAnnotation String&gt; t = null; int a = (@MyAnnotation int) 2L; @MyAnnotation int b = 10; } public static &lt;@MyAnnotation T&gt; void method(T t) { } public static void test(@MyAnnotation String arg) throws @MyAnnotation Exception { }}@Target(ElementType.TYPE_USE) @interface MyAnnotation {} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/** * 注解的使用 * * 1. 理解Annotation: * ① jdk 5.0 新增的功能 * * ② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, * 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 * * ③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android * 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 * 代码和XML配置等。 * * 2. Annocation的使用示例 * 示例一：生成文档相关的注解 * 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 * 示例三：跟踪代码依赖性，实现替代配置文件功能 * * 3. 如何自定义注解：参照@SuppressWarnings定义 * ① 注解声明为：@interface * ② 内部定义成员，通常使用value表示 * ③ 可以指定成员的默认值，使用default定义 * ④ 如果自定义注解没有成员，表明是一个标识作用。 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。 自定义注解通过都会指明两个元注解：Retention、Target 4. jdk 提供的4种元注解 元注解：对现有的注解进行解释说明的注解 Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为）\\RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取。 Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 *******出现的频率较低******* Documented:表示所修饰的注解在被javadoc解析时，保留下来。 Inherited:被它修饰的 Annotation 将具有继承性。 5.通过反射获取注解信息 ---到反射内容时系统讲解 6. jdk 8 中注解的新特性：可重复注解、类型注解 6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 6.2 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 */public class AnnotationTest { public static void main(String[] args) { Person p = new Student(); p.walk(); Date date = new Date(2020, 10, 11); System.out.println(date); @SuppressWarnings(\"unused\") int num = 10;// System.out.println(num); @SuppressWarnings({ \"unused\", \"rawtypes\" }) ArrayList list = new ArrayList(); } @Test public void testGetAnnotation(){ Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); for(int i = 0;i &lt; annotations.length;i++){ System.out.println(annotations[i]); } }}//jdk 8之前的写法：//@MyAnnotations({@MyAnnotation(value=\"hi\"),@MyAnnotation(value=\"hi\")})@MyAnnotation(value=\"hi\")@MyAnnotation(value=\"abc\")class Person{ private String name; private int age; public Person() { } @MyAnnotation public Person(String name, int age) { this.name = name; this.age = age; } @MyAnnotation public void walk(){ System.out.println(\"人走路\"); } public void eat(){ System.out.println(\"人吃饭\"); }}interface Info{ void show();}class Student extends Person implements Info{ @Override public void walk() { System.out.println(\"学生走路\"); } public void show() { }}class Generic&lt;@MyAnnotation T&gt;{ public void show() throws @MyAnnotation RuntimeException{ ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;(); int num = (@MyAnnotation int) 10L; }}----------------------------------------------------------------------@Inherited@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE})public @interface MyAnnotation { String value() default \"hello\";}----------------------------------------------------------------------@Inherited@Retention(RetentionPolicy.RUNTIME)@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})public @interface MyAnnotations { MyAnnotation[] value();}","link":"/2020/03/06/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"},{"title":"Sketch v63.1中文破解版","text":"Sketch for Mac是一款运行在macOS平台上的绘图工具。Sketch for Mac 破解版具有免费调色板，面板，菜单，窗口等功能，与此同时Sketch Mac中文破解版提供了功能强大的矢量绘图和文字工具，Sketch Mac版以简约的设计带给用户最好的体验! 下载：密码ak0w 安装包损坏，打不开怎么处理？打不开“XXX”,因为它来自身份不明的开发者怎么处理？点击查看：解决办法 macOS 10.15 Catalina 提示 xxx.app已损坏，无法打开 *\\***Sketch v63.1中文破解版**/激活版******** *\\***Sketch V61.2中文破解/激活版******** *\\*Sketch V61.1中文破解/激活版**** \\Sketch V61.0中文破解/激活版** \\Sketch V60.0**中文破解/激活版*\\*** \\Sketch V59.1中文破解/激活版** \\Sketch V59.0中文破解/激活版** Sketch V58.0中文破解/激活版 Sketch V57.1中文破解/激活版 …… Sketch Mac破解说明 1.下载完成安装包后，双击打开，将左侧【Sketch】拖拽至右侧应用程序，默认安装。若遇到意外或者无法打开的情况，请参照上面链接方式把mac允许任何来源打开。","link":"/2020/02/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"使用Vagrant创建Centos虚拟机","text":"Vagrant是一款由HashiCorp公司提供的，用于快速构建虚拟机环境的软件。本节我们将使用Vagrant结合Oracle VM VirtualBox快速地在win10环境下构建CentOS7虚拟机。在此之前需要先安装好 Vagrant 和 VirtualBox。 构建CentOS7虚拟机 在https://app.vagrantup.com/boxes/search下搜索centos： 然后在win10任意盘符下创建vagrant_vm目录（注意目录最好不要有中文和空格），然后在该目录下使用cmd执行vagrant init centos/7命令： 然后执行 vagrant up启动（这时候最好也打开VirtualBox）： 构建完毕，这时候VirtualBox的列表里会出现一台正在运行的虚拟机： 这就是我们刚刚通过Vagrant构建的CentOS7虚拟机了。 如果当你执行vagrant up命令后，虚拟机文件下载非常的慢的话，可以使用下面这种方式来构建： 在上面的日志中可以找到这么一行： 1Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1902.01/providers/virtualbox.box 后面这个URL就是下载地址了，将它黏贴到迅雷等下载工具下载即可。然后将下载好后的xxx.box文件复制到vagrant_vm目录下，并且重命名为centos7.box（删除centos7.box之外的文件和目录，只保留centos7.box一个文件）。 接着运行vagrant box add -name 'centos/7' centos7.box命令： 添加成功后执行vagrant init centos/7初始化： 初始化成功后执行vagrant up启动： 构建成功，效果和一开始在线下载构建是一样的。 连接虚拟机我们先用 vagrant status命令查看一下虚拟机的状态： 可以看到虚拟机是运行中的状态，我们可以执行vagrant halt来关闭虚拟机： 启动虚拟机的命令为vagrant up，我们也可以使用vagrant suspend命令来暂停运行中的虚拟机，以保持它的运行状态： 暂停后可以使用vagrant resume命令来恢复虚拟机： 连接正在运行中的虚拟机的命令为vagrant ssh： 重启虚拟机使用的命令为vagrant reload。如果你不想要这个虚拟机的话可以使用vagrant distroy命令进行销毁。 目录共享 Vagrant的根目录（就是我们一开始创建的vagrant_vm）和虚拟机里的/vagrant目录是共享的。我们在vagrant_vm目录下新建一个hello.txt文件，内容为hello： 然后连接虚拟机，查看虚拟机/vagrant目录下有什么内容（必须重启虚拟机才能看到共享文件）: 说明同步成功。 我们也可以自定义共享路劲，编辑vagrant_vm文件夹下的Vagrantfile文件： 在这行下面添加如下配置： 1config.vm.synced_folder \"./data\", \"/vagrant_data\", create:true, owner: \"root\", group: \"root\" 这个配置的意思是将当前路径下的data文件夹和虚拟机的/share目录共享，拥有者为root，群组为root，如果路径不存在则创建。 修改了Vagrantfile文件需要执行 vagrant reload重启。重启后我们在data文件夹下新建一个hello.txt文件，然后连接虚拟机看看是否共享成功： 共享成功！ 在这途中，遇到了如下问题: 123456789101112Vagrant was unable to mount VirtualBox shared folders. This is usuallybecause the filesystem \"vboxsf\" is not available. This filesystem ismade available via the VirtualBox Guest Additions and kernel module.Please verify that these guest additions are properly installed in theguest. This is not a bug in Vagrant and is usually caused by a faultyVagrant box. For context, the command attempted was:mount -t vboxsf -o uid=0,gid=0 vagrant_data /vagrant_dataThe error output from the command was:mount: unknown filesystem type 'vboxsf' 安装下面这个插件可解决问题： 1vagrant plugin install vagrant-vbguest 网络配置虚拟机私有网络在Vagrantfile里打开下面这行配置： 修改成和自己IP在同一网段 然后使用命令vagrant reload重启虚拟机，重启后我们使用ping命令看是否可以在windows上访问到这个ip： 访问成功，连接虚拟机，使用ip addr查看其IP： 正是我们刚刚配置的那个IP。 虚拟机公有网络 编辑Vagrantfile，将我们刚刚开启的私有网络配置注释，然后开启下面这行配置： 虚拟机IP要和本机IP在同一网段 然后重启虚拟机，重启过程中会然你根据当前网络环境选择： 如果是连接的无线网选择第四个选项，重启好后连接虚拟机，查看其IP： 新开一个cmd窗口，ping 这个地址看是否能通: 公有网络和私有网络的区别是：在同一个局域网、wifi网络下的其他设备也是可以访问这个IP地址的。 比如我们在windows浏览器里输入http://192.168.1.200/： 如果centos 中没有安装 httpd 服务器 运行一下命令进行安装启动 yum -y install httpd systemctl start httpd.service 然后让手机连接和电脑相同的wifi网络，并且访问http://192.168.1.200/： 结果说明公有网络配置成功。 多主机配置使用Vagrant可以轻松地创建多台虚拟主机。下面我们开始通过Vagrant来创建两台新的虚拟主机“prod”和“dev”。 在vagrant_vm目录下新建一个目录，名称为multi，然后通过现有的box来初始化一个Vagrantfile配置： 接着编辑multi目录下的Vagrantfile文件，新增下面两项配置： 运行vagrant status： 可以看到多了两台状态为not created的虚拟机，名称分别为“prod”和“dev”。 我们可以使用vagrant up来启动两台主机，也可以通过vagrant up prod来单独启动“prod”这台虚拟主机。 启动后（第一次启动耗时可能比较长），使用vagrant status来查看它们的状态： 通过vagrant ssh 主机名就可以连接上它们了。 网络配置 接下来开始配置网络，让它们之间可以通讯。 我们按照上面介绍网络配置的方式来为这两台虚拟主机配置私有网络： 值得注意的是，在配置私有网络的时候，IP网段不能和Windows主机相同。 配置好后重启这两台虚拟机，然后分别连接这两台虚拟机，看是否能够ping通： 配置成功。 自定义主机名编辑Vagrantfile，添加如下配置： 重启后，连接虚拟机，可以看到hostname已经修改为我们设置的名称了： 多主机的共享目录默认的这两台虚拟主机的/vagrant和当前目录multi/是共享的。我们也可以分别为它们设置不同的共享目录。 编辑Vagrantfile，添加如下配置： 然后重启这两台虚拟主机就好了。 如果没有创建文件需要配置自动创建，拥有者为root，群组为root： create:true, owner: &quot;root&quot;, group: &quot;root&quot; 更多Vagrant的配置可以查看官方文档：https://www.vagrantup.com/docs/","link":"/2020/04/08/%E4%BD%BF%E7%94%A8Vagrant%E5%88%9B%E5%BB%BACentos%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"git windows Linux","slug":"git-windows-Linux","link":"/tags/git-windows-Linux/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"idea IntelliJ IDEA jetbrains","slug":"idea-IntelliJ-IDEA-jetbrains","link":"/tags/idea-IntelliJ-IDEA-jetbrains/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"java高级","slug":"java高级","link":"/tags/java%E9%AB%98%E7%BA%A7/"},{"name":"Java 多线程","slug":"Java-多线程","link":"/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"IO 流","slug":"IO-流","link":"/tags/IO-%E6%B5%81/"},{"name":"enum annotation","slug":"enum-annotation","link":"/tags/enum-annotation/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Ps","slug":"Ps","link":"/tags/Ps/"},{"name":"Sketch","slug":"Sketch","link":"/tags/Sketch/"},{"name":"vagrant","slug":"vagrant","link":"/tags/vagrant/"}],"categories":[{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"注册码破解idea","slug":"注册码破解idea","link":"/categories/%E6%B3%A8%E5%86%8C%E7%A0%81%E7%A0%B4%E8%A7%A3idea/"},{"name":"java中常用的类","slug":"java中常用的类","link":"/categories/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB/"},{"name":"泛型","slug":"泛型","link":"/categories/%E6%B3%9B%E5%9E%8B/"},{"name":"线程的基本概念以及使用","slug":"线程的基本概念以及使用","link":"/categories/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"name":"Java高级","slug":"Java高级","link":"/categories/Java%E9%AB%98%E7%BA%A7/"},{"name":"List Set Map","slug":"List-Set-Map","link":"/categories/List-Set-Map/"},{"name":"enum annotation","slug":"enum-annotation","link":"/categories/enum-annotation/"},{"name":"破解Sketch方法及安装包","slug":"破解Sketch方法及安装包","link":"/categories/%E7%A0%B4%E8%A7%A3Sketch%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/"},{"name":"vagrant","slug":"vagrant","link":"/categories/vagrant/"}]}