{"pages":[],"posts":[{"title":"Docker 安装 fastdfs","text":"环境准备。 libfastcommonV1.0.7.tar.gz FastDFS_v5.05.tar.gz nginx-1.13.6.tar.gz fastdfs-nginx-module_v1.16.tar.gz 创建工作目录在 Linux 服务器上创建 /usr/local/docker/fastdfs/environmen 目录。 说明： /usr/local/docker/fastdfs：用于存放 docker-compose.yml 配置文件及 FastDFS 的数据卷 /usr/local/docker/fastdfs/environmen：用于存放 Dockerfile 镜像配置文件及 FastDFS 所需环境 docker-compose.yml123456789version: '3.1'services: fastdfs: # 服务名称，用户自定义 build: environment # Dockerfile restart: always # 默认开机自启动 container_name: fastdfs # 容器名称 volumes: # 目录挂咋 - ./storage:/fastdfs/storage network_mode: host # 网络模式 Dockerfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ROM ubuntu:xenialMAINTAINER 1183895890@qq.com# 更新数据源WORKDIR /etc/aptRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' &gt; sources.listRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' &gt;&gt; sources.listRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' &gt;&gt; sources.listRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' &gt;&gt; sources.listRUN apt-get update# 安装依赖RUN apt-get install make gcc libpcre3-dev zlib1g-dev --assume-yes# 复制工具包ADD FastDFS_v5.05.tar.gz /usr/local/srcADD fastdfs-nginx-module_v1.16.tar.gz /usr/local/srcADD libfastcommonV1.0.7.tar.gz /usr/local/srcADD nginx-1.16.1.tar.gz /usr/local/src# 安装 libfastcommonWORKDIR /usr/local/src/libfastcommon-1.0.7RUN ./make.sh &amp;&amp; ./make.sh install# 安装 FastDFSWORKDIR /usr/local/src/FastDFSRUN ./make.sh &amp;&amp; ./make.sh install# 配置 FastDFS 跟踪器ADD tracker.conf /etc/fdfsRUN mkdir -p /fastdfs/tracker# 配置 FastDFS 存储ADD storage.conf /etc/fdfsRUN mkdir -p /fastdfs/storage# 配置 FastDFS 客户端ADD client.conf /etc/fdfs# 配置 fastdfs-nginx-moduleADD config /usr/local/src/fastdfs-nginx-module/src# FastDFS 与 Nginx 集成WORKDIR /usr/local/src/nginx-1.16.1RUN ./configure --add-module=/usr/local/src/fastdfs-nginx-module/srcRUN make &amp;&amp; make installADD mod_fastdfs.conf /etc/fdfsWORKDIR /usr/local/src/FastDFS/confRUN cp http.conf mime.types /etc/fdfs/# 配置 NginxADD nginx.conf /usr/local/nginx/conf#建立软连接RUN ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.soRUN ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.soRUN ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.soRUN ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.soCOPY entrypoint.sh /usr/local/bin/ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]WORKDIR /EXPOSE 8888CMD [\"/bin/bash\"] entrypoint.sh1234#!/bin/shfdfs_trackerd /etc/fdfs/tracker.conffdfs_storaged /etc/fdfs/storage.conf/usr/local/nginx/sbin/nginx -g 'daemon off;' 注：Shell 创建后是无法直接使用的，需要赋予执行的权限，使用 chmod +x entrypoint.sh 命令 各种配置文件说明tracker.confFastDFS 跟踪器配置，容器中路径为：/etc/fdfs，修改为： 1base_path=/fastdfs/tracker storage.confFastDFS 存储配置，容器中路径为：/etc/fdfs，修改为： 1234base_path=/fastdfs/storagestore_path0=/fastdfs/storagetracker_server=192.168.33.10:22122http.server_port=8888 client.confFastDFS 客户端配置，容器中路径为：/etc/fdfs，修改为： 12ase_path=/fastdfs/trackertracker_server=192.168.33.10:22122 configfastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： 1234567# 修改前CORE_INCS=\"$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/\"CORE_LIBS=\"$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient\"# 修改后CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\"CORE_LIBS=\"$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient\" mod_fastdfs.conffastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： 1234connect_timeout=10tracker_server=192.168.33.10:22122url_have_group_name = truestore_path0=/fastdfs/storage nginx.confNginx 配置文件，容器中路径为：/usr/local/src/nginx-1.13.6/conf，修改为： 1234567891011121314151617181920212223242526272829user root;worker_processes 1;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8888; server_name localhost; location ~/group([0-9])/M00 { ngx_fastdfs_module; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }} 启动容器1docker-compose up -d 测试上传交互式进入容器1docker exec -it fastdfs /bin/bash 测试文件上传1/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/FastDFS/INSTALL 服务器反馈上传地址1group1/M00/00/00/wKhLi1oHVMCAT2vrAAAeSwu9TgM39767 测试 Nginx 访问1http://192.168.33.10:8888/group1/M00/00/00/wKhLi1oHVMCAT2vrAAAeSwu9TgM3976771","link":"/2020/04/01/Docker-%E5%AE%89%E8%A3%85-fastdfs/"},{"title":"Git安装配置","text":"在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads Linux 平台上安装Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：各 Linux 系统可以很简单多使用其安装包管理工具进行安装： Debian/UbuntuDebian/Ubuntu Git 安装命令为： 1234567$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git-core$ git --versiongit version 1.8.1.2 Centos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为： 1234567$ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel$ yum -y install git-core$ git --versiongit version 1.7.1 Windows 平台上安装在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：安装包下载地址：https://git-scm.com/downloads 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为： http://sourceforge.net/projects/git-osx-installer/安装界面如下所示： Git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 用户信息配置个人的用户名称和电子邮件地址： 12$ git config --global user.name \"lxf\"$ git config --global user.email lxf@php.cn 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：$ git config --global core.editor emacs 差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： $ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 当然，你也可以指定使用自己开发的工具 查看配置信息要检查已有的配置信息，可以使用git config --list 命令： 1234$ git config --listhttp.postbuffer=2Muser.name=lxfuser.email=lxf@java.cn 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。 这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到 如下所示：vim ~/.gitconfig 显示内容如下所示： 12345[http] postBuffer = 2M[user] name = lxf email = lxf@java.cn 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样： 1$ git config user.name lxf Git 工作流程 本节我们将为大家介绍Git的工作流程。 一般工作流程如下： 1.克隆Git 资源为工作目录。 2.在克隆的资源上添加或者是修改文件。 3.如果其他人修改了，你可以更新资源。 4.在提交修改前查看修改。 5.提交修改。 6.在修改完成后，如果发现错误，可以撤回提交并再次修改并体骄傲。 下图展示了Git 的工作流程： ![](Git安装配置/96f3b6_650x800.png) Git 快速设置 简易的命令行入门教程: Git 全局设置 12git config --global user.name \"用户名\"git config --global user.email \"邮箱\" 创建 git 仓库： 12345678mkdir tuolajicd tuolajigit inittouch README.mdgit add README.md //提交单个文件，如果想直接上传所有文件，请将'README.md改'为'.'git commit -m &quot;first commit&quot;git remote add origin https://gitee.com/liqingbo/test.gitgit push -u origin master 已有项目?123cd existing_git_repogit remote add origin https://gitee.com/liqingbo/test.gitgit push -u origin master 创建仓库 初始化 方式一：进入当前根目录初始化 1git init 方式二：指定目录作为Git 仓库 1git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 Git 使用 git init 命令初始化一个 Git 仓库，Git的很多命令都需要 Git 的仓库中运行，所以 git init 是使用 Git 的一个命令。 在执行完 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 提交 如果当前目录下有几个文件想要纳入版本控制，需要先用 `git add` 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 123$ git add *.c$ git add README$ git commit -m '初始化项目版本' 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。 1git clone 我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout)。 克隆仓库的命令格式为： 1git clone &lt;repo&gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式： 1git clone &lt;repo&gt; &lt;directory&gt; 参数说明： 参数 说明 repo Git 仓库 directory 本地目录 如： 1$ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字： 1$ git clone git://github.com/schacon/grit.git lxfgrit","link":"/2020/02/25/Git%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"Git实际操作","text":"Git 远程仓库地址变更 以下均以项目git_test为例： 12老地址：http://192.168.1.12:9797/john/git_test.git 新地址：http://192.168.100.235:9797/john/git_test.git 远程仓库名称： origin 方法一 通过命令直接修改远程地址进入git_test根目录git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 1git remote set-url origin http://192.168.100.235:9797/john/git_test.git 方法二 通过命令先删除再添加远程仓库进入git_test根目录 123git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址git remote rm origingit remote add origin http://192.168.100.235:9797/john/git_test.git 方法三 直接修改配置文件进入git_test/.gitvim config 1234567891011[core] repositoryformatversion = 0 filemode = true logallrefupdates = true precomposeunicode = true [remote \"origin\"] url = http://192.168.100.235:9797/shimanqiang/assistant.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master 修改 [remote “origin”]下面的url即可 方法四 通过第三方git客户端修改。以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件，同样可以完成方法三。 git回滚到任意版本回滚到指定的版本 1git reset --hard e377f60e28c8b84158 强制提交 1git push -f origin master 完美ba87f5b62d581d3a109a78982ca478643c4c6800 先显示提交的log 123456789101112131415161718$ git log -3commit 4dc08bb8996a6ee02fAuthor: Mark &lt;xxx@xx.com&gt;Date: Wed Sep 7 08:08:53 2016 +0800 xxxxxcommit 9cac9ba76574da2167Author: xxx&lt;xx@qq.com&gt;Date: Tue Sep 6 22:18:59 2016 +0800 improved the requstcommit e377f60e28c8b84158Author: xxx&lt;xxx@qq.com&gt;Date: Tue Sep 6 14:42:44 2016 +0800 changed the password from empty to max123 Git pull 强制覆盖本地文件远程获取最新版本到本地 1# git fetch --all 相当于是从远程获取最新版本到本地，不会自动merge只是下载远程的库的内容，不做任何的合并 彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 *慎用* ！ 1# git reset --hard origin/master 删除所有git add的文件（当然这不包括未置于版控制下的文件 untracked files）把HEAD指向刚刚下载的最新的版本 Git pull 强制覆盖本地文件强制覆盖远程分支 1git push origin branch-name --force Git 强制推送方法 1$ git push -u origin master -f （一般不建议使用） git丢弃本地修改的所有文件（新增、删除、修改）本地修改了许多文件，其中有些是新增的，因为开发需要这些都不要了，想要丢弃掉，可以使用如下命令： 本地所有修改的。没有的提交的，都返回到原来的状态 1git checkout . 把所有没有提交的修改暂存到stash里面。可用git stash pop回复。 1git stash # 返回到某个节点，不保留修改。 1git reset --hard HASH 返回到某个节点。保留修改 1git reset --soft HASH 返回到某个节点 1git clean -df git clean 123-n 显示 将要 删除的 文件 和 目录-f 删除 文件-df 删除 文件 和 目录 也可以使用： 1git checkout . &amp;&amp; git clean -xdf 把所有没有提交的修改暂存到stash里面。可用git stash pop回复。 1git stash # 返回到某个节点，不保留修改。 1git reset --hard HASH 返回到某个节点。保留修改 1git reset --soft HASH 返回到某个节点 1git clean -df git clean 123-n 显示 将要 删除的 文件 和 目录-f 删除 文件-df 删除 文件 和 目录 也可以使用： 1git checkout . &amp;&amp; git clean -xdf 配置仓库的SSH公钥你可以按如下命令来生成 sshkey: 12ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" # Generating public/private rsa key pair... 复制 按照提示完成三次回车，即可生成 ssh key。 通过查看~/.ssh/id_rsa.pub文件内容，获取到你的 public key 12cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 码云上添加SSH公钥一、打开终端输入12ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\" #Generating public/private rsa key pair... 三次回车即可生成 ssh key 二、查看你的 public key12cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 三、码云上添加个人公钥复制以上公钥，添加到马云的个人私钥里面 四、查看状态添加后，在终端（Terminal）中输入 1ssh -T git@gitee.com 若返回以下信息，则证明添加成功。 1Hi liqingbo! You've successfully authenticated, but GITEE.COM does not provide shell access. 五、配置git pull/push 免密码进入项目根目录，也就是.git所在目录终端输入 1vi .git/config 文件代码 1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote \"origin\"] url = git@gitee.com:liqingbo/项目.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master 修改配置文件 HTTPS传输的地址，你需要改成SSH的传输地址 1url = https://@gitee.com/liqingbo/项目.git 改成 1url = git@gitee.com:liqingbo/项目.git 复制 注：https://改成git和gitee.com，后面的“/”改成“:” 这样使用命令 git pull/push 就不用输入密码了，这是因为刚才在生成公钥时，没有输入密码，所以当你选择SSH地址传输时，就可免密码使用命令 git pull/push。 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git checkout -b feature1Switched to a new branch 'feature1' 修改readme.txt最后一行，改为： 1Creating a new branch is quick AND simple. 在feature1分支上提交： 1234$ git add readme.txt$ git commit -m \"AND simple\"[feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： 1234$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： 1Creating a new branch is quick &amp; simple. 提交： 1234$ git add readme.txt $ git commit -m \"&amp; simple\"[master 5dc6824] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 12345$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 12345678910111213141516$ git statusOn branch masterYour branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits)You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge)Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: readme.txtno changes added to commit (use \"git add\" and/or \"git commit -a\") 我们可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 1Creating a new branch is quick and simple. 再提交： 12345$ git add readme.txt $ git commit -m \"conflict fixed\"[master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567891011121314$ git log --graph --pretty=oneline --abbrev-commit* cf810e4 (HEAD -&gt; master) conflict fixed|\\ | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/ * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was 14096d0). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 感觉本站内容不错，读后有收获？","link":"/2020/02/26/Git%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C/"},{"title":"Git分支管理","text":"几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。当你执行 git init 的时候，缺省情况下 Git 就会为你创建master分支。 合并冲突合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 12345$ git branch* master* $ cat test.txtw3cschool.cc 总结123456git branch //查看分支git branch &lt;name&gt; //创建分支git checkout &lt;name&gt; //切换分支git checkout -b &lt;name&gt; //创建+切换分支git merge &lt;name&gt; //合并某分支到当前分支git branch -d &lt;name&gt; //删除分支 查看分支1git branch 创建分支1git branch (branchname) 删除分支1git branch -d (branchname) 例如我们要删除”testing”分支： 123456789$ git branch* master testing $ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 切换1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了testing分支，Git 将还原你的工作目录到你创建分支时候的样子 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 123456789101112131415$ lsREADME$ echo 'w3cschool.cc' &gt; test.txt$ git add .$ git commit -m 'add test.txt'[master 048598f] add test.txt 2 files changed, 1 insertion(+), 3 deletions(-) delete mode 100644 hello.php create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch 'testing'$ lsREADME hello.java 当我们切换到testing分支的时候，我们添加的新文件test.txt被移除了,原来被删除的文件hello.php文件又出现了。切换回master分支的时候，它们有重新出现了。 12345$ git checkout masterSwitched to branch 'master'$ lsREADME test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 12345678910111213141516171819$ git checkout -b newtestSwitched to a new branch 'newtest'$ git rm test2.txt rm 'test2.txt'$ lsREADME test.txt$ git commit -am 'removed test2.txt'[newtest 556f0a0] removed test2.txt 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ git checkout masterSwitched to branch 'master'$ lsREADME test.txt test2.txt 如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。 合并1git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： 12345678910111213141516git merge$ git branch* master newtest $ lsREADME test.txt test2.txt$ git merge newtestUpdating 2e082b7..556f0a0Fast-forward test2.txt | 1 - 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ lsREADME test.txt 以上实例中我们将 newtest 分支合并到主分支去，test2.txt 文件被删除。 首先，我们创建一个叫做”change_site”的分支，切换过去，我们将内容改为 www.w3cschool.cc 。 12345678$ git checkout -b change_siteSwitched to a new branch 'change_site'$ vim test.txt $ head -1 test.txt www.w3cschool.cc$ git commit -am 'changed the site'[change_site d7e7346] changed the site 1 file changed, 1 insertion(+), 1 deletion(-) 将修改的内容提交到 “change_site” 分支中。 现在，假如切换回 “master” 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。 123456789$ git checkout masterSwitched to branch 'master'$ head -1 test.txt w3cschool.cc$ vim test.txt $ cat test.txtw3cschool.cc 新增加一行 1234567$ git diffdiff --git a/test.txt b/test.txtindex 704cce7..f84c2a4 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ w3cschool.cc +新增加一行 123$ git commit -am '新增加一行'[master 14b4dca] 新增加一行 1 file changed, 1 insertion(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 1234567891011$ git merge change_siteAuto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result.$ cat test.txt &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADw3cschool.cc新增加一行=======www.w3cschool.cc&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site 我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 12345678910111213$ vim test.txt $ cat test.txt www.w3cschool.cc新增加一行$ git diffdiff --cc test.txtindex f84c2a4,bccb7c2..0000000--- a/test.txt+++ b/test.txt@@@ -1,2 -1,1 +1,2 @@@- w3cschool.cc+ www.w3cschool.cc +新增加一行 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 1234567git status -sUU test.txt$ git add test.txt $ git status -sM test.txt$ git commit[master 88afe0e] Merge branch 'change_site' 现在我们成功解决了合并中的冲突，并提交了结果。 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 w3cschoolcc 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 1$ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了： 12345678910$ git log --oneline --decorate --graph* 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site'|\\ | * d7e7346 (change_site) changed the site* | 14b4dca 新增加一行|/ * 556f0a0 removed test2.txt* 2e082b7 add test2.txt* 048598f add test.txt* 85fc7e7 test comment from w3cschool.cc 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： 1234567891011$ git tag -a v0.9 85fc7e7$ git log --oneline --decorate --graph* 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site'|\\ | * d7e7346 (change_site) changed the site* | 14b4dca 新增加一行|/ * 556f0a0 removed test2.txt* 2e082b7 add test2.txt* 048598f add test.txt* 85fc7e7 (tag: v0.9) test comment from w3cschool.cc 如果我们要查看所有标签可以使用以下命令： 123$ git tagv0.9v1.0 指定标签信息命令： 1$ git tag -a v1.0 PGP签名标签命令： 1git tag -s &lt;tagname&gt; -m \"w3cschool.cc标签\"","link":"/2020/02/26/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"},{"title":"Git常用命令","text":"Git 常用命令速查 1234567891011121314git branch 查看本地所有分支git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支git branch -r 查看远程所有分支git commit -am \"init\" 提交并且加注释 git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支dev 123456789101112131415161718192021222324252627282930313233343536373839git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m \"This is the message describing the commit\" 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m \"remove\" 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来git remote add origin git@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中git pull 本地与服务器端同步git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranchgit fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hsgit branch 删除远程branchgit push origin :branch_remote_namegit branch -r -d branch_remote_name 初始化版本库，并提交到远程服务器端 1234567mkdir WebAppcd WebAppgit init 本地初始化touch READMEgit add README 添加文件git commit -m 'first commit'git remote add origin git@github.com:lixuanfengs/WebApp.git 增加一个远程服务器端 上面的命令会增加URL地址为‘git@github.com:lixuanfengs/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可 1、常用的Git命令 命令 简要说明 git add 添加至暂存区 git add–interactive 交互式添加 git apply 应用补丁 git am 应用邮件格式补丁 git annotate 同义词，等同于 git blame git archive 文件归档打包 git bisect 二分查找 git blame 文件逐行追溯 git branch 分支管理 git cat-file 版本库对象研究工具 git checkout 检出到工作区、切换或创建分支 git cherry-pick 提交拣选 git citool 图形化提交，相当于 git gui 命令 git clean 清除工作区未跟踪文件 git clone 克隆版本库 git commit 提交 git config 查询和修改配置 git describe 通过里程碑直观地显示提交ID git diff 差异比较 git difftool 调用图形化差异比较工具 git fetch 获取远程版本库的提交 git format-patch 创建邮件格式的补丁文件。参见 git am 命令 git grep 文件内容搜索定位工具 git gui 基于Tcl/Tk的图形化工具，侧重提交等操作 git help 帮助 git init 版本库初始化 git init-db* 同义词，等同于 git init git log 显示提交日志 git merge 分支合并 git mergetool 图形化冲突解决 git mv 重命名 git pull 拉回远程版本库的提交 git push 推送至远程版本库 git rebase 分支变基 git rebase–interactive 交互式分支变基 git reflog 分支等引用变更记录管理 git remote 远程版本库管理 git repo-config* 同义词，等同于 git config git reset 重置改变分支“游标”指向 git rev-parse 将各种引用表示法转换为哈希值等 git revert 反转提交 git rm 删除文件 git show 显示各种类型的对象 git stage* 同义词，等同于 git add git stash 保存和恢复进度 git status 显示工作区文件状态 git tag 里程碑管理 2、对象库操作相关命令 命令 简要说明 git commit-tree 从树对象创建提交 git hash-object 从标准输入或文件计算哈希值或创建对象 git ls-files 显示工作区和暂存区文件 git ls-tree 显示树对象包含的文件 git mktag 读取标准输入创建一个里程碑对象 git mktree 读取标准输入创建一个树对象 git read-tree 读取树对象到暂存区 git update-index 工作区内容注册到暂存区及暂存区管理 git unpack-file 创建临时文件包含指定 blob 的内容 git write-tree 从暂存区创建一个树对象 3、引用操作相关命令 命令 简要说明 git check-ref-format 检查引用名称是否符合规范 git for-each-ref 引用迭代器，用于shell编程 git ls-remote 显示远程版本库的引用 git name-rev 将提交ID显示为友好名称 git peek-remote* 过时命令，请使用 git ls-remote git rev-list 显示版本范围 git show-branch 显示分支列表及拓扑关系 git show-ref 显示本地引用 git symbolic-ref 显示或者设置符号引用 git update-ref 更新引用的指向 git verify-tag 校验 GPG 签名的Tag 4、版本库管理相关命令 命令 简要说明 git count-objects 显示松散对象的数量和磁盘占用 git filter-branch 版本库重构 git fsck 对象库完整性检查 git fsck-objects* 同义词，等同于 git fsck git gc 版本库存储优化 git index-pack 从打包文件创建对应的索引文件 git lost-found* 过时，请使用 git fsck –lost-found 命令 git pack-objects 从标准输入读入对象ID，打包到文件 git pack-redundant 查找多余的 pack 文件 git pack-refs 将引用打包到 .git/packed-refs 文件中 git prune 从对象库删除过期对象 git prune-packed 将已经打包的松散对象删除 git relink 为本地版本库中相同的对象建立硬连接 git repack 将版本库未打包的松散对象打包 git show-index 读取包的索引文件，显示打包文件中的内容 git unpack-objects 从打包文件释放文件 git verify-pack 校验对象库打包文件 4、版本库管理相关命令 命令 简要说明 git count-objects 显示松散对象的数量和磁盘占用 git filter-branch 版本库重构 git fsck 对象库完整性检查 git fsck-objects* 同义词，等同于 git fsck git gc 版本库存储优化 git index-pack 从打包文件创建对应的索引文件 git lost-found* 过时，请使用 git fsck –lost-found 命令 git pack-objects 从标准输入读入对象ID，打包到文件 git pack-redundant 查找多余的 pack 文件 git pack-refs 将引用打包到 .git/packed-refs 文件中 git prune 从对象库删除过期对象 git prune-packed 将已经打包的松散对象删除 git relink 为本地版本库中相同的对象建立硬连接 git repack 将版本库未打包的松散对象打包 git show-index 读取包的索引文件，显示打包文件中的内容 git unpack-objects 从打包文件释放文件 git verify-pack 校验对象库打包文件 6、邮件相关命令 命令 简要说明 git imap-send 将补丁通过 IMAP 发送 git mailinfo 从邮件导出提交说明和补丁 git mailsplit 将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件 git request-pull 创建包含提交间差异和执行PULL操作地址的信息 git send-email 发送邮件 7、协议相关命令 命令 简要说明 git daemon 实现Git协议 git http-backend 实现HTTP协议的CGI程序，支持智能HTTP协议 git instaweb 即时启动浏览器通过 gitweb 浏览当前版本库 git shell 受限制的shell，提供仅执行Git命令的SSH访问 git update-server-info 更新哑协议需要的辅助文件 git http-fetch 通过HTTP协议获取版本库 git http-push 通过HTTP/DAV协议推送 git remote-ext 由Git命令调用，通过外部命令提供扩展协议支持 git remote-fd 由Git命令调用，使用文件描述符作为协议接口 git remote-ftp 由Git命令调用，提供对FTP协议的支持 git remote-ftps 由Git命令调用，提供对FTPS协议的支持 git remote-http 由Git命令调用，提供对HTTP协议的支持 git remote-https 由Git命令调用，提供对HTTPS协议的支持 git remote-testgit 协议扩展示例脚本 8、版本库转换和交互相关命令 命令 简要说明 git archimport 导入Arch版本库到Git git bundle 提交打包和解包，以便在不同版本库间传递 git cvsexportcommit 将Git的一个提交作为一个CVS检出 git cvsimport 导入CVS版本库到Git。或者使用 cvs2git git cvsserver Git的CVS协议模拟器，可供CVS命令访问Git版本库 git fast-export 将提交导出为 git-fast-import 格式 git fast-import 其他版本库迁移至Git的通用工具 git svn Git 作为前端操作 Subversion 、合并相关的辅助命令 命令 简要说明 git merge-base 供其他脚本调用，找到两个或多个提交最近的共同祖先 git merge-file 针对文件的两个不同版本执行三向文件合并 git merge-index 对index中的冲突文件调用指定的冲突解决工具 git merge-octopus 合并两个以上分支。参见 git merge 的octopus合并策略 git merge-one-file 由 git merge-index 调用的标准辅助程序 git merge-ours 合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略 git merge-recursive 针对两个分支的三向合并。参见 git merge 的recursive合并策略 git merge-resolve 针对两个分支的三向合并。参见 git merge 的resolve合并策略 git merge-subtree 子树合并。参见 git merge 的 subtree 合并策略 git merge-tree 显式三向合并结果，不改变暂存区 git fmt-merge-msg 供执行合并操作的脚本调用，用于创建一个合并提交说明 git rerere 重用所记录的冲突解决方案 10、 杂项 命令 简要说明 git bisect–helper 由 git bisect 命令调用，确认二分查找进度 git check-attr 显示某个文件是否设置了某个属性 git checkout-index 从暂存区拷贝文件至工作区 git cherry 查找没有合并到上游的提交 git diff-files 比较暂存区和工作区，相当于 git diff –raw git diff-index 比较暂存区和版本库，相当于 git diff –cached –raw git diff-tree 比较两个树对象，相当于 git diff –raw A B git difftool–helper 由 git difftool 命令调用，默认要使用的差异比较工具 git get-tar-commit-id 从 git archive 创建的 tar 包中提取提交ID git gui–askpass 命令 git gui 的获取用户口令输入界面 git notes 提交评论管理 git patch-id 补丁过滤行号和空白字符后生成补丁唯一ID git quiltimport 将Quilt补丁列表应用到当前分支 git replace 提交替换 git shortlog 对 git log 的汇总输出，适合于产品发布说明 git stripspace 删除空行，供其他脚本调用 git submodule 子模组管理 git tar-tree 过时命令，请使用 git archive git var 显示 Git 环境变量 git web–browse 启动浏览器以查看目录或文件 git whatchanged 显示提交历史及每次提交的改动 git-mergetool–lib 包含于其他脚本中，提供合并/差异比较工具的选择和执行 git-parse-remote 包含于其他脚本中，提供操作远程版本库的函数 git-sh-setup 包含于其他脚本中，提供 shell 编程的函数库 git init初始化仓库 git statusgit-status - Show the working tree status git checkoutgit checkout命令用于切换分支或恢复工作树文件。git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。 使用语法 123456git checkout [-q] [-f] [-m] [&lt;branch&gt;]git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…git checkout [-p|--patch] [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…] 描述更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径git checkout还会更新HEAD，将指定的分支设置为当前分支。 示例示例-1以下顺序检查主分支，将Makefile还原为两个修订版本，错误地删除hello.c，并从索引中取回。 1234$ git checkout master #(1)$ git checkout master~2 Makefile #(2)$ rm -f hello.c$ git checkout hello.c #(3) (1) 切换分支(2) 从另一个提交中取出文件(3)从索引中恢复hello.c 如果想要检出索引中的所有C源文件，可以使用以下命令 - 1$ git checkout -- '*.c' 注意:*.c是使用引号的。 文件hello.c也将被检出，即使它不再在工作树中，因为文件globbing用于匹配索引中的条目(而不是在shell的工作树中)。 如果有一个分支也命名为hello.c，这一步将被混淆为一个指令切换到该分支。应该写： 1$ git checkout -- hello.c 示例-2 在错误的分支工作后，想切换到正确的分支，则使用： 1$ git checkout mytopic 但是，您的”错误”分支和正确的”mytopic”分支可能会在在本地修改的文件中有所不同，在这种情况下，上述检出将会失败： $ git checkout mytopicerror: You have local changes to ‘frotz’; not switching branches. 可以将-m标志赋给命令，这将尝试三路合并： $ git checkout -m mytopicAuto-merging frotz 在这种三路合并之后，本地的修改没有在索引文件中注册，所以git diff会显示从新分支的提示之后所做的更改。 示例-3 当使用-m选项切换分支时发生合并冲突时，会看到如下所示： 1234$ git checkout -m mytopicAuto-merging frotzERROR: Merge conflict in frotzfatal: merge program failed 此时，git diff会显示上一个示例中干净合并的更改以及冲突文件中的更改。 编辑并解决冲突，并用常规方式用git add来标记它： 12$ edit frotz # 编辑 frotz 文件中内容，然后重新添加$ git add frotz 其它示例 git checkout的主要功能就是迁出一个分支的特定版本。默认是迁出分支的HEAD版本一此用法示例： 1234$ git checkout master #//取出master版本的head。$ git checkout tag_name #//在当前分支上 取出 tag_name 的版本$ git checkout master file_name #//放弃当前对文件file_name的修改$ git checkout commit_id file_name #//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。 $ git checkout -b dev/1.5.4 origin/dev/1.5.4 从远程dev/1.5.4分支取得到本地分支/dev/1.5.412345$ git checkout -- hello.rb#这条命令把hello.rb从HEAD中签出.$ git checkout .#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。 git reset -–hard123$ git reset --hard HEAD^ 回退到上个版本$ git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前$ git reset --hard commit_id 退到/进到 指定commit的sha码 git reset -–hard彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！ git fsck –lost-found这个命令可以恢复git add过的文件 相关命令 git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git log1$ git log 123456789101112131415161718192021222324252627commit 88afe0e02adcdfea6844bb627de97da21eb10af1Merge: 14b4dca d7e7346Author: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 15:03:42 2015 +0800 Merge branch 'change_site' Conflicts: test.txtcommit 14b4dcadbdc847207651d5a9fae0d315057f346eAuthor: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 14:53:15 2015 +0800 新增加一行commit d7e734640da06055e107eaf29cf350b3f1de1c2cAuthor: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 14:48:57 2015 +0800 changed the sitecommit 556f0a0637978097b82287ac665a717623b21f3fAuthor: w3cschool &lt;w3c@w3cschool.cc&gt;Date: Sun Mar 1 14:40:34 2015 +0800 removed test2.txt –oneline查看历史记录的简洁的版本。 12345678$ git log --oneline88afe0e Merge branch 'change_site'14b4dca 新增加一行d7e7346 changed the site556f0a0 removed test2.txt2e082b7 add test2.txt048598f add test.txt85fc7e7 test comment from w3cschool.cc 这告诉我们的是，此项目的开发历史。我们还可以用 ``选项，查看历史中什么时候出现了分支、合并。 –graph查看历史中什么时候出现了分支、合并。 12345678910$ git log --oneline --graph* 88afe0e Merge branch 'change_site'|\\ | * d7e7346 changed the site* | 14b4dca 新增加一行|/ * 556f0a0 removed test2.txt* 2e082b7 add test2.txt* 048598f add test.txt* 85fc7e7 test comment from w3cschool.cc 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。你也可以用 --reverse参数来逆向显示所有日志。 12345678$ git log --reverse --oneline85fc7e7 test comment from w3cschool.cc048598f add test.txt2e082b7 add test2.txt556f0a0 removed test2.txtd7e7346 changed the site14b4dca 新增加一行88afe0e Merge branch 'change_site' 如果只想查找指定用户的提交日志可以使用命令：git log --author例如，比方说我们要找 Git 源码中 Linus 提交的部分： 123456$ git log --author=Linus --oneline -581b50f3 Move 'builtin-*' into a 'builtin/' subdirectory3bb7256 make &quot;index-pack&quot; a built-in377d027 make &quot;git pack-redundant&quot; a built-inb532581 make &quot;git unpack-file&quot; a built-in112dd51 make &quot;mktag&quot; a built-in 如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）： 12345678910$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges5469e2d Git 1.7.1-rc2d43427d Documentation/remote-helpers: Fix typos and improve language272a36b Fixup: Second argument may be any arbitrary stringb6c8d2d Documentation/remote-helpers: Add invocation section5ce4f4e Documentation/urls: Rewrite to accomodate transport::address00b84e9 Documentation/remote-helpers: Rewrite description03aa87e Documentation: Describe other situations where -z affects git diff77bc694 rebase-interactive: silence warning when no commits rewritten636db2c t3301: add tests to use --format=&quot;%N&quot; 更多 git log 命令可查看：http://git-scm.com/docs/git-log","link":"/2020/02/26/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Git远程仓库","text":"Git 并不像 SVN 那样有个中心服务器。目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。 查看远程分支加上-a参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）： 1234$ git branch -a master* fenzhi remotes/origin/master 添加远程库要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下： 1git remote add [shortname] [url] 查看当前的远程库要查看当前配置有哪些远程仓库，可以用命令： 123456git remote$ git remoteorigin$ git remote -vorigin git@github.com:tianqixin/w3cschool.cc.git (fetch)origin git@github.com:tianqixin/w3cschool.cc.git (push) 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： 1$ git branch -av 提取远程仓库Git 有两个命令用来提取远程仓库的更新。1、从远程仓库下载新分支与数据： 1git fetch 该命令执行完后需要执行git merge 远程分支到你所在的分支。 2、从远端仓库提取数据并尝试合并到当前分支：git pull 该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。 假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。 推送到远程仓库推送你的新分支与数据到某个远端仓库命令: 1git push [alias] [branch] 以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。 12345678$ git merge origin/masterUpdating 7d2081c..f5f3dd5Fast-forward \"w3cschool\\350\\217\\234\\351\\270\\237\\346\\225\\231\\347\\250\\213\\346\\265\\213\\350\\257\\225.txt\" | 1 + 1 file changed, 1 insertion(+)bogon:w3cschoolcc tianqixin$ vim w3cschoolphp中文网测试.txt bogon:w3cschoolcc tianqixin$ git push origin masterEverything up-to-date 删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： 1$ git push origin --delete &lt;branchName&gt; 删除tag这么用： 1git push origin --delete tag &lt;tagname&gt; 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： 1git push origin :&lt;branchName&gt; 这是删除tag的方法，推送一个空tag到远程tag： 12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 两种语法作用完全相同。","link":"/2020/02/26/Git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"title":"Git服务器搭建","text":"Centos,win10,阿里云上搭建自己的git服务器. Centos 搭建git服务器1、安装Git1$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel 1$ yum install git 创建一个git用户组和用户，用来运行git服务： 1$ groupadd git 复制 1$ adduser git -g git win10生成SSH keysSSH key 可以让你在你的电脑和Code服务器之间建立安全的加密连接。 先执行以下语句来判断是否已经存在本地公钥： 1cat ~/.ssh/id_rsa.pub 如果出现类似一下字符串，表示你还没创建ssh key 如果你看到一长串以 ssh-rsa或 ssh-dsa开头的字符串, 你可以跳过 ssh-keygen的步骤。 提示: 最好的情况是一个密码对应一个ssh key，但是那不是必须的。你完全可以跳过创建密码这个步骤。请记住设置的密码并不能被修改或获取。 生成ssh key在git窗口输入 1ssh-keygen -t rsa -C \"1183895890@qq.com\" 然后一直回车这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击Enter键去使用默认值。如图： 查看生成的公钥 1cat ~/.ssh/id_rsa.pub 复制这个公钥放到你的个人设置中的SSH/My SSH Keys下请完整拷贝从ssh-开始直到你的用户名和主机名为止的内容。 到这里的时候，你的公钥已经创建成功了 扩展通过下面方法可以拷贝你的公钥到你的粘贴板下请参考你的操作系统使用以下的命令：Windows: 1clip &lt; ~/.ssh/id_rsa.pub Mac: 1pbcopy &lt; ~/.ssh/id_rsa.pub GNU/Linux (requires xclip): 1xclip -sel clip &lt; ~/.ssh/id_rsa.pub Applications Eclipse：如何在Eclipse中添加ssh key: https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_ConfigurationTip: Non-default OpenSSH key file names or locations 如果，不管你有什么理由，当你决定去用一个非默认的位置或文件名去存放你的ssh key。你必须配置好你的ssh客户端以找到你的ssh私钥去连接Code服务器，对于OpenSSH客户端，这个通常是在~/.ssh/config类似的位置配置的： 123456## Our company's internal GitLab server#Host my-git.company.comRSAAuthentication yesIdentityFile ~/my-ssh-key-directory/company-com-private-key-filename","link":"/2020/02/26/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"title":"IntelliJ IDEA 2019.3注册码+破解","text":"一、前言 ​ 笔者在网上找了一圈，各种方法都试过了，之前那种在网上随便找个注册码，就能激活成功的方式已经一去不返了~ 本文记录下个人 IntelliJ IDEA 2019.3激活破解教程~ 说实话，IDEA 更新是真滴快，还以为 IDEA 2019.2.4 后面会更新 IDEA 2019.2.5 版本，谁知道 11 月份刚结束，官方直接就上了 2019.3 版本 … 据官方说 IDEA 2019.3 版本在启动速度以及 UI 交互上做了很大优化。 二、下载最新的 IDEA 2019.3 其实也可以从老版本直接升级，这里为了照顾大部分人可能第一次安装，我们选择从官网下载，下载地址为: https://www.jetbrains.com/idea/download/ 等待下载完成~~ 三、点击启动 IDEA 2019.3 安装包 ### 这里本人的电脑是64位的，顺便将 64 位的 IDEA 启动图标生成到桌面上： 点击 NEXT ~~ 启动 IDEA 2019.3, 启动成功后，我们可以看到 IDEA 新的欢迎界面如下: 四、开始激活 IDEA 2019.3 如下图所示，我们先选择免费试用 30 天，先进去再说: 五、配置破解补丁 进去过后，我们随便建个项目，点击菜单栏 **Help -> Edit Custom VM Options**: 注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格了~ 下载破解补丁成功以后，笔者将它放置在了 IDEA 的安装目录 /bin 路径下，以防止后面被自己误删: 注意：补丁全路径中不要包含中文，否则，可能导致破解失败！ 页面提取人数太多，导致破解补丁容易被封，一直更换非常麻烦，为限制人数，目前暂不提供页面直接提取，改为从笔者微信号提取。 在 .vmoptions 文件中配置我们补丁放置的全路径位置。 1-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3\\bin\\jetbrains-agent.jar 注意，你的位置可能和我不一样，请自行修改。 六、重启 IDEA切记，一定要重启 IDEA. 七、填入激活码，激活重启完成后，开始填入激活码，点击菜单栏 Help -&gt; Register: 注意：激活码需搭配上面的破解补丁一起使用才有效！！！ 7.1 第一个激活码1A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 7.2 第二个激活码13AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 7.3 第三个激活码1KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 点击激活: 可以看到，已经激活到 2089 年了，开心编码吧~ 声明本教程只做个人学习使用，请勿用于商业用途！ 若资金允许，请点击 https://www.jetbrains.com/idea/buy/ 购买正版，谢谢合作！ 学生凭学生证可免费申请 https://sales.jetbrains.com/hc/zh-cn/articles/207154369-学生授权申请方式 正版授权！ 创业公司可5折购买 https://www.jetbrains.com/shop/eform/startup 正版授权！ 八、可能遇到的问题8.1 Your activation code could not be validated (error 1653219)https://www.exception.site/essay/your-activation-code-could-not-be-validated-error-1653219","link":"/2020/02/18/IntelliJ-IDEA-2019-3%E6%B3%A8%E5%86%8C%E7%A0%81-%E7%A0%B4%E8%A7%A3/"},{"title":"Java中常用类","text":"字符串相关的类，String 类及常用方法 StringBuffer、StringBuilder。JDK 8.0 之前的日期 API, System 静态方法，Date 类，calendar 类，SimpleDateFormat 类。JDK 8.0 中的时间 API, LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormat、其它类。Java 比较器，Comparable 接口，Comparator 接口，System 类，Math 类，BigInteger 与 BigDecimal。 字符串相关的类String 的特性 String 类：代表字符串。Java 程序中的所有字符串字面值（如”abc“）都作为此类的示的实例实现 String 是一个final 类，代表不可变的字符序列 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改 String对象的字符内容是存储在一个字符数组 value[] 中的 1234567public final class Stringimplements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {/** The value is used for character storage. */private final char value[];/** Cache the hash code for the string */private int hash; // Default to 0 String s1 = “abc”;//字面量的定义方式 String s2 = “abc”; s1 = “hello”; String 对象的创建 1234567891011String str = \"hello\";//本质上this.value = new char[0];String s1 = new String();//this.value = original.value;String s2 = new String(String original);//this.value = Arrays.copyOf(value, value.length);String s3 = new String(char[] a);String s4 = new String(char[] a,int startIndex,int count); String str1 = “abc”；与 String str2 = new String(”abc“); 的区别？ *str1 * 字符串常量存储在字符串常量池， 目的是共享 str2 字符串非常量对象存储在堆中 字符串对象是如何存储的 练习1 12345678String s1 = \"javaEE\";String s2 = \"javaEE\";String s3 = new String(\"javaEE\");String s4 = new String(\"javaEE\");System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//false System.out.println(s3 == s4);//false 练习2 123456789101112Person p1 = new Person(); p1.name = \"xianrenqiu\";Person p2 = new Person(); p2.name = \"xianrenqiu\";System.out.println(p1.name .equals( p2.name)); // trueSystem.out.println(p1.name == p2.name); // trueSystem.out.println(p1.name == \"xianrenqiu\"); // trueString s1 = new String(\"bcde\");String s2 = new String(\"bcde\");System.out.println(s1==s2); //false 1234Person p1 = new Person(\"Tom\",12);Person p2 = new Person(\"Tom\",12);System.out.println(p1.name == p2.name);//true 字符串的特性 结论： 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量 只要其中有一个是变量，结果就在堆中 如果拼接的结果调用intern()方法，返回值就在常量池中 String 使用的陷阱 String s1 = “a”; 说明：在字符串常量池中创建了一个字面量是 “a”的字符串 s1 = s1 + “b”; 说明：实际上原来的“a”字符对象已经丢弃了，现在在堆空间中产生了一个字符串 s1 + “b”(也就是“ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能 String s2 = “ab”; 说明：直接在字符串常量池中创建一个字面量为“ab”的字符串 String s3 = “a” + “b”; 说明：s3指向字符串常量池中已经创建的“ab”的字符串 String s4 = s1.intern(); 说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的“ab” 字符串赋值给s4 练习3 【面试题】 下列程序运行的结果： 12345678910111213141516public class StringTest {String str = new String(\"good\");char[] ch = { 't', 'e', 's', 't' };public void change(String str, char ch[]) { str = \"test ok\"; ch[0] = 'b';}public static void main(String[] args) { StringTest ex = new StringTest(); ex.change(ex.str, ex.ch); System.out.print(ex.str + \" and \");// good and System.out.println(ex.ch); // }} String 常用方法1 int length()：返回字符串的长度： return value.length char charAt(int index)： 返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空字符串：return value.length == 0 String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写 String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写 String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+” int compareTo(String anotherString)：比较两个字符串的大小 String substring(int beginIndex)： 返回一个新的字符串， 它是此字符串的从beginIndex开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串 String常用方法2 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf方法如果未找到都是返回-1 String常用方法3 String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String replace(CharSequence target, CharSequence replacement)： 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement) ： 使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement) ： 使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 12345678910111213141516171819202122232425String str = \"12hello34world5java7891mysql456\";//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉String string = str.replaceAll(\"\\\\d+\", \",\").replaceAll(\"^,|,$\", \"\");System.out.println(string);String str = \"12345\";//判断str字符串中是否全部有数字组成，即有1-n个数字组成boolean matches = str.matches(\"\\\\d+\");System.out.println(matches); String tel = \"0571-4534289\";//判断这是否是一个杭州的固定电话boolean result = tel.matches(\"0571-\\\\d{7,8}\");System.out.println(result);String str = \"hello|world|java\"; String[] strs = str.split(\"\\\\|\");for (int i = 0; i &lt; strs.length; i++) { System.out.println(strs[i]);}System.out.println();String str2 = \"hello.world.java\"; String[] strs2 = str2.split(\"\\\\.\");for (int i = 0; i &lt; strs2.length; i++) { System.out.println(strs2[i]);} String与基本数据类型转换 字符串 -&gt; 基本数据类型、包装类 integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。 类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应 的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。 基本数据类型、包装类 -&gt; 字符串 调用String类的public String valueOf(int n)可将int型转换为字符串 相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换 字符串数组 -&gt; 字符串 String 类的构造器：String(char[]) 和 String(char[], int offset, int length)分别用字符数组中的全部字符和部分字符创建字符串对象。 字符串 -&gt; 字符串数组 public char[] toCharArray(): 将字符串中的全部字符存放在一个字符数组中的方法。 public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin): 提供了将指定索引范围内的字符串存放到数组中的方法。 字节数组 -&gt; 字符串 String(byte[]): 通过使用平台的默认字符集解码指定的byte数组，构造一个新的 String。 String(byte[], int offset, int length): 用指定的字节数组的一部分， 即从数组起始位置offset开始取length个字节构造一个字符串对象。 字符串 -&gt; 字节数组 public byte[] getBytes(): 使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。 public byte[] getBytes(String charsetName): 使用指定的字符集将此String 编码到 byte 序列，并将结果存储到新的 byte 数组。 练习4 12345678String str = \"中\";System.out.println(str.getBytes(\"ISO8859-1\").length);// -128~127System.out.println(str.getBytes(\"GBK\").length); System.out.println(str.getBytes(\"UTF-8\").length);System.out.println(new String(str.getBytes(\"ISO8859-1\"),\"ISO8859-1\"));// 乱码，表示不了中文System.out.println(new String(str.getBytes(\"GBK\"), \"GBK\"));System.out.println(new String(str.getBytes(\"UTF-8\"), \"UTF-8\")); 练习5：常见算法题目 1. 模拟一个trim方法，去除字符串两端的空格。 2. 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class StringDemo { /* 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 方式一：转换为char[] */ public String reverse(String str,int startIndex,int endIndex){ if(str != null){ char[] arr = str.toCharArray(); for(int x = startIndex,y = endIndex;x &lt; y;x++,y--){ char temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; } return new String(arr); } return null; } //方式二：使用String的拼接 public String reverse1(String str,int startIndex,int endIndex){ if(str != null){ //第1部分 String reverseStr = str.substring(0,startIndex); //第2部分 for(int i = endIndex;i &gt;= startIndex;i--){ reverseStr += str.charAt(i); } //第3部分 reverseStr += str.substring(endIndex + 1); return reverseStr; } return null; } //方式三：使用StringBuffer/StringBuilder替换String public String reverse2(String str,int startIndex,int endIndex){ if(str != null){ StringBuilder builder = new StringBuilder(str.length()); //第1部分 builder.append(str.substring(0,startIndex)); //第2部分 for(int i = endIndex;i &gt;= startIndex;i--){ builder.append(str.charAt(i)); } //第3部分 builder.append(str.substring(endIndex + 1)); return builder.toString(); } return null; } @Test public void testReverse(){ String str = \"abcdefg\"; String reverse = reverse(str, 2, 5); System.out.println(reverse); }} 3. 获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在“abkkcadkabkebfkabkskab”中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class StringDemo1 { /* 获取一个字符串在另一个字符串中出现的次数。 比如：获取“ab”在 “abkkcadkabkebfkaabkskab” 中出现的次数 */ /** * 获取subStr在mainStr中出现的次数 * @param mainStr * @param subStr * @return */ public int getCount(String mainStr,String subStr){ int mainLength = mainStr.length(); int subLength = subStr.length(); int count = 0; int index = 0; if(mainLength &gt;= subLength){ //方式一：// while((index = mainStr.indexOf(subStr)) != -1){// count++;// mainStr = mainStr.substring(index + subStr.length());// } //方式二：对方式一的改进 while((index = mainStr.indexOf(subStr,index)) != -1){ count++; index += subLength; } return count; }else{ return 0; } } @Test public void testGetCount(){ String mainStr = \"abkkcadkabkebfkaabkskab\"; String subStr = \"ab\"; int count = getCount(mainStr, subStr); System.out.println(count); }} 4. 获取两个字符串中最大相同子串。比如： str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class StringDemo2 { /* 获取两个字符串中最大相同子串。比如： str1 = \"abcwerthelloyuiodefabcdef\";str2 = \"cvhellobnm\" 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 */ //前提：两个字符串中只有一个最大相同子串 public String getMaxSameString(String str1,String str2){ if(str1 != null &amp;&amp; str2 != null){ String maxStr = (str1.length() &gt;= str2.length())? str1 : str2; String minStr = (str1.length() &lt; str2.length())? str1 : str2; int length = minStr.length(); for(int i = 0;i &lt; length;i++){ for(int x = 0,y = length - i;y &lt;= length;x++,y++){ String subStr = minStr.substring(x,y); if(maxStr.contains(subStr)){ return subStr; } } } } return null; } // 如果存在多个长度相同的最大相同子串 // 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便 public String[] getMaxSameString1(String str1, String str2) { if (str1 != null &amp;&amp; str2 != null) { StringBuffer sBuffer = new StringBuffer(); String maxString = (str1.length() &gt; str2.length()) ? str1 : str2; String minString = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i &lt; len; i++) { for (int x = 0, y = len - i; y &lt;= len; x++, y++) { String subString = minString.substring(x, y); if (maxString.contains(subString)) { sBuffer.append(subString + \",\"); } }// System.out.println(sBuffer); if (sBuffer.length() != 0) { break; } } String[] split = sBuffer.toString().replaceAll(\",$\", \"\").split(\"\\\\,\"); return split; } return null; } @Test public void testGetMaxSameString(){ String str1 = \"abcwerthello1yuiodefabcdef\"; String str2 = \"cvhello1bnmabcdef\"; String[] maxSameStrings = getMaxSameString1(str1, str2); System.out.println(Arrays.toString(maxSameStrings)); }} 5. 对字符串中字符进行自然顺序排序。 提示： 1）字符串变成字符数组。 2）对数组排序，选择，冒泡，Arrays.sort(); 3）将排序后的数组变成字符串 StringBuffer类 java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。 很多方法与String相同。 作为参数传递时，方法内部可以改变值。 StringBuffer 类不同于String，其对象必须使用构造器生成。有三个构造器： StringBuffer(): 初始容量为16的字符串缓冲区 StringBuffer(int size): 构造指定容量的字符缓冲区 StringBufer(String str): 将内容初始化为指定字符串内容 123String s = new String(\"我喜欢学习\");StringBuffer buffer = new StringBuffer(\"我喜欢学习\");buffer.append(\"数学\"); StringBuffer类的常用方法 StringBuffer append(xxx): 提供了很多的append()方法，用于进行字符串拼接 StringBuffer delete(int start, int end): 删除指定位置的内容 StringBuffer raplace(int start, int end, String str): 把(start,end)位置替换为str StringBuffer insert(int offset, xxx): 在指定位置插入 xxx StringBuffer reverse(): 把当前字符序列逆转 当append和insert时，如果原来value数组长度不够，可扩容。 如上这些方法支持方法链操作。 方法链的原理： 此外，还定义了如下的方法： public int indexOf(String str) public String substring(int start,int end) public int length() public char charAt(int n ) public void setCharAt(int n ,char ch) StringBuilder类 StringBuilder 和 StringBuffer 北厂类似，均代表可变的字符序列，而且提供相关功能的方法也一样 面试题：对比String、StringBuffer、StringBuilder String(JDK1.0)：不可变字符序列 StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全 StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全 注意：作为参数传递的话，方法内部 String 不会改变其值，StringBuffer 和 StringBuilder会改变其值 三者效率测试 12345678910111213141516171819202122232425//初始设置long startTime = 0L;long endTime = 0L;String text = \"\";StringBuffer buffer = new StringBuffer(\"\");StringBuilder builder = new StringBuilder(\"\");//开始对比startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) { buffer.append(String.valueOf(i));}endTime = System.currentTimeMillis();System.out.println(\"StringBuffer的执行时间：\" + (endTime - startTime));startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) { builder.append(String.valueOf(i));}endTime = System.currentTimeMillis();System.out.println(\"StringBuilder的执行时间：\" + (endTime - startTime));startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) { text = text + i;}endTime = System.currentTimeMillis(); System.out.println(\"String的执行时间：\" + (endTime - startTime)); 【面试题】 程序输出： 1234567String str = null;StringBuffer sb = new StringBuffer();sb.append(str); System.out.println(sb.length());// 4System.out.println(sb);// nullStringBuffer sb1 = new StringBuffer(str);System.out.println(sb1);// java.lang.NullPointerException 【面试题2】程序输出： 1234567891011@Testpublic void testString (){ String a = \"123\"; String b = \"123\"; String c = new String(\"123\"); String d = new String(\"123\"); System.out.println(a.equals(b)); //true System.out.println(a == b); //true System.out.println(c.equals(d)); //true System.out.println(c == d); //false} JDK8 之前日期时间 API java.lang.System 类 System 类提供的 public static long currentTimeMillis())用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 此方法适于计算时间差。 计算世界时间的主要标准有： UTC(Coordinated Universal Time) GMT(Greenwich Mean Time) CST(Central Standard Time) java.util.Date 类 表示特定的瞬间，精确到毫秒 构造器： Date(): 使用无参构造器创建的对象可以获取本地当前时间 Date(long date) 常用方法 getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。 其它很多方法都过时了。 12345678Date date = new Date();System.out.println(date);System.out.println(System.currentTimeMillis());System.out.println(date.getTime()); Date date1 = new Date(date.getTime());System.out.println(date1.getTime()); System.out.println(date1.toString()); java.text.SimpleDateFormat 类 Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。 它允许进行格式化：日期 -&gt; 文本、解析：文本 -&gt; 日期 格式化： SimpleDateFormat(): 默认的模式和语言环境创建对象 public SimpleDateFormat(String pattern): 该构方法可以用参数 pattern指定的格式创建一个对象，该对象调用： public String format(Date date): 方法格式化时间对象 date 解析： public Date parse(String source): 从给定字符串的开始解析文本，以生成一个日期。 1234567891011121314Date date = new Date(); // 产生一个Date实例// 产生一个formater格式化的实例SimpleDateFormat formater = new SimpleDateFormat();System.out.println(formater.format(date));// 打印输出默认的格式SimpleDateFormat formater2 = new SimpleDateFormat(\"yyyy年MM月dd日EEEHH:mm:ss\");System.out.println(formater2.format(date));try { // 实例化一个指定的格式对象 Date date2 = formater2.parse(\"2008年08月08日 星期一 08:08:08\"); // 将指定的日期解析后格式化按指定的格式输出 System.out.println(date2.toString());} catch (ParseException e) { e.printStackTrace();} java.util.Calendar(日历) 类 Calendar 是一个抽象基类，主要用于完成日期字段之间的相互操作的功能。 获取 Calendar 实例的方法 使用 Calendar.getInstance() 方法 调用它的子类 GregorianCalendar 的构造器 一个 Calendar 的实例是系统时间的抽象表示，通过get(int field) 方法来取得想要的时间信息。比如l 比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND public void set(int field,int value) public void add(int field,int amount) public final Date getTime() public final void setTime(Date date) 注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2 ， 。。。。周六是7 123456789101112Calendar calendar = Calendar.getInstance();// 从一个 Calendar 对象中获取 Date 对象Date date = calendar.getTime();// 使用给定的 Date 设置此 Calendar 的时间date = new Date(234234235235L);calendar.setTime(date);calendar.set(Calendar.DAY_OF_MONTH, 8);System.out.println(\"当前时间日设置为8后,时间是:\" + calendar.getTime());calendar.add(Calendar.HOUR, 2);System.out.println(\"当前时间加2小时后,时间是:\" + calendar.getTime());calendar.add(Calendar.MONTH, -2);System.out.println(\"当前日期减2个月后,时间是:\" + calendar.getTime()); JDK8 中新日期时间 API新日期时间API出现的背景 如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中的年份是从1900开始的，而月份都从0开始。格式化：格式化只对Date有用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。 新时间日期 API 第三次引入的 API 是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。 Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime） 和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法， 用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。 java.time - 包含值对象的基础包 java.time.chrono - 提供对不同的日历系统访问 java.time.format - 格式化和解析时间和日期 java.time.temporal - 包括底层框架和扩展特性 java.time.zone - 包含时区支持类 说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。 LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。 LocalTime表示一个时间，而不是日期。 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。 方法 描述 now() / * now(ZoneId zone) 静态方法，根据当前时间创建对象/指定时区的对象 of() 静态方法，根据指定日期/时间创建对象 getDayOfMonth()/getDayOfYear() 获得月份天数(1-31) /获得年份天数(1-366) getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值) getMonth() 获得月份, 返回一个 Month 枚举值 getMonthValue() / getYear() 获得月份(1-12) /获得年份 getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒 withDayOfMonth()/withDayOfYear()/withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 plusDays(),plusWeeks(),plusMonths(),plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时 minusMonths()/minusWeeks()/minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时 瞬时：Instant Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是 时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中， 也是从1970年开始，但以毫秒为单位。 java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。 (1 ns = 10 ^-9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒 方法 描述 now() 静态方法，返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个 OffsetDateTime toEpochMilli() 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 格式化与解析日期或时间 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 方法 描述 ofPattern(String pattern) 静态方法 ，返回一个指定字符串格式的DateTimeFormatter format(TemporalAccessor t) 格式化一个日期、时间，返回字符串 parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间 其它 API ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等 Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 持续时间：Duration，用于计算两个“时间”间隔 日期间隔：Period，用于计算两个“日期”间隔 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。 TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。 12345678910111213141516//ZoneId:类中包含了所有的时区信息// ZoneId的getAvailableZoneIds():获取所有的ZoneIdSet&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();for (String s : zoneIds) {System.out.println(s);}// ZoneId的of():获取指定时区的时间LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of(\"Asia/Tokyo\"));System.out.println(localDateTime.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日EEEHH:mm:ss\")));//ZonedDateTime:带时区的日期时间// ZonedDateTime的now():获取本时区的ZonedDateTime对象ZonedDateTime zonedDateTime = ZonedDateTime.now();System.out.println(zonedDateTime);// ZonedDateTime的now(ZoneId id):获取指定时区的ZonedDateTime对象ZonedDateTime zonedDateTime1 = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));System.out.println(zonedDateTime1); 123456789101112131415//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准LocalTime localTime = LocalTime.now();LocalTime localTime1 = LocalTime.of(15, 23, 32);//between():静态方法，返回Duration对象，表示两个时间的间隔Duration duration = Duration.between(localTime1, localTime);System.out.println(duration);System.out.println(duration.getSeconds());System.out.println(duration.getNano());LocalDateTime localDateTime = LocalDateTime.of(2016, 6, 12, 15, 23, 32);LocalDateTime localDateTime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32);Duration duration1 = Duration.between(localDateTime1, localDateTime);System.out.println(duration1.toDays()); 123456789101112131415161718// TemporalAdjuster:时间校正器// 获取当前日期的下一个周日是哪天？TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY);LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster); System.out.println(localDateTime);// 获取下一个工作日是哪天？LocalDate localDate = LocalDate.now().with(new TemporalAdjuster() {@Overridepublic Temporal adjustInto(Temporal temporal) { LocalDate date = (LocalDate) temporal; if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) { return date.plusDays(3); } else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) { return date.plusDays(2); } else { return date.plusDays(1); } }});System.out.println(\"下一个工作日是：\" + localDate); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * jdk 8中日期时间API的测试 */public class JDK8DateTimeTest { @Test public void testDate(){ //偏移量 Date date1 = new Date(2020 - 1900,9 - 1,8); System.out.println(date1);//Tue Sep 08 00:00:00 GMT+08:00 2020 } /* LocalDate、LocalTime、LocalDateTime 的使用 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar */ @Test public void test1(){ //now():获取当前的日期、时间、日期+时间 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); //of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); //getXxx()：获取相关的属性 System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getMonthValue()); System.out.println(localDateTime.getMinute()); //体现不可变性 //withXxx():设置相关的属性 LocalDate localDate1 = localDate.withDayOfMonth(22); System.out.println(localDate); System.out.println(localDate1); LocalDateTime localDateTime2 = localDateTime.withHour(4); System.out.println(localDateTime); System.out.println(localDateTime2); //不可变性 LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime); System.out.println(localDateTime4); } /* Instant的使用 类似于 java.util.Date类 */ @Test public void test2(){ //now():获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant);//2019-02-18T07:29:41.719Z //添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2019-02-18T15:32:50.611+08:00 //toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long milli = instant.toEpochMilli(); System.out.println(milli); //ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 = Instant.ofEpochMilli(1550475314878L); System.out.println(instant1); } /* DateTimeFormatter:格式化或解析日期、时间 类似于SimpleDateFormat */ @Test public void test3(){// 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化:日期--&gt;字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1);//2019-02-18T15:42:18.797 //解析：字符串 --&gt;日期 TemporalAccessor parse = formatter.parse(\"2019-02-18T15:42:18.797\"); System.out.println(parse);// 方式二：// 本地化相关的格式。如：ofLocalizedDateTime()// FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); //格式化 String str2 = formatter1.format(localDateTime); System.out.println(str2);//2019年2月18日 下午03时47分16秒// 本地化相关的格式。如：ofLocalizedDate()// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); //格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);//2019-2-18// 重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\"); //格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2019-02-18 03:52:09 //解析 TemporalAccessor accessor = formatter3.parse(\"2019-02-18 03:52:09\"); System.out.println(accessor); } 类 To 遗留类 From 遗留类 java.time.Instant与java.util.Date Date.from(instant) date.toInstant() java.time.Instant与java.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTime与java.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDate与java.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTime与java.sql.Time Date.valueOf(localDate) date.toLocalTime() time.LocalDateTime与java.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneId与java.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatter与java.text.DateFormat formatter.toFormat() 无 Java 比较器 在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 Java实现对象排序的方式有两种： 自然排序：java.lang.Comparable 定制排序：java.lang.Comparator 方式一：自然排序：java.lang.Comparable Comparable 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 实现 Comparable 的类必须实现 compareTo(Object object) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象 this 大于形参对象 Obj, 则返回正整数，如果当前对象 this 小于形参对象obj, 则返回负整数，如果当前对象 this 等于形参对象 obj, 则返回零 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。 Comparable 的典型实现：（默认都是从小都大排列的） 12345678910111213public class ComparableTest{ public static void main(String[] args) { Goods[] all = new Goods[4]; all[0] = new Goods(\"《红楼梦》\", 100); all[1] = new Goods(\"《西游记》\", 80); all[2] = new Goods(\"《三国演义》\", 140); all[3] = new Goods(\"《水浒传》\", 120); Arrays.sort(all); System.out.println(Arrays.toString(all)); }} 方式二：定制排序：java.util.Comparator 当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口 的排序规则不适合当前操作，那么考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Goods implements Comparable{ private String name; private double price; public Goods() { } public Goods(String name, double price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \"Goods{\" + \"name='\" + name + '\\'' + \", price=\" + price + '}'; } //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序 @Override public int compareTo(Object o) {// System.out.println(\"**************\"); if(o instanceof Goods){ Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price){ return 1; }else if(this.price &lt; goods.price){ return -1; }else{// return 0; return -this.name.compareTo(goods.name); } //方式二：// return Double.compare(this.price,goods.price); }// return 0; throw new RuntimeException(\"传入的数据类型不一致！\"); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 一、说明：Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的 * 但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 * 如何实现？使用两个接口中的任何一个：Comparable 或 Comparator * * 二、Comparable接口与Comparator的使用的对比： * Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。 * Comparator接口属于临时性的比较。 */public class CompareTest { /* Comparable接口的使用举例： 自然排序 1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。 2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列 3. 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 在compareTo(obj)方法中指明如何排序 */ @Test public void test1(){ String[] arr = new String[]{\"AA\",\"CC\",\"KK\",\"MM\",\"GG\",\"JJ\",\"DD\"}; // Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } @Test public void test2(){ Goods[] arr = new Goods[5]; arr[0] = new Goods(\"lenovoMouse\",34); arr[1] = new Goods(\"dellMouse\",43); arr[2] = new Goods(\"xiaomiMouse\",12); arr[3] = new Goods(\"huaweiMouse\",65); arr[4] = new Goods(\"microsoftMouse\",43); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } /* Comparator接口的使用：定制排序 1.背景： 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作， 那么可以考虑使用 Comparator 的对象来排序 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 */ @Test public void test3(){ String[] arr = new String[]{\"AA\",\"CC\",\"KK\",\"MM\",\"GG\",\"JJ\",\"DD\"}; Arrays.sort(arr,new Comparator(){ //按照字符串从大到小的顺序排列 @Override public int compare(Object o1, Object o2) { if(o1 instanceof String &amp;&amp; o2 instanceof String){ String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2); }// return 0; throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); } @Test public void test4(){ //定制排序 Goods[] arr = new Goods[6]; arr[0] = new Goods(\"lenovoMouse\",34); arr[1] = new Goods(\"dellMouse\",43); arr[2] = new Goods(\"xiaomiMouse\",12); arr[3] = new Goods(\"huaweiMouse\",65); arr[4] = new Goods(\"huaweiMouse\",224); arr[5] = new Goods(\"microsoftMouse\",43); Arrays.sort(arr, new Comparator() { //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序 @Override public int compare(Object o1, Object o2) { if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods){ Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName())){ return -Double.compare(g1.getPrice(),g2.getPrice()); }else{ return g1.getName().compareTo(g2.getName()); } } throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); }} System 类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流（键盘输入），标准输出流（显示器）和标准错误输出流（显示器）。 成员方法 native long currentTimeMillis(): 该方法的作用是返回当前的计算机时间，时间的表达式格式为当前计算机时间和 GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status): 该方法的作用时退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出共功能等。 void gc(): 该方法的作用是请求系统进行垃圾回收。至于系统是否立即回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key): 该方法的作用是获取系统中属性名为 key 的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 属性名 属性说明 java.version java 运行时环境版本 java.home java 安装目录 os.name 操作系统的名称 os.version 操作系统的版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 1234567891011121314151617181920212223@Testpublic void test1() { String javaVersion = System.getProperty(\"java.version\"); System.out.println(\"java的version:\" + javaVersion); String javaHome = System.getProperty(\"java.home\"); System.out.println(\"java的home:\" + javaHome); String osName = System.getProperty(\"os.name\"); System.out.println(\"os的name:\" + osName); String osVersion = System.getProperty(\"os.version\"); System.out.println(\"os的version:\" + osVersion); String userName = System.getProperty(\"user.name\"); System.out.println(\"user的name:\" + userName); String userHome = System.getProperty(\"user.home\"); System.out.println(\"user的home:\" + userHome); String userDir = System.getProperty(\"user.dir\"); System.out.println(\"user的dir:\" + userDir);} Math 类java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为 double 型。 方法 描述 abs 绝对值 acos, asin, cos, sin, tan 三角函数 sqrt 平方根 pow(double a,double b) a的b次幂 log 自然对数 exp e为底指数 max(double a, double b) 求两个数中的最大的值 min(double a, double b) 求两个数中的最小的值 random() 返回0.0 到1.0的随机数 long round(double a） double 型数据a转换为long类型（四舍五入） toDegrees(double angrad) 弧度 -&gt; 角度 toRadians(double angdeg) 角度 -&gt; 弧度 BigInteger 与 BigDecimal Integer类作为int的包装类，能存储的最大整型值为2的31次方-1，Long类也是有限的， 最大为2的63次方-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 java.math包的BigInteger 可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val): 根据字符串构建 BigInteger对象 常用方法 public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger。 BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger。 BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger。 BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。 BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 BigInteger[] divideAndRemainde r(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。 BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。 BigDecimal 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中， 要求数字精度比较高，故用到java.math.BigDecimal类。 BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 public BigDecimal(double val) public BigDecimal(String val) 常用方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 12345678910@Testpublic void test2() { BigInteger bi = new BigInteger(\"1243324112234324324325235245346567657653\"); BigDecimal bd = new BigDecimal(\"12435.351\"); BigDecimal bd2 = new BigDecimal(\"11\"); System.out.println(bi); System.out.println(bd.divide(bd2)); System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_DOWN)); System.out.println(bd.divide(bd2, 25, BigDecimal.ROUND_HALF_DOWN));}","link":"/2020/03/02/Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/"},{"title":"Java泛型","text":"为什么要有泛型 在集合中使用泛型 自定义泛型结构 泛型在继承上的体现 通配符的使用 泛型应用举例 为什么要有泛型(Generic)? 泛型：标签 举例： 中药店，每个抽屉外面贴着标签 超市购物架上很多瓶子，每个瓶子装的是什么，有标签 泛型的设计背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个&lt;E&gt;就是类型参数，即泛型。 泛型的概念 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如， 继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念， 允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持， 从而可以在声明集合变量、创建集合对象时传入类型实参。 那么为什么要有泛型呢，直接Object不是也可以存储数据吗？ 解决元素存储安全性问题，好比商品、药品标签，不会弄错。 解决获取数据元素时，需要类型强制转换问题，好比不用每回拿商品、药品都要辨别。 在集合中没有反泛型时 任何类型都可以添加到集合中：类型不安全 读取出来的对象需要强转：繁琐可能有 ClassCastException 在集合中有泛型时 只有指定类型才可以添加到集合中：类型安全 读取出来的对象不需要强转：便捷 Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 在集合中使用泛型123456789101112131415ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();//类型推断list.add(78);list.add(88);list.add(77);list.add(66);//遍历方式一：//for(Integer i : list){ //不需要强转 //System.out.println(i);//}//遍历方式二：Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext()){ System.out.println(iterator.next());} 1234567891011121314151617Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();map.put(\"Tom1\",34);map.put(\"Tom2\",44);map.put(\"Tom3\",33);map.put(\"Tom4\",32);//添加失败//map.put(33, \"Tom\");Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();while(iterator.hasNext()){Entry&lt;String,Integer&gt; entry = iterator.next(); System.out.println(entry.getKey() + \"---&gt;\" + entry.getValue());} 自定义泛型结构 自定义泛型类 自定义泛型接口 自定义泛型方法 泛型的声明： interface List 和 class GenTest&lt;K,V&gt; 其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。 常用T表示，是Type的缩写。 泛型的实例化： 一定要在类名后面指定类型参数值（类型）。如： List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); Iterator&lt;Customer&gt; iterator = customers.iterator(); T 只能时类，不能用基本数据类型填充。但可以使用包装类填充 把一个集合中的内容限制为一个特定的数据类型，这就是 generics背后的人核心思想 Comparable c = new Date();System.out.println(c.compareTo(&quot;red&quot;)); JDK1.5 之前 Comparable&lt;Date&gt; c = new Date();System.out.println(c.compareTo(&quot;red&quot;)); JDK1.5 体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误 自定义泛型结构：泛型类、泛型接口 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 泛型类的构造器如下：public GenericClass(){}。 而下面是错误的：public GenericClass(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致 泛型不同的引用不能相互赋值。 尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象 jdk1.7 泛型的简化操作：ArrayList &lt;Fruit&gt; first = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换 1234567891011121314151617181920class GenericTest { public static void main(String[] args) { // 1、使用时：类似于Object，不等同于Object ArrayList list = new ArrayList(); // list.add(new Date());//有风险 list.add(\"hello\"); test(list);// 泛型擦除，编译不会类型检查 // ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;(); // test(list2);//一旦指定Object，编译会类型检查，必须按照Object处理 } public static void test(ArrayList&lt;String&gt; list) { String str = \"\"; for (String s : list) { str += s + \",\"; } System.out.println(\"元素:\" + str); }} 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。 异常类不能时泛型。 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 没有类型 擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型 12345678910111213141516class Father&lt;T1, T2&gt; {}// 子类不保留父类的泛型// 1)没有类型 擦除class Son1 extends Father {// 等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型class Son2 extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; {} 12345678910111213141516class Father&lt;T1, T2&gt; {}// 子类不保留父类的泛型// 1)没有类型 擦除class Son&lt;A, B&gt; extends Father{//等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; {} 1234567891011121314151617181920212223242526272829Class Person&lt;T&gt; { // 使用T类型定义变量 private T info; // 使用T类型定义一般方法 public T getInfo() { return info; } public void setInfo(T info) { this.info = info; } // 使用T类型定义构造器 public Person() { } public Person(T info) { this.info = info; } // static的方法中不能声明泛型 //public static void show(T t) { // //} // 不能在try-catch中使用泛型定义 public void test() { //try { // //} catch (MyException&lt;T&gt; ex) { //} //} // }} 自定义泛型结构：泛型方法 方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。 泛型方法的格式：泛型方法的格式： [访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常 泛型方法声明泛型时也可以指定上限(在12.5中讲) 123456789public class DAO { public &lt;E&gt; E get(int id, E e) { E result = null; return result; }} 123456789101112131415161718192021public static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c) { for (T o : a) { c.add(o); }}public static void main(String[] args) { Object[] ao = new Object[100]; Collection&lt;Object&gt; co = new ArrayList&lt;Object&gt;(); fromArrayToCollection(ao, co); String[] sa = new String[20]; Collection&lt;String&gt; cs = new ArrayList&lt;&gt;(); fromArrayToCollection(sa, cs); Collection&lt;Double&gt; cd = new ArrayList&lt;&gt;(); // 下面代码中T是Double类，但sa是String类型，编译错误。 // fromArrayToCollection(sa, cd); // 下面代码中T是Object类型，sa是String类型，可以赋值成功。 fromArrayToCollection(sa, co);} 12345678910111213141516class Creature{}class Person extends Creature{} class Man extends Person{} class PersonTest { public static &lt;T extends Person&gt; void test(T t){ System.out.println(t); } public static void main(String[] args) { test(new Person()); test(new Man()); //The method test(T) in the type PersonTest is not //applicable for the arguments (Creature) test(new Creature()); }} 泛型在继承上的体现请输出如下的两段代码有何不同 123456public void printCollection(Collection c) { Iterator i = c.iterator(); for (int k = 0; k &lt; c.size(); k++) { System.out.println(i.next()); }} 12345public void printCollection(Collection&lt;Object&gt; c) { for (Object e : c) { System.out.println(e); }} 如果 B 是 A 的一个子类（子类或者子类接口），而G是具有泛型声明的类或接口，G&lt;B&gt;并不是G&lt;A&gt;的子类型！ 比如：String是Object的子类，但是List&lt;String &gt;并不是List&lt;Object&gt;的子类 123456789101112public void testGenericAndSubClass() { Person[] persons = null; Man[] mans = null; // 而 Person[] 是 Man[] 的父类. persons = mans; Person p = mans[0]; // 在泛型的集合上 List&lt;Person&gt; personList = null; List&lt;Man&gt; manList = null; // personList = manList;(报错)} 通配符的使用 使用类型 通配符：? 比如：List&lt;?&gt; , Map&lt;? , ?&gt; List&lt;?&gt;是List、List等各种泛型List的父类。 读取 List&lt;?&gt; 的对象 list 中的元素时，永远时安全的，因为不管 list 的真实类型是什么，它包含的都是 Object。 写入 list 中的元素时，不行。因为我们不知道 c 的元素类型，我们不能向其中添加对象。 唯一的例外时 null，它是所有类型的成员。 将任意元素加入到其中不是类型安全的： Collection&lt;?&gt; c = new ArrayList&lt;String&gt;(); c.add(new Object()); // 编译时错误 因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。 唯一的例外的是 null，它是所有类型的成员。 另一方面，我们可以调用 get() 方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个 Object 。 12345678910111213141516171819public static void main(String[] args) { List&lt;?&gt; list = null; list = new ArrayList&lt;String&gt;(); list = new ArrayList&lt;Double&gt;(); // list.add(3);//编译不通过list.add(null); List&lt;String&gt; l1 = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); l1.add(\"尚硅谷\"); l2.add(15); read(l1); read(l2);}public static void read(List&lt;?&gt; list) { for (Object o : list) { System.out.println(o); }} 通配符的使用：注意点//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?public static &lt;?&gt; void test(ArrayList&lt;?&gt; list){ } //注意点2：编译错误：不能用在泛型类的声明上class GenericTypeClass&lt;?&gt;{ } /注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象 ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;() 通配符的使用：有限制的通配符 &lt;?&gt; 允许所有泛型的引用调用 通配符指定上限 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 通配符指定下限 下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例： &lt;? extends Number&gt; (无穷小 , Number] 只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt; [Number , 无穷大) 只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt; 只允许泛型为实现Comparable接口的实现类的引用调用 123456789101112131415public static void printCollection3(Collection&lt;? extends Person&gt; coll) { //Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why? Iterator&lt;?&gt; iterator = coll.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }}public static void printCollection4(Collection&lt;? super Person&gt; coll) {//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why? Iterator&lt;?&gt; iterator = coll.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }} 练习题：为什么编译如下的操作会报错？ 泛型应用举例12345678910111213141516public static void main(String[] args) { HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = new HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;(); ArrayList&lt;Citizen&gt; list = new ArrayList&lt;Citizen&gt;(); list.add(new Citizen(\"刘恺威\")); list.add(new Citizen(\"杨幂\")); list.add(new Citizen(\"小糯米\")); map.put(\"刘恺威\", list); Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator(); while (iterator.hasNext()) { Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next(); String key = entry.getKey(); ArrayList&lt;Citizen&gt; value = entry.getValue(); System.out.println(\" 户 主 ：\" + key); System.out.println(\"家庭成员：\" + value); }} 泛型应用举例：实际案例用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。","link":"/2020/03/13/Java%E6%B3%9B%E5%9E%8B/"},{"title":"Java多线程","text":"本章节主要介绍线程的基本概念， 线程的创建和使用 ，线程的生命周期 ，线程的同步 ，线程的通信以及 JDK5.0 新增线程创建方式。 基本概念：程序、进程、线程程序程序（program）是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程进程（process）是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程：有它本身的产生、存在和消亡的过程。——生命周期 运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配单位，系统在运行时会为每个进程分配不同的内存区域 线程线程（thread）进程可以进一步细化为线程，是一个程序内部测一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和从程序计数器（pc），线程切换的开销小 一个进程中的多个线程共享相同的内存单元/内存地址空间 ——》它们从堆中分配对象，可以访问相同变量和对象。这就使得线程间通信更简单、高效。但多个线程操作共享的系统资源可能就会带来安全隐患。 单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。 使用多线程的优点背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 1.提高应用程序的响应。对图形化界面更有意义，可以增强用户体验。 2.提高计算机系统CPU的利用率。 3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程？ 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如果用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时。 线程的创建和使用 注意 ：上图里的程序不是多线程！ 线程的创建和启动 Java语言的JVM允许程序运行多个线程，它通过 java.lang.Thread 类来体现。 Thread 类的特性 每个线程都是通过某个特定 Thread 对象的 Run() 方法来完成操作的，经常把 run() 方法的主体称为线程体 通过该 Thread 对象的 start() 方法来启动这个线程，而非直接调用 run() Thread类 构造器 Thread(): 创建新的 Thread 对象 Thread(String threadname): 创建线程并指定线程的实例名 Thread(Runnable target): 指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法 Thread(Runnable target,String name): 创建新的 Thread 对象 API 中创建线程的两种方式 JDK 1.5 之前创建新执行线程有两种方法： 继承 Thread 类的方式 实现 Runnable 接口的方式 方式一：继承 Thread 类 定义子类继承 Thread 类 子类中重写 Thread 类中的 run 方法 创建 Thread 子类对象，即创建了线程对象 调用线程对象 start 方法：启动线程，调用 run 方法 MyThread 子线程的创建和启动过程 注意点： 如果自己手动调用 run() 方法，那么就只是普通方法，没有启动多线程模式。 run() 方法是油 JVM 调用，什么时候调用，执行的过程控制都有操作系统 CPU 调度决定。 想要启动多线程，必须调用 start 方法。 一个线程对象只能调用一次 start() 方法启动，如果重复调用了，则将抛出异常 “IllegalThreadStateException”。 方式二：实现 Runnable 接口 定义子类，实现 Runnable 接口。 子类中重写 Runnable 接口中的 run 方法。 通过 Thread 类含参构造器创建线程对象。 将 Runnable 接口的子类对象作为实际参数传递给 Thread 类的构造器中。 调用 Thread 类中的 start 方法：开启线程，调用 Runnable 子类接口的 run 方法。 继承方式和实现方式的联系与区别 public class Thread extends Object implements Runnable 区别 继承Thread: 线程代码存放Thread子类run方法中。 实现Runnable：线程代码存在接口的子类的run方法。 实现方式的好处 避免了单继承的局限性 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。 Thread类的有关方法 void start(): 启动线程，并执行对象的run()方法 run(): 线程在被调度时执行的操作 String getName(): 返回线程的名称 void setName(String name): 设置该线程名称 static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 Thread类的有关方法（2） static void yield(): 线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若对列中没有同优先级的线程，忽略此方法 join(): 当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis): (指定时间：毫秒) 令当前活动线程在指定的时间段内放弃对 CPU 控制，使其他线程有机会被执行，时间到后重排队。 抛出 InterruptedException 异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive(): 返回 boolean ,判断线程是否还活着 线程的调度 调度策略 时间片 抢占式：高优先级的线程抢占 CPU Java 的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级 线程的优先等级 MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5 涉及的方法 getPriority(): 返回线程优先值 setPriority(int newPriority): 改变线程的优先级 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 补充：线程的分类 Java中的线程分为两类：一种是守护线程，一种是用户线程。 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 Java 垃圾回收就是一个典型的守护线程。 若 JVM 中都是守护线程，当前JVM将退出。 形象理解：兔死狗烹，鸟尽弓藏 12345678910111213141516171819202122232425262728/** * 测试Thread中的常用方法： * 1. start():启动当前线程；调用当前线程的run() * 2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 * 3. currentThread():静态方法，返回执行当前代码的线程 * 4. getName():获取当前线程的名字 * 5. setName():设置当前线程的名字 * 6. yield():释放当前cpu的执行权 * 7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 * 结束阻塞状态。 * 8. stop():已过时。当执行此方法时，强制结束当前线程。 * 9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。 * 10. isAlive():判断当前线程是否存活 * * * 线程的优先级： * 1. * MAX_PRIORITY：10 * MIN _PRIORITY：1 * NORM_PRIORITY：5 --&gt;默认优先级 * 2.如何获取和设置当前线程的优先级： * getPriority():获取线程的优先级 * setPriority(int p):设置线程的优先级 * * 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 * 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 * */ 线程的生命周期JDK 中用 Thread.State 类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五中状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 堵塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程的同步 问题提出 多个线程执行的不确定性引起执行结果的不稳定 多个线程对账本的共享，会造成操作的不完整性，会破坏数据 例题 模拟火车站售票程序，开启三个窗口售票。 多线程出现安全问题 问题原因： 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。 解决办法 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 Synchronized 的使用方法 JAVA 对于多线程的安全问题提供了专业的解决方式：同步机制 同步代码块 synchronized(对象){ ​ //需要被同步的代码 } synchronized 还可以放在方法声明中，表示整个方法为同步方法例如： public synchronized void show (String name){ ​ … } 分析同步原理 同步机制中的锁 同步锁机制： 在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。 synchronized 的锁是什么？ 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 同步方法的锁：静态方法（类名.class）、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为this或类名.class 注意： 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this) ,同步代码块（指定需谨慎） 同步范围 如何找问题，即代码是否存在线程安全？(非常重要) 明确哪些代码是多线程运行的代码 明确多个线程是否有共享数据 明确多线程运行代码中是否有多条语句操作共享数据 如何解决呢？（非常重要） 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中。 切记： 范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能 释放锁操作 当前线程的同步方法、同步代码块执行结束。 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁 不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。 应尽量避免使用suspend()和resume()来控制线程 单例设计模式之懒汉式（线程安全） 1234567891011121314151617181920class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.Class){ if(instance == null){ instance = new Singleton(); } } } }}public calss SingletonTest{ public static void main(String[] args){ Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.printIn(s1 == s2); }} 线程的死锁问题 死锁 不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都出处于阻塞状态，无法继续 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.demo.test;class A { public synchronized void foo(B b) { System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 进入了A实例的foo方法\"); // ① try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 企图调用B实例的last方法\"); // ③ b.last(); } public synchronized void last() { System.out.println(\"进入了A类的last方法内部\"); }}class B { public synchronized void bar(A a) { System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 进入了B实例的bar方法\"); // ② try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\"当前线程名: \" + Thread.currentThread().getName() + \" 企图调用A实例的last方法\"); // ④ a.last(); } public synchronized void last() { System.out.println(\"进入了B类的last方法内部\"); }}public class DeadLock implements Runnable { A a = new A(); B b = new B(); public void init() { Thread.currentThread().setName(\"主线程\"); // 调用a对象的foo方法 a.foo(b); System.out.println(\"进入了主线程之后\"); } public void run() { Thread.currentThread().setName(\"副线程\"); // 调用b对象的bar方法 b.bar(a); System.out.println(\"进入了副线程之后\"); } public static void main(String[] args) { DeadLock dl = new DeadLock(); new Thread(dl).start(); dl.init(); }} Lock(锁)1234567891011Class A{ private final ReentrantLock lock = new ReentrantLock(); public void m(){ lock.lock(); try{ //保证线程安全代码； } finally { lock.unlock(); } }} 注意：如果同步代码有异常，要将 unlock() 写入 finally 语句块 Synchronized 与 Lock 的对比 Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是 隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序： Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源）-&gt; 同步方法（在方法体之外） 练习 银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 问题：该程序是否有安全问题，如果有，如何解决？ 【提示】 明确哪些代码式多线程运行代码，须写入 run() 方法 明确什么是共享数据 明确多线程运行代码中那些语句是操作共享数据的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 银行有一个账户。 有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 分析： 1.是否是多线程问题？ 是，两个储户线程 2.是否有共享数据？ 有，账户（或账户余额） 3.是否有线程安全问题？有 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。 * @author shkstart * @create 2019-02-15 下午 3:54 */class Account{ private double balance; public Account(double balance) { this.balance = balance; } //存钱 public synchronized void deposit(double amt){ if(amt &gt; 0){ balance += amt; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":存钱成功。余额为：\" + balance); } }}class Customer extends Thread{ private Account acct; public Customer(Account acct) { this.acct = acct; } @Override public void run() { for (int i = 0; i &lt; 3; i++) { acct.deposit(1000); } }}public class AccountTest { public static void main(String[] args) { Account acct = new Account(0); Customer c1 = new Customer(acct); Customer c2 = new Customer(acct); c1.setName(\"甲\"); c2.setName(\"乙\"); c1.start(); c2.start(); }} 拓展问题：可否实现两个储户交替存钱操作 线程的通信例题：使用两个线程打印 1-100。线程1，线程2交替打印 wait() 与 notify() 和 notifyAll() wait(): 令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用 notify（）或者 notifyAll（）方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。 notify(): 唤醒正在排队等待同步资源的线程中优先级最高者结束等待。 notifyAll(): 唤醒正在排队等待资源的所有线程结束等待。 这三个方法只有在 synchronized 方法或 synchronized 代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException 异常。 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。 wait() 方法 在当前线程中调用方法：对象名.wait() 使当前线程进入等待（某对象）状态，直到另一线程对该对象发出 notify (或者是 notifyAll) 为止 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 调用此方法后，当前线程将释放对象监控权，然后进入等待 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行 notify() / notifyAll() 在当前线程中调用方法：对象名.notify() 功能：唤醒等待该对象监控权的一个 / 所有线程 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 经典例题：生产者 / 消费者问题 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 这里可能出现两个问题： 生产者比消费者快时，消费者会漏掉一些数据没有取到 消费者比生产者快时，消费者会取相同的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.example.demo.test;class Clerk { //售货员 private int product = 0; public synchronized void addProduct() { if(product &gt;= 20) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { product++; System.out.println(\"生产者生产了第\" + product + \"个产品\"); notifyAll(); } } public synchronized void getProduct() { if(this.product &lt;= 0) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { System.out.println(\"消费者取走了第\" +product + \"个产品\"); product--; notifyAll(); } }}class Productor implements Runnable { //生产者 Clerk clerk; public Productor(Clerk clerk) { this.clerk = clerk; } public void run() { System.out.println(\"生产者开始生产产品。。。\"); while (true) { try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.addProduct(); } }}class Consumer implements Runnable {//消费者 Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } public void run() { System.out.println(\"消费者开始取走产品\"); while (true) { try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.getProduct(); } }}public class BankTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Thread productorThread = new Thread(new Productor(clerk)); Thread consumerThread = new Thread(new Consumer(clerk)); productorThread.start(); consumerThread.start(); }} 练习 模拟银行取钱问题 定义一个Account类 该Account类封装了账户编号（String）和余额（double）两个属性 设置相应属性的getter和setter方法 提供无参和有两个参数的构造器 系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写 提供两个取钱的线程类：小明、小明’s wife 提供了Account类的account属性和double类的取款额的属性 提供带线程名的构造器 run()方法中提供取钱的操作 在主类中创建线程进行测试，考虑线程安全问题 JDK5.0 新增线程创建方式新增方式一：实现 Callable 接口 与使用Runnable相比， Callable功能更强大些 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future 接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等 FutrueTask是Futrue接口的唯一的实现类 FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 新增方式二：使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 … 线程池 API JDK 5.0 起提供了线程池相关API：ExecutorService 和 Executors ExecutorService: 真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable Future submit(Callable task)：执行任务，有返回值，一般用来执行Callable void shutdown() ：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。","link":"/2020/02/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"git扩展知识","text":"Git 的诞生，集中式 vs 分布式，工作区、暂存区和版本库，Git 与 SVN 的区别。 Git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 集中式vs分布式Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 基本概念我们先来理解下Git 工作区、暂存区和版本库概念工作区： 就是你在电脑里能看到的目录。暂存区： 英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。版本库： 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 左侧为工作区，右侧为版本库 在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 .git/objects目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作git commit时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm --cached命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout -- 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行git checkout HEAD . 或者 git checkout HEAD命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别点： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 常见问题1234567891011gitThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; merged0.9.6 新建本地分支后将本地分支推送到远程库, 使用git pull 或者 git push 的时候报错 是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .根据命令行提示只需要执行以下命令即可 git branch –set-upstream-to=origin/远程分支的名字 本地分支的名字如： 1git branch --set-upstream master origin/master Please move or remove them before you can merge在使用git pull时,经常会遇到报错:Please move or remove them before you can merge 这是因为本地有修改,与云端别人提交的修改冲突,又没有merge. 如果确定使用云端的代码,最方便的解决方法是删除本地修改,可以使用以下命令: 1234git clean -d -fx \"\"d -----删除未被添加到git的路径中的文件f -----强制运行x -----删除忽略文件已经对git来说不识别的文件 注意:该命令会删除本地的修改,最好先备份再使用 1234567git clean 参数 -n 显示 将要 删除的 文件 和 目录 -f 删除 文件，-df 删除 文件 和 目录git clean -ngit clean -dfgit clean -f the branch XXX is not fully merged 提示: the branch XXX is not fully merged 解决方法： 使用大写的D 强制删除 git branch -D XXX .gitignore配置语法： 123456以斜杠“/”开头表示目录；以星号“*”通配多个字符；以问号“?”通配单个字符以方括号“[]”包含单个字符的匹配列表；以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 此外，git 对于.gitignore配置文件是按行从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效； 示例：忽略目录 fd1 下的全部内容 1fd1/* 注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； *忽略根目录下的 /fd1/ 目录的全部内容* 1/fd1/* 要注意以上两个示例的区别 1234/*!.gitignore!/fw/bin/!/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录 过滤整个文件夹 1/mtk/ 过滤所有.zip文件 1*.zip 过滤某个具体文件 1/mtk/do.c 注意事项如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。 不要误解了 .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效。 重置.gitignore规则123git rm -r --cached .git add .git commit -m 'update .gitignore' 《Pro Git》学习笔记","link":"/2020/02/26/git%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"},{"title":"io流","text":"​ File类的使用，File类的使用，File类的使用，缓冲流，转换流，标准输入、输出流，打印流，数据流，对象流，随机存取文件流，NIO.2中Path、Paths、Files类的使用。 File类的使用 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关 File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。 File 对象可以作为参数传递给流的构造器 常用构造器 public File (String pathname) 以pathname为路径创建File对象，可以是绝对路径或者是相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 绝对路径：是一个固定的路径，从盘符开始 相对路径：是相对于某个位置开始 pulic File (String parent, String child) 以 parent 为父路径， child 为子路径创建 File 对象 public File(File parent, String child) 根据一个父 File 对象和子文件路径创建 File 对象 路径分隔符 路径中的每级目录之间用一个路径分隔符隔开。 路径分隔符和系统有关： windows和DOS系统默认使用“\\”来表示 UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用。 为了解决这个隐患，File类提供了一个常量： public static final String separator。根据操作系统，动态的提供分隔符。 举例： 123File file1 = new File(\"d:\\\\cactus\\\\info.txt\");File file2 = new File(\"d:\" + File.separator + \"cactus\" + File.separator + \"info.txt\");File file3 = new File(\"d:/cactus\"); 常用方法 File类的获取功能 public String getAbsolutePath()：获取绝对路径 public String getPath() ：获取路径 public String getName() ：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 public long lastModified() ：获取最后一次的修改时间，毫秒值 public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组 public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组 File类的重命名功能 public boolean renameTo(File dest):把文件重命名为指定的文件路径 File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile() ：判断是否是文件 public boolean exists() ：判断是否存在 public boolean canRead() ：判断是否可读 public boolean canWrite() ：判断是否可写 public boolean isHidden() ：判断是否隐藏 File类的创建功能 public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建 注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目 路径下。 File类的删除功能 public boolean delete()：删除文件或者文件夹 删除注意事项： Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 File类的使用 123456789101112131415161718File dir1 = new File(\"D:/IO/dir1\");if (!dir1.exists()) { // 如果 D:/IO/dir1 不存在，就创建为目录 dir1.mkdir();}// 创建以dir1为父目录，名为 “dir2” 的File 对象File dir2 = new File(dir1, \"dir2\");if(!dir2.exists()) { // 如果还不存在，就创建为目录 dir2.mkdirs();}File dir4 = new File(dir, \"dir3/dir4\");if (!dir4.exists()) { dir4.mkdirs();}// 创建以 dir2 为父目录，名为“test.txt” 的 File 对象File file = new File(dir2, \"test.txt\");if (!file.exists()) { // 如果还不存在，就创建为文件 file.createNewFile();} 【练习】 利用File构造器，new 一个文件目录file 在其中创建多个文件和目录 编写方法，实现删除file中指定文件的操作 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class FindJPGFileTest { @Test public void test1(){ File srcFile = new File(\"d:\\\\code\"); String[] fileNames = srcFile.list(); for(String fileName : fileNames){ if(fileName.endsWith(\".jpg\")){ System.out.println(fileName); } } } @Test public void test2(){ File srcFile = new File(\"d:\\\\code\"); File[] listFiles = srcFile.listFiles(); for(File file : listFiles){ if(file.getName().endsWith(\".jpg\")){ System.out.println(file.getAbsolutePath()); } } } /* * File类提供了两个文件过滤器方法 * public String[] list(FilenameFilter filter) * public File[] listFiles(FileFilter filter) */ @Test public void test3(){ File srcFile = new File(\"d:\\\\code\"); File[] subFiles = srcFile.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".jpg\"); } }); for(File file : subFiles){ System.out.println(file.getAbsolutePath()); } } } 遍历指定目录所有文件名称，包括子文件目录中的文件。 拓展1：并计算指定目录占用空间的大小 拓展2：删除指定文件目录及其下的所有文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class ListFilesTest { public static void main(String[] args) { // 递归:文件目录 /** 打印出指定目录所有文件名称，包括子文件目录中的文件 */ // 1.创建目录对象 File dir = new File(\"E:\\\\teach\\\\01_javaSE\\\\_尚硅谷Java编程语言\\\\3_软件\"); // 2.打印目录的子文件 printSubFile(dir); } public static void printSubFile(File dir) { // 打印目录的子文件 File[] subfiles = dir.listFiles(); for (File f : subfiles) { if (f.isDirectory()) {// 文件目录 printSubFile(f); } else {// 文件 System.out.println(f.getAbsolutePath()); } } } // 方式二：循环实现 // 列出file目录的下级内容，仅列出一级的话 // 使用File类的String[] list()比较简单 public void listSubFiles(File file) { if (file.isDirectory()) { String[] all = file.list(); for (String s : all) { System.out.println(s); } } else { System.out.println(file + \"是文件！\"); } } // 列出file目录的下级，如果它的下级还是目录，接着列出下级的下级，依次类推 // 建议使用File类的File[] listFiles() public void listAllSubFiles(File file) { if (file.isFile()) { System.out.println(file); } else { File[] all = file.listFiles(); // 如果all[i]是文件，直接打印 // 如果all[i]是目录，接着再获取它的下一级 for (File f : all) { listAllSubFiles(f);// 递归调用：自己调用自己就叫递归 } } } // 拓展1：求指定目录所在空间的大小 // 求任意一个目录的总大小 public long getDirectorySize(File file) { // file是文件，那么直接返回file.length() // file是目录，把它的下一级的所有大小加起来就是它的总大小 long size = 0; if (file.isFile()) { size += file.length(); } else { File[] all = file.listFiles();// 获取file的下一级 // 累加all[i]的大小 for (File f : all) { size += getDirectorySize(f);// f的大小; } } return size; } // 拓展2：删除指定的目录 public void deleteDirectory(File file) { // 如果file是文件，直接delete // 如果file是目录，先把它的下一级干掉，然后删除自己 if (file.isDirectory()) { File[] all = file.listFiles(); // 循环删除的是file的下一级 for (File f : all) {// f代表file的每一个下级 deleteDirectory(f); } } // 删除自己 file.delete(); }} IO流原理及流的分类Google I/O 寓为“开放中创新” (Innovation in the Open) Input/Output 二进制1,0 Java IO 原理 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。 java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 流的分类 按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit) 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流 (抽象基类) 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。 IO流体系 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStram PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferdOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 节点流和处理流 节点流：直接从数据源或目的地读写数据 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。 InputStream &amp; Reader lnputStream 和 Reader 是所有输入流的基类。 lnputStream（典型实现：FileInputStream） int read() int read(byte[] b) int read(byte[] b, int off, int len) Reader（典型实现：FileReader） int read() int read(char[] c) int read(char[] c, int off, int len) 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。 FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader InputStream int read() 从输入流中读取数据的下一个字节。返回 0 到 255 范围内的int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。 int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off, int len) 将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。 public void close() throws IOException 关闭此输入流并释放与该流关联的所有系统资源。 Reader int read() 读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 int read(char[] cbuf) 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。 public void close() throws IOException 关闭此输入流并释放与该流关联的所有系统资源。 OutputStream &amp; Writer OutputStream 和 Writer 也非常相似： void write(int b/int c);void write(byte[] b/char[] cbuf);void write(byte[] b/char[] buff, int off, int len);void flush();void close(); 需要先刷新，再关闭此流 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组， 即以 String 对象作为参数 void write(String str);void write(String str, int off, int len); FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream 用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter OutputStream void write(int b) 将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 void write(byte[] b) 将b.length 个字节从指定的byte 数组写入此输出流。write(b) 的常规协定是：应该与调用write(b, 0, b.length) 的效果完全相同。 void write(byte[] b, int off, int len) 将指定byte 数组中从偏移量 off 开始的len 个字节写入此输出流。 public void flush() throws IOException 刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException 关闭此输出流并释放与该流关联的所有系统资源。 writer void write(int c) 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 void write(char[] cbuf) 写入字符数组。 void write(char[] cbuf, int off, int len)* void write(String str) 写入字符数组的某一部分。从off开始，写入len个字符 void write(String str, int off, int len) 写入字符串。 void flush() 刷新该流的缓冲，则立即将它们写入预期目标。 public void close() throws IOException 关闭此输出流并释放与该流关联的所有系统资源。 节点流（或文件流）读取文件 建立一个流对象，将已存在的一个文件加载进流。 FileReader fr = new FileReader(new File(“Test.txt”)); 创建一个临时存放数据的数组 char[] ch = new char[1024]; 调用流对象的读取方法将流中的数据读入到数组中。 fr.read(ch); 关闭资源。 fr.close(); 1234567891011121314151617FileReader fr = null; try { fr = new FileReader(new File(\"c:\\\\test.txt\")); char[] buf = new char[1024]; int len; while ((len = fr.read(buf)) != -1) { System.out.print(new String(buf, 0, len)); }} catch (IOException e) { System.out.println(\"read-Exception :\" + e.getMessage());} finally { if (fr != null) { try { fr.close(); } catch (IOException e) { System.out.println(\"close-Exception :\" + e.getMessage()); } }} 写入文件 创建流对象，建立数据存放文件 FileWriter fw = new FileWriter(new File(“Test.txt”)); 调用流对象的写入方法，将数据写入流 fw.write(“atguigu-songhongkang”); 关闭流资源，并将流中的数据清空到文件中。 fw.close(); 12345678910111213FileWriter fw = null; try { fw = new FileWriter(new File(\"Test.txt\")); fw.write(\"cactus.cbvn\");} catch (IOException e) { e.printStackTrace();} finally { if (fw != null) try { fw.close(); } catch (IOException e) { e.printStackTrace(); }} 定义文件路径时，注意：可以用“/”或者“\\”。 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。 如果使用构造器FileOutputStream(file,true),则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。 在读取文件时，必须保证该文件已存在，否则报异常。 字节流操作字节，比如：.mp3, .avi, .rmvb, mp4, jpg, doc, .ppt 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt, java, .c, .cpp 等语言的源代码。尤其注意 .doc, excel, ppt 这些不是文本文件。 缓冲流 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为： BufferedInputStream 和 BufferedOutputStream BufferedReader 和 BufferedWriter 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，（BufferedOutputStream）才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 flush()方法的使用：手动将buffer中内容写入文件 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出 12345678910111213141516171819202122232425262728293031BufferedReader br = null; BufferedWriter bw = null; try { // 创建缓冲流对象：它是处理流，是对节点流的包装 br = new BufferedReader(new FileReader(\"d:\\\\IOTest\\\\source.txt\")); bw = new BufferedWriter(new FileWriter(\"d:\\\\IOTest\\\\dest.txt\")); String str; while ((str = br.readLine()) != null) { // 一次读取字符文本文件的一行字符 bw.write(str); // 一次写入一行字符串 bw.newLine(); // 写入行分隔符 } bw.flush(); // 刷新缓冲区} catch (IOException e) { e.printStackTrace();} finally { // 关闭IO流对象 try { if (bw != null) { bw.close(); // 关闭过滤流时,会自动关闭它所包装的底层节点流 } } catch (IOException e) { e.printStackTrace(); } try { if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); }} 【练习】 分别使用节点流：FileInputStream、FileOutputStream和缓冲流： BufferedInputStream、BufferedOutputStream实现文本文件/图片/视频文件的复制。并比较二者在数据复制方面的效率 实现图片加密操作。 提示： 1234int b = 0;while((b = fis.read()) != -1){ fos.write(b ^ 5);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class PicTest { //图片的加密 @Test public void test1() { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(\"测试.jpg\"); fos = new FileOutputStream(\"测试secret.jpg\"); byte[] buffer = new byte[20]; int len; while ((len = fis.read(buffer)) != -1) { //字节数组进行修改 //错误的 // for(byte b : buffer){ // b = (byte) (b ^ 5); // } //正确的 for (int i = 0; i &lt; len; i++) { buffer[i] = (byte) (buffer[i] ^ 5); } fos.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } //图片的解密 @Test public void test2() { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(\"测试secret.jpg\"); fos = new FileOutputStream(\"测试.jpg\"); byte[] buffer = new byte[20]; int len; while ((len = fis.read(buffer)) != -1) { //字节数组进行修改 //错误的 // for(byte b : buffer){ // b = (byte) (b ^ 5); // } //正确的 for (int i = 0; i &lt; len; i++) { buffer[i] = (byte) (buffer[i] ^ 5); } fos.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 获取文本上每个字符出现的次数 提示：遍历文本的每一个字符；字符及出现的次数保存在Map中；将Map中数据写入文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 练习3:获取文本上字符出现的次数,把数据写入文件 * * 思路： * 1.遍历文本每一个字符 * 2.字符出现的次数存在Map中 * * Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); * map.put('a',18); * map.put('你',2); * * 3.把map中的数据写入文件 * * @author cactus * @create 2020 下午 12:23 */public class WordCount { /* 说明：如果使用单元测试，文件相对路径为当前module 如果使用main()测试，文件相对路径为当前工程 */ @Test public void testWordCount() { FileReader fr = null; BufferedWriter bw = null; try { //1.创建Map集合 Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); //2.遍历每一个字符,每一个字符出现的次数放到map中 fr = new FileReader(\"dbcp.txt\"); int c = 0; while ((c = fr.read()) != -1) { //int 还原 char char ch = (char) c; // 判断char是否在map中第一次出现 if (map.get(ch) == null) { map.put(ch, 1); } else { map.put(ch, map.get(ch) + 1); } } //3.把map中数据存在文件count.txt //3.1 创建Writer bw = new BufferedWriter(new FileWriter(\"wordcount.txt\")); //3.2 遍历map,再写入数据 Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) { switch (entry.getKey()) { case ' ': bw.write(\"空格=\" + entry.getValue()); break; case '\\t'://\\t表示tab 键字符 bw.write(\"tab键=\" + entry.getValue()); break; case '\\r':// bw.write(\"回车=\" + entry.getValue()); break; case '\\n':// bw.write(\"换行=\" + entry.getValue()); break; default: bw.write(entry.getKey() + \"=\" + entry.getValue()); break; } bw.newLine(); } } catch (IOException e) { e.printStackTrace(); } finally { //4.关流 if (fr != null) { try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } if (bw != null) { try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 转换流 转换流提供了在字节流和字符流之间的转换 Java API 提供了两个转换流： InputStreamReader: 将InputStream转换成为Reader OutputStreamWriter:将Writer转换为OutputStream 字节流中的数据都是字符时，转换成字符流操作更高效 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码功能。 InputStreamReader 实现将字节的输入流按指定字符集转换为字符的输入流。 需要和InputStream “套接”。 构造器 public InputStreamReader(InputStream in) public InputStreamReader(InputStream in,String charsetName) 如：Reader isr = new InputStreamReader(System.in, “gbk”) 指定字符集 OutputStreamWriter 实现将字符的输出流按指定字符集转换为字节的输出流。 需要和OutputStream“套接”。 构造器 public OutputStreamWriter(OutputStream out) public OutputStreamWriter(OutputStream out, String charsetName) 123456789101112131415161718public void testMyInput() throws Exception { FileInputStream fis = new FileInputStream(\"cactus.txt\"); FileOutputStream fos = new FileOutputStream(\"cactus5.txt\"); InputStreamReader isr = new InputStreamReader(fis, \"GBK\"); OutputStreamWriter osw = new OutputStreamWriter(fos, \"GBK\"); BufferedReader br = new BufferedReader(isr); BufferedWriter bw = new BufferedWriter(osw); String str = null; while ((str = br.readLine()) != null) { bw.write(str); bw.newLine(); bw.flush(); } bw.close(); br.close();} 补充：字符编码 编码表的由来 计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。 常见的编码表 ASCII：美国标准信息交换码。 用一个字节的7位可以表示。 ISO8859-1：拉丁码表。欧洲码表 用一个字节的8位表示。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的（即字符集≈编码方式，都是直接将字符和最终字节流绑定死了。 GBK等双字节编码方式，用最高位是1或0表示两个字节和一个字节。 Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节， 就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。 面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF- 8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。 Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） —————————————————————– 0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII） 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 编码：字符串 -&gt; 字节数组 解码：字节数组 -&gt; 字符串 转换流的编码应用 可以将字符按指定编码格式存储 可以对文本数据按指定编码格式来解读 指定编码表的动作由构造器完成 标准输入、输出流 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变。 public static void setIn(InputStream in) public static void setOut(PrintStream out) 【例题】 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。 12345678910111213141516171819202122System.out.println(\"请输入信息(退出输入e或exit):\");// 把\"标准\"输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String s = null; try { while ((s = br.readLine()) != null) { // 读取用户输入的一行数据 --&gt; 阻塞程序 if (\"e\".equalsIgnoreCase(s) || \"exit\".equalsIgnoreCase(s)) { System.out.println(\"安全退出!!\"); break; } // 将读取到的整行字符串转成大写输出System.out.println(\"--&gt;:\" + s.toUpperCase()); System.out.println(\"继续输入信息\"); }} catch (IOException e) { e.printStackTrace();} finally { try { if (br != null) { br.close(); // 关闭过滤流时,会自动关闭它包装的底层节点流 } } catch (IOException e) { e.printStackTrace(); }} 打印流 实现将基本数据类型的数据格式转化为字符串输出 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 rintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 123456789101112131415161718192021PrintStream ps = null; try { FileOutputStream fos = new FileOutputStream(new File(\"D:\\\\IO\\\\text.txt\")); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\\n' 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) {// 把标准输出流(控制台输出)改成文件 System.setOut(ps); } for (int i = 0; i &lt;= 255; i++) { // 输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) { // 每50个数据一行 System.out.println(); // 换 行 } }} catch (FileNotFoundException e) { e.printStackTrace();} finally { if (ps != null) { ps.close(); }} 数据流 为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。 数据流有两个类：(用于读取和写出基本数据类型、String类的数据） DataInputStream 和 DataOutputStream 分别“套接”在 InputStream 和 OutputStream 子类的流上 DataInputStream中的方法boolean readBoolean() byte readByte()char readChar() float readFloat()double readDouble() short readShort()long readLong() int readInt()String readUTF() void readFully(byte[] b) DataOutputStream中的方法 将上述的方法的read改为相应的write即可 12345678910111213141516171819DataOutputStream dos = null;try { // 创建连接到指定文件的数据输出流对象 dos = new DataOutputStream(new FileOutputStream(\"destData.dat\")); dos.writeUTF(\"我爱北京天安门\"); // 写UTF字符串 dos.writeBoolean(false); // 写入布尔值 dos.writeLong(1234567890L); // 写入长整数 System.out.println(\"写文件成功!\");} catch (IOException e) { e.printStackTrace();} finally { // 关闭流对象try { if (dos != null) { // 关闭过滤流时,会自动关闭它包装的底层节点流 dos.close(); } } catch (IOException e) { e.printStackTrace(); }} 1234567891011121314151617181920DataInputStream dis = null;try { dis = new DataInputStream(new FileInputStream(\"destData.dat\")); String info = dis.readUTF(); boolean flag = dis.readBoolean(); long time = dis.readLong(); System.out.println(info); System.out.println(flag); System.out.println(time);} catch (Exception e) { e.printStackTrace();} finally { if (dis != null) { try { dis.close(); } catch (IOException e) { e.printStackTrace(); } }} 对象流 ObjectInputStream和OjbectOutputSteam 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础 l如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常 Serializable Externalizable 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： private static final long serialVersionUID;调用 readObject() 方法读取流中的对象 serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象 进行版本控制，有关各版本反序列化时是否兼容。 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验 证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException 若某个类实现了 Serializable 接口，该类的对象就是可序列化的： 创建一个 ObjectOutputStream 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 注意写出一次，操作flush()一次 反序列化 创建一个 ObjectInputStream 调用 readObject() 方法读取流中的对象 强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化 【序列化：将对象写入到磁盘或者进行网络传输】 【要求对象必须实现序列化】 12345ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“data.txt\"));Person p = new Person(\"韩梅梅\", 18, \"中华大街\", new Pet());oos.writeObject(p);oos.flush();oos.close(); 【反序列化：将磁盘中的对象数据源读出】 123ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“data.txt\"));Person p1 = (Person)ois.readObject(); System.out.println(p1.toString()); ois.close(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 对象流的使用 * 1.ObjectInputStream 和 ObjectOutputStream * 2.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 * * 3.要想一个java对象是可序列化的，需要满足相应的要求。见Person.java * * 4.序列化机制： * 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种 * 二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。 * 当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。 */public class ObjectInputOutputStreamTest { /* 序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去 使用ObjectOutputStream实现 */ @Test public void testObjectOutputStream(){ ObjectOutputStream oos = null; try { //1. oos = new ObjectOutputStream(new FileOutputStream(\"object.dat\")); //2. oos.writeObject(new String(\"我爱北京天安门\")); oos.flush();//刷新操作 oos.writeObject(new Person(\"王铭\",23)); oos.flush(); oos.writeObject(new Person(\"张学良\",23,1001,new Account(5000))); oos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(oos != null){ //3. try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 反序列化：将磁盘文件中的对象还原为内存中的一个java对象 使用ObjectInputStream来实现 */ @Test public void testObjectInputStream(){ ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"object.dat\")); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); Person p1 = (Person) ois.readObject(); System.out.println(str); System.out.println(p); System.out.println(p1); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if(ois != null){ try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗？ 实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。 由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。 随机存取文件流RandomAccessFile 类 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。 RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针： long getFilePointer()：获取文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到 pos 位置 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式： r: 以只读方式打开 rw：打开以便读取和写入 rwd:打开以便读取和写入；同步文件内容的更新 rws:打开以便读取和写入；同步文件内容和元数据的更新 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件， 如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。 我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以自己实现下。 【读取文件】 12345678910RandomAccessFile raf = new RandomAccessFile(“test.txt”, “rw”）; raf.seek(5);byte [] b = new byte[1024];int off = 0; int len = 5;raf.read(b, off, len);String str = new String(b, 0, len); System.out.println(str);raf.close(); 【写入文件】 12345678910RandomAccessFile raf = new RandomAccessFile(\"test.txt\", \"rw\"); raf.seek(5);//先读出来String temp = raf.readLine();raf.seek(5); raf.write(\"xyz\".getBytes()); raf.write(temp.getBytes());raf.close(); 12345678910111213141516171819202122RandomAccessFile raf1 = new RandomAccessFile(\"hello.txt\", \"rw\");raf1.seek(5);//方式一：//StringBuilder info = new StringBuilder((int) file.length());//byte[] buffer = new byte[10];//int len;//while((len = raf1.read(buffer)) != -1){////info += new String(buffer,0,len);//info.append(new String(buffer,0,len));//}//方式二：ByteArrayOutputStream baos = new ByteArrayOutputStream();byte[] buffer = new byte[10];int len;while((len = raf1.read(buffer)) != -1){ baos.write(buffer, 0, len);}raf1.seek(5); raf1.write(\"xyz\".getBytes()); raf1.write(baos.toString().getBytes());baos.close();raf1.close(); 【流的基本小结】 流是用来处理数据的。 处理数据时，一定要先明确数据源，与数据目的地 数据源可以是文件，可以是键盘。 数据目的地可以是文件、显示器或者其他设备。 而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、转换处理等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * RandomAccessFile的使用 * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 * * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。 * 如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖） * * 4. 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果 * * @author shkstart * @create 2019 上午 11:18 */public class RandomAccessFileTest { @Test public void test1() { RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try { //1. raf1 = new RandomAccessFile(new File(&quot;爱情与友情.jpg&quot;),&quot;r&quot;); raf2 = new RandomAccessFile(new File(&quot;爱情与友情1.jpg&quot;),&quot;rw&quot;); //2. byte[] buffer = new byte[1024]; int len; while((len = raf1.read(buffer)) != -1){ raf2.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { //3. if(raf1 != null){ try { raf1.close(); } catch (IOException e) { e.printStackTrace(); } } if(raf2 != null){ try { raf2.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Test public void test2() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;); raf1.seek(3);//将指针调到角标为3的位置 raf1.write(&quot;xyz&quot;.getBytes());// raf1.close(); } /* 使用RandomAccessFile实现数据的插入效果 */ @Test public void test3() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;); raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1){ builder.append(new String(buffer,0,len)) ; } //调回指针，写入“xyz” raf1.seek(3); raf1.write(&quot;xyz&quot;.getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); raf1.close(); //思考：将StringBuilder替换为ByteArrayOutputStream }} NIO.2中Path、Paths、Files类的使用Java NIO 概述 Java NIO 概述Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 java.nio.channels.Channel FileChannel:处理本地文件 SocketChannel：TCP网络编程的客户端的Channel ServerSocketChannel: TCP网络编程的服务器端的Channel DatagramChannel：UDP网络编程中发送端和接收端的Channel NIO. 2 随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分 Path、Paths和Files核心API 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。 NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。 在以前IO操作都是这样写的: 12import java.io.File;File file = new File(\"index.html\"); 但在ava7 中，我们可以这样写： 123import java.nio.file.Path;import java.nio.file.Paths;Path path = Paths.get(\"index.html\"); 同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。 Paths 类提供的静态 get() 方法用来获取 Path 对象： static Path get(String first, String … more) : 用于将多个字符串串连成路径 static Path get(URI uri): 返回指定uri对应的Path路径 Path接口 Path 常用方法： String toString() ： 返回调用 Path 对象的字符串表示形式 boolean startsWith(String path) : 判断是否以 path 路径开始 boolean endsWith(String path) : 判断是否以 path 路径结束 boolean isAbsolute() : 判断是否是绝对路径 Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 Path getRoot() ：返回调用 Path 对象的根路径 Path getFileName() : 返回与调用 Path 对象关联的文件名 int getNameCount() : 返回Path 根目录后面元素的数量 Path getName(int idx) : 返回指定索引位置 idx 的路径名称 Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象 Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象 File toFile(): 将Path转化为File类的对象 Files 类 java.nio.file.Files 用于操作文件或目录的工具类。 Files常用方法： Path copy(Path src, Path dest, CopyOption … how) : 文件的复制 Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录 Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件 void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错 void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除 Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置 long size(Path path) : 返回 path 指定文件的大小 Files常用方法：用于判断 boolean exists(Path path, LinkOption … opts) : 判断文件是否存在 boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录 boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件 boolean isHidden(Path path) : 判断是否是隐藏文件 boolean isReadable(Path path) : 判断文件是否可读 boolean isWritable(Path path) : 判断文件是否可写 boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在 Files常用方法：用于操作内容 SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。 DirectoryStream&lt;Path&gt; newDirectoryStream(Path path) : 打开 path 指定的目录 InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象 OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象 【练习】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 1. jdk 7.0 时，引入了 Path、Paths、Files三个类。 * 2.此三个类声明在：java.nio.file包下。 * 3.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关 * &lt;p&gt; * 4.如何实例化Path:使用Paths. * static Path get(String first, String … more) : 用于将多个字符串串连成路径 * static Path get(URI uri): 返回指定uri对应的Path路径 */public class PathTest { //如何使用Paths实例化Path @Test public void test1() { Path path1 = Paths.get(\"d:\\\\nio\\\\hello.txt\");//new File(String filepath) Path path2 = Paths.get(\"d:\\\\\", \"nio\\\\hello.txt\");//new File(String parent,String filename); System.out.println(path1); System.out.println(path2); Path path3 = Paths.get(\"d:\\\\\", \"nio\"); System.out.println(path3); } //Path中的常用方法 @Test public void test2() { Path path1 = Paths.get(\"d:\\\\\", \"nio\\\\nio1\\\\nio2\\\\hello.txt\"); Path path2 = Paths.get(\"hello.txt\");// String toString() ： 返回调用 Path 对象的字符串表示形式 System.out.println(path1);// boolean startsWith(String path) : 判断是否以 path 路径开始 System.out.println(path1.startsWith(\"d:\\\\nio\"));// boolean endsWith(String path) : 判断是否以 path 路径结束 System.out.println(path1.endsWith(\"hello.txt\"));// boolean isAbsolute() : 判断是否是绝对路径 System.out.println(path1.isAbsolute() + \"~\"); System.out.println(path2.isAbsolute() + \"~\");// Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 System.out.println(path1.getParent()); System.out.println(path2.getParent());// Path getRoot() ：返回调用 Path 对象的根路径 System.out.println(path1.getRoot()); System.out.println(path2.getRoot());// Path getFileName() : 返回与调用 Path 对象关联的文件名 System.out.println(path1.getFileName() + \"~\"); System.out.println(path2.getFileName() + \"~\");// int getNameCount() : 返回Path 根目录后面元素的数量// Path getName(int idx) : 返回指定索引位置 idx 的路径名称 for (int i = 0; i &lt; path1.getNameCount(); i++) { System.out.println(path1.getName(i) + \"*****\"); }// Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象 System.out.println(path1.toAbsolutePath()); System.out.println(path2.toAbsolutePath());// Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象 Path path3 = Paths.get(\"d:\\\\\", \"nio\"); Path path4 = Paths.get(\"nioo\\\\hi.txt\"); path3 = path3.resolve(path4); System.out.println(path3);// File toFile(): 将Path转化为File类的对象 File file = path1.toFile();//Path---&gt;File的转换 Path newPath = file.toPath();//File---&gt;Path的转换 }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Files工具类的使用：操作文件或目录的工具类 */public class FilesTest { @Test public void test1() throws IOException{ Path path1 = Paths.get(\"d:\\\\nio\", \"hello.txt\"); Path path2 = Paths.get(\"atguigu.txt\"); // Path copy(Path src, Path dest, CopyOption … how) : 文件的复制 //要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。// Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING); // Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录 //要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。 Path path3 = Paths.get(\"d:\\\\nio\\\\nio1\");// Files.createDirectory(path3); // Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件 //要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。 Path path4 = Paths.get(\"d:\\\\nio\\\\hi.txt\");// Files.createFile(path4); // void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错// Files.delete(path4); // void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束 Files.deleteIfExists(path3); // Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置 //要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。// Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE); // long size(Path path) : 返回 path 指定文件的大小 long size = Files.size(path2); System.out.println(size); } @Test public void test2() throws IOException{ Path path1 = Paths.get(\"d:\\\\nio\", \"hello.txt\"); Path path2 = Paths.get(\"atguigu.txt\");// boolean exists(Path path, LinkOption … opts) : 判断文件是否存在 System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS));// boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录 //不要求此path对应的物理文件存在。 System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));// boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件// boolean isHidden(Path path) : 判断是否是隐藏文件 //要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。// System.out.println(Files.isHidden(path1));// boolean isReadable(Path path) : 判断文件是否可读 System.out.println(Files.isReadable(path1));// boolean isWritable(Path path) : 判断文件是否可写 System.out.println(Files.isWritable(path1));// boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在 System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS)); } /** * StandardOpenOption.READ:表示对应的Channel是可读的。 * StandardOpenOption.WRITE：表示对应的Channel是可写的。 * StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略 * StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常 * * @author shkstart 邮箱：shkstart@126.com * @throws IOException */ @Test public void test3() throws IOException{ Path path1 = Paths.get(\"d:\\\\nio\", \"hello.txt\");// InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象 InputStream inputStream = Files.newInputStream(path1, StandardOpenOption.READ);// OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象 OutputStream outputStream = Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);// SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。 SeekableByteChannel channel = Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);// DirectoryStream&lt;Path&gt; newDirectoryStream(Path path) : 打开 path 指定的目录 Path path2 = Paths.get(\"e:\\\\teach\"); DirectoryStream&lt;Path&gt; directoryStream =Files.newDirectoryStream(path2); Iterator&lt;Path&gt; iterator = directoryStream.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } }}","link":"/2020/03/17/io%E6%B5%81/"},{"title":"java集合类","text":"本章主要介绍 Java集合框架概述，Collection接口方法，Iterator迭代器接口，Collection子接口一：List，Collection子接口二：Set，Map接口，Collections工具类的使用方法以及相关的 API。 Java集合框架概述 一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。 数组在内存存储方面的特点： 数组初始化以后，长度就确定了。 数组声明的类型，就决定了进行元素初始化时的类型 数组在存储数据方面的弊端： 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数 数组存储的数据是有序的、可以重复的。 &gt;存储数据的特点单一 Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。 Java 集合框架概述：集合的使用场景 Java 集合可分为 Collection 和 Map 两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 Set：元素无序、不可重复的集合 Set：元素无序、不可重复的集合 Java 集合框架概述：Collection接口继承树 JDK提供的集合API位于java.util包内 Java 集合框架概述：Map接口继承树 Collection接口方法Collection 接口 Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。 JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。 添加 add(Object obj) addAll(Collection coll) 获取有效元素的个数 int size() 清空集合 void clear() 是否是空集合 boolean isEmpty() 是否包含某个元素 boolean contains(Object obj)：是通过元素的equals方法来判断是否 是同一个对象 boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。 删除 boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 boolean removeAll(Collection coll)：取当前集合的差集 取两个集合的交集 boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c 集合是否相等 boolean equals(Object obj) 转成对象数组 Object[] toArray() 获取集合对象的哈希值 hashCode() 遍历 iterator()：返回迭代器对象，用于集合遍历 Iterator迭代器接口Iterator迭代器接口 Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 Iterator接口的方法 在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。 Iterator接口remove()方法 1234567Iterator iter = coll.iterator();//回到起点while(iter.hasNext()){ Object obj = iter.next(); if(obj.equals(\"Tom\")){ iter.remove(); }} 注意： Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。 使用 foreach 循环遍历集合元素 Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。 遍历集合的底层调用Iterator完成操作。 foreach还可以用来遍历数组。 练习：判断输出结果为何？ 123456789101112public class ForTest { public static void main(String[] args) { String[] str = new String[5]; for (String myStr : str) { myStr = \"xianrenqiu ....\"; System.out.println(myStr); // xianrenqiu .... } for (int i = 0; i &lt; str.length; i++) { System.out.println(str[i]); // null .... } }} Collection子接口之一：List接口List接口概述 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 List接口方法 List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。 void add(int index, Object ele):在index位置插入ele元素 boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 Object get(int index):获取指定index位置的元素 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 List实现类之一：ArrayList ArrayList 是 List 接口的典型实现类、主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 ArrayList的JDK1.8之前与之后的实现区别？ JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 【面试题】 1234567891011121314151617/*** 注意 remove(int index) 和 remove(Object obj);**/@Testpublic void testListRemove() { List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list);// [1,2]}private static void updateList(List list) { list.remove(2); //list.remove(new Integer(2));} List实现类之二：LinkedList 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。 新增方法： void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last， 用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基 本结构。Node除了保存数据，还定义了两个变量： prev变量记录前一个元素的位置 next变量记录下一个元素的位置 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} List 实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用 新增方法： void addElement(Object obj) void insertElementAt(Object obj,int index) void setElementAt(Object obj,int index) void removeElement(Object obj) void removeAllElements() 【面试题】： 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? ArrayList和LinkedList的异同 二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。 ArrayList和Vector的区别 Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。 Collection子接口之二：Set接口Set 接口概述 Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法 Set实现类之一：HashSet HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 HashSet 具有以下特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。 向HashSet中添加元素的过程： 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散 列函数设计的越好） 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128 等） 重写 hashCode() 方法的基本原则 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 重写 equals() 方法的基本原则 以自定义的Customer类为例，何时需要重写equals()？ 当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不 同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法， 它们仅仅是两个对象。 因此，违反了“相等的对象必须具有相等的散列码”。 结论：复写 equals 方法的时候一般都需要同时腹泻 hashCode 方法。通常参与计算机 hashCode 的对象的属性也应该参与到 equals() 中进行计算。 Eclipse/IDEA 工具里 hashCode() 的重写 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突） 并且31只占用5bits,相乘造成数据溢出的概率较小。 31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率） 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置， 但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。 LinkedHashSet 不允许集合元素重复。 12345Set set = new LinkedHashSet(); set.add(new String(\"AA\")); set.add(456);set.add(456);set.add(new Customer(\"刘德华\", 1001)); LinkedHashSet底层结构 Set实现类之三：TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。 TreeSet底层使用红黑树结构存储数据 新增的方法如下：（了解） Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。 TreeSet 和后面要讲的TreeMap采用红黑树的存储结构 特点：有序，查找速度比List 快 排序-自然排序 自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable接口。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 Comparable 的典型实现： BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较 Character：按字符的 unicode值来进行比较 Boolean：true 对应的包装类实例大于 false 对应的包装类实例 String：按字符串中字符的 unicode 值进行比较 Date、Time：后边的时间、日期比前面的时间、日期大 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。 排序-定制排序 TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。 【面试题】 12345678910111213141516171819202122/** * 注意先 用 hashCode 判断 hash 值是否相等， 然后再用 equals 作比较。 */@Testpublic void test3(){ HashSet set = new HashSet(); Person p1 = new Person(1001,\"AA\"); Person p2 = new Person(1002,\"BB\"); set.add(p1); set.add(p2); System.out.println(set); p1.name = \"CC\"; set.remove(p1); System.out.println(set); set.add(new Person(1001,\"CC\")); System.out.println(set); set.add(new Person(1001,\"AA\")); System.out.println(set);} 练习：在List内去除重复数字值，要求尽量简单 123456789101112131415161718//在List内去除重复数字值，要求尽量简单public static List duplicateList(List list) { HashSet set = new HashSet(); set.addAll(list); return new ArrayList(set);}public static void main(String[] args) { List list = new ArrayList(); list.add(new Integer(1)); list.add(new Integer(2)); list.add(new Integer(2)); list.add(new Integer(4)); list.add(new Integer(4)); List list2 = duplicateList(list); for (Object integer : list2) { System.out.println(integer); }} Map接口 Map接口概述 y=f(x) (x1,y1) (x2,y2),… Map与Collection并列存在。用于保存具有映射关系的数据:key-value Map 中的 key 和 value 都可以是任何引用类型的数据 Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法 常用String类作为Map的“键” key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类 Map 接口：常用方法 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对，存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value Int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法: Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 12345678910111213141516171819202122Map map = new HashMap();//map.put(..,..)省略System.out.println(\"map的所有key:\"); Set keys = map.keySet();// HashSetfor (Object key : keys) { System.out.println(key + \"-&gt;\" + map.get(key));}------------------------------------------------------------System.out.println(\"map的所有的value：\"); Collection values = map.values();Iterator iter = values.iterator();while (iter.hasNext()) { System.out.println(iter.next());}-------------------------------------------------------------System.out.println(\"map所有的映射关系：\");// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口Set mappings = map.entrySet();for (Object mapping : mappings) { Map.Entry entry = (Map.Entry) mapping; System.out.println(\"key是：\" + entry.getKey() + \"，value是：\" + entry.getValue());} Map实现类之一：HashMap HashMap是 Map 接口使用频率最高的实现类。 允许使用null键和null值，与HashSet一样，不保证映射的顺序。 所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode() 所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals() 一个key-value构成一个entry 所有的entry构成的集合是Set:无序的、不可重复的 HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true， hashCode 值也相等。 HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。 HashMap的存储结构 JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。 HashMap源码中的重要常量 DEFAULT_INITIAL_CAPACITY : HashMap 的默认容量，16 MAXIMUM_CAPACITY ： HashMap 的最大支持容量 ，2^30 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树 UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。） table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数。 threshold：扩容的临界值，=容量*填充因子 HashMap的存储结构：JDK 1.8之前 HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时， 系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时， 系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引 用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。 添加的元素过程： 向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。 HashMap的扩容: 当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么HashMap什么时候进行扩容呢？ 当HashMap 中的元素个数超过数组大小( 数组总大小length, 不是数组中个数size) * loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况 下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16 * 0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能。 HashMap的存储结构：JDK 1.8 HashMap 的内部存储结构其实是 数组+链表+树的结合。当实例化一个 HashMap 时，会初始化 initl ialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为 “桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。 那么HashMap什么时候进行扩容和树形化呢？ 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) * loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认 情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中 元素个数超过16 * 0.75=12（这个值就是代码中的threshold值，也叫做临界值） 的时候，就把数组的大小扩展为 2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。 关于映射关系的key是否可以修改？answer：不要修改 映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关 系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。 总结：JDK1.8相较于之前的变化： HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组 当首次调用map.put()时，再创建长度为16的数组 .数组为Node类型，在jdk7中称为Entry类型 形成链表结构时，新添加的key-value对在链表的尾部（七上八下） 当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储 【面试题：】 谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244/** * 一、Map的实现类的结构： * |----Map:双列数据，存储key-value对的数据 ---类似于高中的函数：y = f(x) * |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value * |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 * 原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 * 对于频繁的遍历操作，此类执行效率高于HashMap。 * |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 * 底层使用红黑树 * |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value * |----Properties:常用来处理配置文件。key和value都是String类型 * * * HashMap的底层：数组+链表 （jdk7及之前） * 数组+链表+红黑树 （jdk 8） * * * 面试题： * 1. HashMap的底层实现原理？ * 2. HashMap 和 Hashtable的异同？ * 3. CurrentHashMap 与 Hashtable的异同？（暂时不讲） * * 二、Map结构的理解： * Map中的key:无序的、不可重复的，使用Set存储所有的key ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例） * Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals() * 一个键值对：key-value构成了一个Entry对象。 * Map中的entry:无序的、不可重复的，使用Set存储所有的entry * * 三、HashMap的底层实现原理？以jdk7为例说明： * HashMap map = new HashMap(): * 在实例化以后，底层创建了长度是16的一维数组Entry[] table。 * ...可能已经执行过多次put... * map.put(key1,value1): * 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 * 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1 * 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据 * 的哈希值： * 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2 * 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： * 如果equals()返回false:此时key1-value1添加成功。----情况3 * 如果equals()返回true:使用value1替换value2。 * * 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 * * 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 * * jdk8 相较于jdk7在底层实现方面的不同： * 1. new HashMap():底层没有创建一个长度为16的数组 * 2. jdk 8底层的数组是：Node[],而非Entry[] * 3. 首次调用put()方法时，底层创建长度为16的数组 * 4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 * 4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 * * DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 * DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 * threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 * TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 * MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 * * 四、LinkedHashMap的底层实现原理（了解） * 源码中： * static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } * * * 五、Map中定义的方法： 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 *总结：常用方法： * 添加：put(Object key,Object value) * 删除：remove(Object key) * 修改：put(Object key,Object value) * 查询：get(Object key) * 长度：size() * 遍历：keySet() / values() / entrySet() * * * @author shkstart * @create 2019 上午 11:15 */public class MapTest { /* 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 */ @Test public void test5(){ Map map = new HashMap(); map.put(\"AA\",123); map.put(45,1234); map.put(\"BB\",56); //遍历所有的key集：keySet() Set set = map.keySet(); Iterator iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } System.out.println(); //遍历所有的value集：values() Collection values = map.values(); for(Object obj : values){ System.out.println(obj); } System.out.println(); //遍历所有的key-value //方式一：entrySet() Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext()){ Object obj = iterator1.next(); //entrySet集合中的元素都是entry Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + \"----&gt;\" + entry.getValue()); } System.out.println(); //方式二： Set keySet = map.keySet(); Iterator iterator2 = keySet.iterator(); while(iterator2.hasNext()){ Object key = iterator2.next(); Object value = map.get(key); System.out.println(key + \"=====\" + value); } } /* 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 */ @Test public void test4(){ Map map = new HashMap(); map.put(\"AA\",123); map.put(45,123); map.put(\"BB\",56); // Object get(Object key) System.out.println(map.get(45)); //containsKey(Object key) boolean isExist = map.containsKey(\"BB\"); System.out.println(isExist); isExist = map.containsValue(123); System.out.println(isExist); map.clear(); System.out.println(map.isEmpty()); } /* 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 */ @Test public void test3(){ Map map = new HashMap(); //添加 map.put(\"AA\",123); map.put(45,123); map.put(\"BB\",56); //修改 map.put(\"AA\",87); System.out.println(map); Map map1 = new HashMap(); map1.put(\"CC\",123); map1.put(\"DD\",123); map.putAll(map1); System.out.println(map); //remove(Object key) Object value = map.remove(\"CC\"); System.out.println(value); System.out.println(map); //clear() map.clear();//与map = null操作不同 System.out.println(map.size()); System.out.println(map); } @Test public void test2(){ Map map = new HashMap(); map = new LinkedHashMap(); map.put(123,\"AA\"); map.put(345,\"BB\"); map.put(12,\"CC\"); System.out.println(map); } @Test public void test1(){ Map map = new HashMap();// map = new Hashtable(); map.put(null,123); }} 负载因子值的大小，对HashMap有什么影响？ 负载因子的大小决定了HashMap的数据密度。 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序 与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致 HashMap中的内部类：Node 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next;} LinkedHashMap中的内部类：Entry 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after;s Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} Map实现类之三：TreeMap TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。 TreeMap底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 Map实现类之四：Hashtable Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 Map实现类之五：Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 1234Properties pros = new Properties();pros.load(new FileInputStream(\"jdbc.properties\")); String user = pros.getProperty(\"user\"); System.out.println(user); Collections工具类 Collections 是一个操作 Set、List 和 Map 等集合的工具类 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 排序操作：（均为static方法） reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 Collections常用方法查找、替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值 Collections常用方法：同步控制 Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 补充：Enumeration Enumeration 接口是 Iterator 迭代器的 “古老版本” 12345Enumeration stringEnum = new StringTokenizer(\"a-b*c-d-e-g\", \"-\");while(stringEnum.hasMoreElements()){ Object obj = stringEnum.nextElement(); System.out.println(obj);} 练习 请从键盘随机输入10个整数保存到List中，并按倒序、从大到小的顺序显示出来。 请把学生名与考试分数录入到集合中，并按分数显示前三名成绩学员的名字。 练习 练习 对一个Java源文件中的关键字进行计数。 提示：Java源文件中的每一个单词，需要确定该单词是否是一个关键字。为了高效处理这个问题，将所有的关键字保存在一个HashSet中。用contains() 来测试。 123456File file = new File(\"Test.java\"); Scanner scanner = new Scanner(file); while(scanner.hasNext()){ String word = scanner.next(); System.out.println(word);}","link":"/2020/03/09/java%E9%9B%86%E5%90%88%E7%B1%BB/"},{"title":"枚举类与注解","text":"主要记录枚举类与注解使用的方法，及相关使用的 API。 枚举类的使用主要内容 如何自定义枚举类 如何使用关键字enum定义枚举类 Enum类的主要方法 实现接口的枚举类 常见的使用方式及场景： 类的对象只有有限个，确定的。举例如下： 星期：Monday(星期一)、…、Sunday(星期天) 性别：Man(男)、Woman(女) 季节：Spring(春节). Winter(冬天) 支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银 行卡)、CreditCard(信用卡) 就职状态：Busy、Free、Vocation、Dimission 订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、Return（退货）、Checked（已确认）Fulfilled（已配货） 线程状态：创建、就绪、运行、阻塞、死亡 当需要定义一组常量时，强烈建议使用枚举类 枚举类的实现 JDK1.5之前需要自定义枚举类 JDK 1.5 新增的 enum 关键字用于定义枚举类 若枚举只有一个对象, 则可以作为一种单例模式的实现方式。 枚举类的属性 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 自定义枚举类 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：public static final 对象如果有实例变量，应该声明为private final，并在构造器中初始化 123456789101112class Season{ private final String SEASONNAME;//季节的名称 private final String SEASONDESC;//季节的描述 private Season(String seasonName,String seasonDesc){ this.SEASONNAME = seasonName; this.SEASONDESC = seasonDesc; } public static final Season SPRING = new Season(\"春天\", \"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\", \"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\", \"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\", \"白雪皑皑\");} 使用enum定义枚举类 使用说明 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类 枚举类的构造器只能使用 private 权限修饰符 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰 必须在枚举类的第一行声明枚举类对象 JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。 123456789101112131415161718public enum SeasonEnum { SPRING(\"春天\",\"春风又绿江南岸\"), SUMMER(\"夏天\",\"映日荷花别样红\"), AUTUMN(\"秋天\",\"秋水共长天一色\"), WINTER(\"冬天\",\"窗含西岭千秋雪\"); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) { this.seasonName =seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; }} 测试使用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 一、枚举类的使用 * 1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 * 2.当需要定义一组常量时，强烈建议使用枚举类 * 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 * * 二、如何定义枚举类 * 方式一：jdk5.0之前，自定义枚举类 * 方式二：jdk5.0，可以使用enum关键字定义枚举类 * * 三、Enum类中的常用方法： * values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 * valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 * toString()：返回当前枚举类对象常量的名称 * * 四、使用enum关键字定义的枚举类实现接口的情况 * 情况一：实现接口，在enum类中实现抽象方法 * 情况二：让枚举类的对象分别实现接口中的抽象方法 */public class SeasonTest { public static void main(String[] args) { Season spring = Season.SPRING; System.out.println(spring); }}//自定义枚举类class Season{ //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(\"春天\",\"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\",\"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\",\"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\",\"冰天雪地\"); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求1：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; }} 方法名 详细描述 valueOf 传递枚举类型的Class对象和枚举常量名称給静态方法valueOf,会得到与参数匹配的枚举常量。 toString 得到当前枚举常量的名称。你可以通过重写这个方法来使得到的结果更易读。 equals 在枚举类型中可以直接使用”==”来比较两个枚举常量是否相等。Enum提供的这个equals0方法，也是直接使用“==“实现的。它的存在是为了在Set、List和Map中使用。注意，equals()是不 可变的。 hashCode Enum实现了hashCode0来和equals0保持一致。 它也是不可变的。 getDeclaringClass getDeclaringClass得到枚举 常量所属枚举类型的Class 对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。 name 得到当前枚举常量的名称。建议优先使用toString0。 ordinal 得到当前枚举常量的次序。 compareTo 枚举类型实现了Comparable接口，这样可以比较两个枚举常量的大小(按照声明的顺序排列) clone 枚举类型不能被Clone.为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException 异常的不变Clone0。 Enum类的主要方法： values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 使用enum关键字定义枚举类 * 说明：定义的枚举类默认继承于java.lang.Enum类 * * @author shkstart * @create 2019 上午 10:35 */public class SeasonTest1 { public static void main(String[] args) { Season1 summer = Season1.SUMMER; //toString():返回枚举类对象的名称 System.out.println(summer.toString());// System.out.println(Season1.class.getSuperclass()); System.out.println(\"****************\"); //values():返回所有的枚举类对象构成的数组 Season1[] values = Season1.values(); for(int i = 0;i &lt; values.length;i++){ System.out.println(values[i]); values[i].show(); } System.out.println(\"****************\"); Thread.State[] values1 = Thread.State.values(); for (int i = 0; i &lt; values1.length; i++) { System.out.println(values1[i]); } //valueOf(String objName):返回枚举类中对象名是objName的对象。 Season1 winter = Season1.valueOf(\"WINTER\"); //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException// Season1 winter = Season1.valueOf(\"WINTER1\"); System.out.println(winter); winter.show(); }}interface Info{ void show();}//使用enum关键字枚举类enum Season1 implements Info{ //1.提供当前枚举类的对象，多个对象之间用\",\"隔开，末尾对象\";\"结束 SPRING(\"春天\",\"春暖花开\"){ @Override public void show() { System.out.println(\"春天在哪里？\"); } }, SUMMER(\"夏天\",\"夏日炎炎\"){ @Override public void show() { System.out.println(\"宁夏\"); } }, AUTUMN(\"秋天\",\"秋高气爽\"){ @Override public void show() { System.out.println(\"秋天不回来\"); } }, WINTER(\"冬天\",\"冰天雪地\"){ @Override public void show() { System.out.println(\"大约在冬季\"); } }; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; }// //4.其他诉求1：提供toString()//// @Override// public String toString() {// return \"Season1{\" +// \"seasonName='\" + seasonName + '\\'' +// \", seasonDesc='\" + seasonDesc + '\\'' +// '}';// }// @Override// public void show() {// System.out.println(\"这是一个季节\");// }} 注解（Annotation）主要内容： 注解(Annotation)概述 常见的Annotation示例 自定义Annotation JDK中的元注解 利用反射获取注解信息（在反射部分涉及） JDK 8中注解的新特性 从 JDK 5.0 开始，java 增加了对元数据（MetaData）的支持也就是Annotation(注解) Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于 修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在 Annotation的“name = value” 对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能， 忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 使用 Annotation 时要在其前面增加 @符号，并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。 示例一：生成文档相关的注解 @author 标明开发该类模块的作者，多个作者之间使用,分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写 其中：@param @return 和 @exception 这三个标记都是只用于方法的。 ​ @param的格式要求：@param 形参名形参类型 形参说明 ​ @return 的格式要求：@return 返回值类型返回值说明 ​ @exception的格式要求：@exception 异常类型 异常说明 ​ @param和@exception可以并列多个 12345678910111213141516171819202122package com.annotation.javadoc;/***@author 仙人球*@version 1.0*@see Math.java*/public class JavadocTest { /** *程序的主方法，程序的入口 *@param args String[] 命令行参数 */ public static void main(String[] args) { } /** *求圆面积的方法 *@param radius double 半径值 *@return double 圆的面积 */ public static double getArea(double radius){ return Math.PI * radius * radius; }} 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 12345678910111213141516package com.annotation.javadoc;public class AnnotationTest{ public static void main(String[] args) { @SuppressWarnings(\"unused\") int a = 10; } @Deprecated public void print(){ System.out.println(\"过时的方法\"); } @Override public String toString() { return \"重写的toString方法()\"; }} 示例三：跟踪代码依赖性，实现替代配置文件功能 Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。 12345678910111213141516@WebServlet(&quot;/login&quot;)public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response);}&lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; spring框架中关于“事务”的管理 1234567891011121314151617@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)public void buyBook(String username, String isbn) { //1.查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); //2. 更新库存 bookShopDao.updateBookStock(isbn); //3. 更新用户的余额 bookShopDao.updateUserAccount(username, price);}&lt;!-- 配置事务属性 --&gt;&lt;tx:advice transaction-manager=\"dataSourceTransactionManager\" id=\"txAdvice\"&gt;&lt;tx:attributes&gt;&lt;!-- 配置每个方法使用的事务属性--&gt;&lt;tx:method name=\"buyBook\" propagation=\"REQUIRES_NEW\" isolation=\"READ_COMMITTED\" read-only=\"false\" timeout=\"3\" /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt; 自定义 Annotation 定义新的 Annotation 类型使用 @interface 关键字 自定义注解自动继承了 java.lang.annotation.Annotation 接口 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 可以在定义 Annotation 的成员变量时为其指定初始值，指定成员变量的初始值可以使用 default 关键字 如果 只有一个参数成员，建议使用参数名为 value 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value， 可以省略“value=” 没有成员定义的 Annotation 称为标记；包含成员变量的 Annotation 称为元数据 Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义。 1234567891011121314151617@MyAnnotation(value=\"尚硅谷\")public class MyAnnotationTest { public static void main(String[] args) { Class clazz = MyAnnotationTest.class; Annotation a = clazz.getAnnotation(MyAnnotation.class); MyAnnotation m = (MyAnnotation) a; String info = m.value(); System.out.println(info); }}---------------------------------------------------------@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE) @interface MyAnnotation{ String value() default \"xianrenqiu\";} JDK 中的元注解 JDK 的元 Annotation 用于修饰其他 Annotation 定义 JDK5.0 提供了4个标准的 meta-annotation 类型，分别是： Retention Target Documented Inherited 元数据的理解：String name = “xianrenqiu”; @Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: RetentionPolicy.SOURCE: 在源文件中有效（即源文件保留），编译器直接丢弃这种策略的 RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值 RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。 12345678910public enum RetentionPolicy{ SOURCE, CLASS, RUNTIME}@Retention(RetentionPolicy.SOURCE)@interface MyAnnotation1{ }@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2{ } @Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。@Target 也包含一个名为 value 的成员变量。 取值(ElementType) 取值(ElementType) CONSTRUCTOR 用于描述构造器 PACKAGE 用于描述包 FIELD 用于描述域 PARAMETER 用于描述参数 LOCAL_ VARIABLE 用于描述局部变量 TYPE 用于描述类、接口(包括注解类型)或enum声明 METHOD 用于描述方法 @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为RUNTIME。 @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解 实际应用中，使用较少 练习 编写一个Person类，使用Override注解它的toString方法 自定义一个名为“MyTiger”的注解类型，它只可以使用在方法上，带一个String类型的value属性，然后第1题中的Person类上正确使用。 利用反射获取注解信息 JDK 5.0 在 java.lang.reflect 包下新增了AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素 当一个Annotation 类型被定义为运行时Annotation 后, 该注解才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取 程序可以调用 AnnotatedElement对象的如下方法来访问 Annotation 信息 JDK8 中注解的特新性Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外， 反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。 可重复注解示例： 类型注解： JDK1.8之后,关于元注解@Target的参数类型ElementType枚举值多了两:TYPE_PARAMETER,TYPE_USE。 在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 123456789public class TestTypeDefine&lt;@TypeDefine() U&gt; { private U u; public &lt;@TypeDefine() T&gt; void test(T t){ }}-----------------------------------------------@Target({ElementType.TYPE_PARAMETER})@interface TypeDefine{} 123456789101112131415161718192021@MyAnnotationpublic class AnnotationTest&lt;U&gt; { @MyAnnotation private String name; public static void main(String[] args) { AnnotationTest&lt;@MyAnnotation String&gt; t = null; int a = (@MyAnnotation int) 2L; @MyAnnotation int b = 10; } public static &lt;@MyAnnotation T&gt; void method(T t) { } public static void test(@MyAnnotation String arg) throws @MyAnnotation Exception { }}@Target(ElementType.TYPE_USE) @interface MyAnnotation {} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/** * 注解的使用 * * 1. 理解Annotation: * ① jdk 5.0 新增的功能 * * ② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, * 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 * * ③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android * 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 * 代码和XML配置等。 * * 2. Annocation的使用示例 * 示例一：生成文档相关的注解 * 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 * 示例三：跟踪代码依赖性，实现替代配置文件功能 * * 3. 如何自定义注解：参照@SuppressWarnings定义 * ① 注解声明为：@interface * ② 内部定义成员，通常使用value表示 * ③ 可以指定成员的默认值，使用default定义 * ④ 如果自定义注解没有成员，表明是一个标识作用。 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。 自定义注解通过都会指明两个元注解：Retention、Target 4. jdk 提供的4种元注解 元注解：对现有的注解进行解释说明的注解 Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为）\\RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取。 Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 *******出现的频率较低******* Documented:表示所修饰的注解在被javadoc解析时，保留下来。 Inherited:被它修饰的 Annotation 将具有继承性。 5.通过反射获取注解信息 ---到反射内容时系统讲解 6. jdk 8 中注解的新特性：可重复注解、类型注解 6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 6.2 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 */public class AnnotationTest { public static void main(String[] args) { Person p = new Student(); p.walk(); Date date = new Date(2020, 10, 11); System.out.println(date); @SuppressWarnings(\"unused\") int num = 10;// System.out.println(num); @SuppressWarnings({ \"unused\", \"rawtypes\" }) ArrayList list = new ArrayList(); } @Test public void testGetAnnotation(){ Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); for(int i = 0;i &lt; annotations.length;i++){ System.out.println(annotations[i]); } }}//jdk 8之前的写法：//@MyAnnotations({@MyAnnotation(value=\"hi\"),@MyAnnotation(value=\"hi\")})@MyAnnotation(value=\"hi\")@MyAnnotation(value=\"abc\")class Person{ private String name; private int age; public Person() { } @MyAnnotation public Person(String name, int age) { this.name = name; this.age = age; } @MyAnnotation public void walk(){ System.out.println(\"人走路\"); } public void eat(){ System.out.println(\"人吃饭\"); }}interface Info{ void show();}class Student extends Person implements Info{ @Override public void walk() { System.out.println(\"学生走路\"); } public void show() { }}class Generic&lt;@MyAnnotation T&gt;{ public void show() throws @MyAnnotation RuntimeException{ ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;(); int num = (@MyAnnotation int) 10L; }}----------------------------------------------------------------------@Inherited@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE})public @interface MyAnnotation { String value() default \"hello\";}----------------------------------------------------------------------@Inherited@Retention(RetentionPolicy.RUNTIME)@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})public @interface MyAnnotations { MyAnnotation[] value();}","link":"/2020/03/06/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"},{"title":"Sketch v63.1中文破解版","text":"Sketch for Mac是一款运行在macOS平台上的绘图工具。Sketch for Mac 破解版具有免费调色板，面板，菜单，窗口等功能，与此同时Sketch Mac中文破解版提供了功能强大的矢量绘图和文字工具，Sketch Mac版以简约的设计带给用户最好的体验! 下载：密码ak0w 安装包损坏，打不开怎么处理？打不开“XXX”,因为它来自身份不明的开发者怎么处理？点击查看：解决办法 macOS 10.15 Catalina 提示 xxx.app已损坏，无法打开 *\\***Sketch v63.1中文破解版**/激活版******** *\\***Sketch V61.2中文破解/激活版******** *\\*Sketch V61.1中文破解/激活版**** \\Sketch V61.0中文破解/激活版** \\Sketch V60.0**中文破解/激活版*\\*** \\Sketch V59.1中文破解/激活版** \\Sketch V59.0中文破解/激活版** Sketch V58.0中文破解/激活版 Sketch V57.1中文破解/激活版 …… Sketch Mac破解说明 1.下载完成安装包后，双击打开，将左侧【Sketch】拖拽至右侧应用程序，默认安装。若遇到意外或者无法打开的情况，请参照上面链接方式把mac允许任何来源打开。","link":"/2020/02/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"使用Vagrant创建Centos虚拟机","text":"Vagrant是一款由HashiCorp公司提供的，用于快速构建虚拟机环境的软件。本节我们将使用Vagrant结合Oracle VM VirtualBox快速地在win10环境下构建CentOS7虚拟机。在此之前需要先安装好 Vagrant 和 VirtualBox。 构建CentOS7虚拟机 在 https://app.vagrantup.com/boxes/search 下搜索centos： 然后在win10任意盘符下创建vagrant_vm目录（注意目录最好不要有中文和空格），然后在该目录下使用cmd执行vagrant init centos/7命令： 然后执行 vagrant up启动（这时候最好也打开VirtualBox）： 构建完毕，这时候VirtualBox的列表里会出现一台正在运行的虚拟机： 这就是我们刚刚通过Vagrant构建的CentOS7虚拟机了。 如果当你执行vagrant up命令后，虚拟机文件下载非常的慢的话，可以使用下面这种方式来构建： 在上面的日志中可以找到这么一行： 1Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1902.01/providers/virtualbox.box 后面这个URL就是下载地址了，将它黏贴到迅雷等下载工具下载即可。然后将下载好后的xxx.box文件复制到vagrant_vm目录下，并且重命名为centos7.box（删除centos7.box之外的文件和目录，只保留centos7.box一个文件）。 接着运行vagrant box add -name 'centos/7' centos7.box命令： 添加成功后执行vagrant init centos/7初始化： 初始化成功后执行vagrant up启动： 构建成功，效果和一开始在线下载构建是一样的。 连接虚拟机我们先用 vagrant status命令查看一下虚拟机的状态： 可以看到虚拟机是运行中的状态，我们可以执行vagrant halt来关闭虚拟机： 启动虚拟机的命令为vagrant up，我们也可以使用vagrant suspend命令来暂停运行中的虚拟机，以保持它的运行状态： 暂停后可以使用vagrant resume命令来恢复虚拟机： 连接正在运行中的虚拟机的命令为vagrant ssh： 重启虚拟机使用的命令为vagrant reload。如果你不想要这个虚拟机的话可以使用vagrant distroy命令进行销毁。 目录共享 Vagrant的根目录（就是我们一开始创建的vagrant_vm）和虚拟机里的/vagrant目录是共享的。我们在vagrant_vm目录下新建一个hello.txt文件，内容为hello： 然后连接虚拟机，查看虚拟机/vagrant目录下有什么内容（必须重启虚拟机才能看到共享文件）: 说明同步成功。 我们也可以自定义共享路劲，编辑vagrant_vm文件夹下的Vagrantfile文件： 在这行下面添加如下配置： 1config.vm.synced_folder \"./data\", \"/vagrant_data\", create:true, owner: \"root\", group: \"root\" 这个配置的意思是将当前路径下的data文件夹和虚拟机的/share目录共享，拥有者为root，群组为root，如果路径不存在则创建。 修改了Vagrantfile文件需要执行 vagrant reload重启。重启后我们在data文件夹下新建一个hello.txt文件，然后连接虚拟机看看是否共享成功： 共享成功！ 在这途中，遇到了如下问题: 123456789101112Vagrant was unable to mount VirtualBox shared folders. This is usuallybecause the filesystem \"vboxsf\" is not available. This filesystem ismade available via the VirtualBox Guest Additions and kernel module.Please verify that these guest additions are properly installed in theguest. This is not a bug in Vagrant and is usually caused by a faultyVagrant box. For context, the command attempted was:mount -t vboxsf -o uid=0,gid=0 vagrant_data /vagrant_dataThe error output from the command was:mount: unknown filesystem type 'vboxsf' 安装下面这个插件可解决问题： 1vagrant plugin install vagrant-vbguest 网络配置虚拟机私有网络在Vagrantfile里打开下面这行配置： 修改成和自己IP在同一网段 然后使用命令vagrant reload重启虚拟机，重启后我们使用ping命令看是否可以在windows上访问到这个ip： 访问成功，连接虚拟机，使用ip addr查看其IP： 正是我们刚刚配置的那个IP。 虚拟机公有网络 编辑Vagrantfile，将我们刚刚开启的私有网络配置注释，然后开启下面这行配置： 虚拟机IP要和本机IP在同一网段 然后重启虚拟机，重启过程中会根据当前网络环境选择： 如果是连接的无线网选择第四个选项，重启好后连接虚拟机，查看其IP： 新开一个cmd窗口，ping 这个地址看是否能通: 公有网络和私有网络的区别是：（公有网络）在同一个局域网、wifi网络下的其他设备也是可以访问这个IP地址的。 比如我们在windows浏览器里输入http://192.168.1.200/： 如果centos 中没有安装 httpd 服务器 运行一下命令进行安装启动 yum -y install httpd systemctl start httpd.service 然后让手机连接和电脑相同的wifi网络，并且访问http://192.168.1.200/： 结果说明公有网络配置成功。 多主机配置使用Vagrant可以轻松地创建多台虚拟主机。下面我们开始通过Vagrant来创建两台新的虚拟主机“prod”和“dev”。 在vagrant_vm目录下新建一个目录，名称为multi，然后通过现有的box来初始化一个Vagrantfile配置： 接着编辑multi目录下的Vagrantfile文件，新增下面两项配置： 运行vagrant status： 可以看到多了两台状态为not created的虚拟机，名称分别为“prod”和“dev”。 我们可以使用vagrant up来启动两台主机，也可以通过vagrant up prod来单独启动“prod”这台虚拟主机。 启动后（第一次启动耗时可能比较长），使用vagrant status来查看它们的状态： 通过vagrant ssh 主机名就可以连接上它们了。 网络配置 接下来开始配置网络，让它们之间可以通讯。 我们按照上面介绍网络配置的方式来为这两台虚拟主机配置私有网络： 值得注意的是，在配置私有网络的时候，IP网段不能和Windows主机相同。 配置好后重启这两台虚拟机，然后分别连接这两台虚拟机，看是否能够ping通： 配置成功。 自定义主机名编辑Vagrantfile，添加如下配置： 重启后，连接虚拟机，可以看到hostname已经修改为我们设置的名称了： 多主机的共享目录默认的这两台虚拟主机的/vagrant和当前目录multi/是共享的。我们也可以分别为它们设置不同的共享目录。 编辑Vagrantfile，添加如下配置： 然后重启这两台虚拟主机就好了。 如果没有创建文件需要配置自动创建，拥有者为root，群组为root： create:true, owner: &quot;root&quot;, group: &quot;root&quot; 更多Vagrant的配置可以查看官方文档：https://www.vagrantup.com/docs/","link":"/2020/04/08/%E4%BD%BF%E7%94%A8Vagrant%E5%88%9B%E5%BB%BACentos%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"Docker安装步骤","text":"Docker简介 是什么？ Docker是基于Go语言实现的云开源项目。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。 能用来做什么？ Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 比较了 Docker 和传统虚拟化方式的不同之处： 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 开发/运维（DevOps）一次性构建、随处运行 更快速的应用交付和部署 更便捷的升级和维护 更简单的系统运维 更高效的计算资源利用 在哪里下载？ 官网：http://www.docker.com 仓库：https://hub.docker.com Docker 安装步骤CentOS6.8安装Docker yum install -y epel-release Docker使用EPEL发布，RHEL系的OS首先要确保已经持有EPEL仓库，否则先检查OS的版本，然后安装相应的EPEL包 yum install -y docker-io 安装后查看配置文件内容：cat /etc/sysconfig/docker 启动Docker后台服务：service docker start 查看Docker版本：docker version CentOS7安装Docker官网示例： https://docs.docker.com/engine/install/centos/ 确定你是CentOS7及以上版本： 1cat /etc/redhat-release 确认CentOS7能连上外网，yum安装gcc相关: 12sudo yum -y install gccsudo yum -y install gcc-c++ 卸载旧版本的Docker: 1sudo yum -y remove docker docker-common docker-selinux docker-engine 官网卸载命令： 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装需要的软件包: 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 设置stable镜像仓库: 1234#推荐使用sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #官网仓库sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 更新yum软件包索引： 1yum makecache fast 安装DOCKER CE: 1yum -y install docker-ce 启动Docker： 1systemctl start docker 测试： 12docker versiondocker run hello-world 配置镜像加速： 123456mkdir -p /etc/dockervim /etc/docker/daemon.json#网易云{\"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] }#阿里云{\"registry-mirrors\": [\"https://｛自已的编码｝.mirror.aliyuncs.com\"]}systemctl daemon-reloadsystemctl restart docke 卸载： 123systemctl stop docker yum -y remove docker-cerm -rf /var/lib/docke hello World 测试配置阿里云镜像加速：https://cr.console.aliyun.com/cn-hangzhou 获取加速器地址： 配置本机Docker运行镜像加速器：我使用的是阿里云的本人自己账号的镜像地址(需要自己注册有一个属于你自己的)： https://xxxx.mirror.aliyuncs.com 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ \"registry-mirrors\": [\"https://xxxdx.mirror.aliyuncs.com\"]}EOFsudo systemctl daemon-reload #加载配置文件sudo systemctl restart docker #重启DOcker Linux 系统下配置完加速器需要检查是否生效，用 docker info 命令进行查看： 网易云加速，基本同上述阿里云。 启动Docker后台容器(测试运行 hello-world): docker run hello-world 图中绿色的框圈中的内容意思是，由于本地没有 hello-world 这个镜像，所以会下载一个 hello-world 的镜像，并在容器内运行。 docker run 的启动流程： Docker 底层原理，Docker 是怎么工作的？ Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。 为什么Docker比较比VM快？ docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。","link":"/2020/04/09/Docker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"},{"title":"ES6基础学习","text":"一、简介ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 二、 特性1. let新增加的声明变量的关键字，与var声明变量有以下不同 声明的变量有严格局部作用域 123456 { var a = 102; let b = 2; } console.log(a); // 1 console.log(b); // ReferenceError: b is not defined var 可以声明多次，let 只能声明一次 123456 var m = 1 var m = 2 let n = 3let n = 4 console.log(m) // 2 console.log(n) // Identifier 'n' has already been declared var 会变量提升，let 不存在变量提升 1234 console.log(x); // undefined var x = 10; console.log(y); //ReferenceError: y is not defined let y = 20; 2. const 一但声明必须初始化，否则会报错 声明之后不允许改变 12 const a = 1; a = 3; //Uncaught TypeError: Assignment to constant variable. 3. 解构表达式 数组解构 可以直接将数组的元素依次赋值给其他变量 12345678910 let arr = [1,2,3];//不需要像下面这样挨个赋值 // let a = arr[0]; // let b = arr[1]; // let c = arr[2]; let [a,b,c] = arr; console.log(a,b,c) //1 2 3 对象解构 可以直接将对象的属性赋给其他变量 1234567891011121314151617const person = { name: \"jack\", age: 21, language: ['java', 'js', 'css'] } // 不需要像下面这样挨个赋值 // const name = person.name; // const age = person.age; // const language = person.language; //对象解构 //将name的值赋给abc const { name:abc, age, language } = person; console.log(abc, age, language) 4. 字符串 字符串扩展 字符串可以使用startsWith()、endsWith、includes等函数 12345let str = \"hello.vue\"; console.log(str.startsWith(\"hello\"));//true console.log(str.endsWith(\".vue\"));//true console.log(str.includes(\"e\"));//true console.log(str.includes(\"hello\"));//true 模板字符串 模板字符串相当于加强版的字符串，用反引号 `,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。 123456789101112131415161718192021普通字符串:let string = `Hello'\\n'world`;console.log(string); // \"Hello'// 'world\" 多行字符串:let string1 = `Hey,can you stop angry now?`;console.log(string1);// Hey,// can you stop angry now? 变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式:function fun() { return \"这是一个函数\"} let info = `我是${abc}，今年${age + 10}了, 我想说： ${fun()}`;console.log(info);//我是jack，今年31了, 我想说： 这是一个函数 5. 函数优化 参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法；现在可以直接给参数写上默认值，没传就会自动使用默认值 123456789101112131415//在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： function add(a, b) { // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b; } // 传一个参数 console.log(add(10)); //现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值 function add2(a, b = 1) { return a + b; } console.log(add2(20)); 不定参数 12345function fun(...values) { console.log(values.length)}fun(1, 2) //2fun(1, 2, 3, 4) //4 箭头函数 12345678910111213 var print = obj =&gt; console.log(obj); print(\"hello\"); //箭头函数+解构 const person = { name: \"jack\", age: 21, language: ['java', 'js', 'css'] } var hello2 = ({name}) =&gt; console.log(\"hello,\" +name); hello2(person); 6. 对象优化 对象的新方法 1234567891011121314151617 const person = { name: \"jack\", age: 21, language: ['java', 'js', 'css'] }//key/values/entries方法 console.log(Object.keys(person));//[\"name\", \"age\", \"language\"] console.log(Object.values(person));//[\"jack\", 21, Array(3)] console.log(Object.entries(person));//[Array(2), Array(2), Array(2)] const target = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; //assign将源对象的所有可枚举属性复制到目标对象中。 Object.assign(target, source1, source2); console.log(target); //{a:1,b:2,c:3} 声明对象简写 12345678const age = 23const name = \"张三\"//原本声明对象const person1 = { age: age, name: name } //简写后(若属性名与常量名相同时才可以使用)const person2 = { age, name }console.log(person2); 对象函数属性简写 可以省略对象函数属性的声明，用箭头函数或者函数属性名代替函数声明 123456789101112let person3 = { name: \"jack\", // 以前： eat: function (food) { console.log(this.name + \"在吃\" + food); }, //箭头函数this不能使用，对象.属性 eat2: food =&gt; console.log(person3.name + \"在吃\" + food), eat3(food) { console.log(this.name + \"在吃\" + food); }} 对象扩展运算符 可以用...object代表某个对象所有的属性进行操作 1234567891011// 1、拷贝对象（深拷贝）let p1 = { name: \"Amy\", age: 15 }let someone = { ...p1 }console.log(someone) //{name: \"Amy\", age: 15} // 2、合并对象let age1 = { age: 15 }let name1 = { name: \"Amy\" }let p2 = {name:\"zhangsan\"}p2 = { ...age1, ...name1 } console.log(p2) //{age: 15, name: \"Amy\"} 7. map 和 reduce函数 map函数 接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 123 let arr = ['1', '20', '-5', '3']; arr = arr.map(item=&gt; item*2); console.log(arr); //[2, 40, -10, 6] reduce函数 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素， arr.reduce(callback,[initialValue]) callback函数可用四个参数 1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue）） 2、currentValue （数组中当前被处理的元素） 3、index （当前元素在数组中的索引） 4、array （调用 reduce 的数组）12345678910111213141516171819202122 let arr = [2, 40, -10, 6]; let result = arr.reduce((a,b,index)=&gt;{ console.log(\"上一次处理后：\"+a); console.log(\"当前正在处理：\"+b); console.log(index); return a + b; },100); console.log(result) //控制台打印结果 上一次处理后：100 当前正在处理：2 0 上一次处理后：102 当前正在处理：40 1 上一次处理后：142 当前正在处理：-102 上一次处理后：132 当前正在处理：6 3 8. promise对象当发送异步请求时，如果我们下一个异步请求需要用到上一个异步请求的结果，这个时候就会发生连续嵌套，非常混乱，而通过promise对象和then函数可以解决这一问题 原始的嵌套处理： 12345678910111213141516171819$.ajax({ url:\"mock/user.json\", success:function(data){ console.log(\"查到数据\"+data.id) $.ajax({ url:`mock/user_corse_${data.id}.json`, success:function(data){ console.log(data) }, error:function(error){ console.log(\"出错。。\"+error) } }); }, error:function(error){ console.log(\"出现异常\"+error) }} ) 通过promise对象和then函数处理: 1234567891011121314151617181920let p=new Promise((resolve,reject)=&gt;{ $.ajax({ url:\"mock/user.json\", success:function(data){ console.log(\"查到数据\"+data); resolve(data); }, error:function(err){ reject(err); } })});p.then(obj=&gt;{ $.ajax({ url:`mock/user_corse_${obj.id}.json`, success:function(data){ console.log(data); } })}) 9. 模块化模块导入导出各种类型的变量，如字符串，数值，函数，类。 导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 不仅能导出声明还能导出引用（例如函数）。 export 命令可以出现在模块的任何位置，但必需处于模块顶层。 import 命令会提升到整个模块的头部，首先执行。 1234567891011121314151617/*-----export [test.js]-----*/let myName = \"Tom\";let myAge = 20;let myfn = function(){ return \"My name is\" + myName + \"! I'm '\" + myAge + \"years old.\"}let myClass = class myClass { static a = \"yeah!\";}export { myName, myAge, myfn, myClass } /*-----import [xxx.js]-----*/import { myName, myAge, myfn, myClass } from \"./test.js\";console.log(myfn());// My name is Tom! I'm 20 years old.console.log(myAge);// 20console.log(myName);// Tomconsole.log(myClass.a );// yeah!","link":"/2020/06/09/ES6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"title":"frp搭建内网穿","text":"​ 内网穿透技术众多，比如花生壳内网穿透、Ngrok、Frp 都是现在主流的内网穿透技术。但我个人认为 Frp 是目前最好用配置最简单的。 花生壳配置简单方便，比较傻瓜化。但要收费。虽然也有免费版，但由于免费版的流量限制，基本上没有什么实际作用。 Ngrok发布时间相对较长，对象较为成熟的一种内网穿透技术。但由于功能的强大。配置较为繁琐。 Frp配置简单。并且适用于各大主流平台设备。 准备工作 需要一台有公网ip的云服务器（腾讯云、阿里云等） 在腾讯云或者是阿里云购买一个域名 由于 frp官网 说明文档比较详细，我这里就不在详细介绍了。 配置 frp 服务器登录自己买的云服务器，在 https://github.com/fatedier/frp/releases 页面下载自己服务器对应版本 的 frp 1wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gz 使用 tar 指令解压 tar.gz 文件 1tar -zxvf frp_0.32.1_linux_amd64.tar.gz 进入 frp 目录 1cd frp_0.32.1_linux_amd64 删除不必要的客户端文件 1rm -f frpc frpc_full.ini frpc.ini 版本不同可能稍有差异。 frpc 为客户端文件 frpc 为客户端文件 配置服务器端文件 1vim frps.ini frps.ini 为服务器配置文件 编辑配置文件 1234567891011121314[common]bind_port = 7000vhost_http_port = 8080dashboard_port = 7500dashboard_user = 用户名dashboard_pwd = 密码max_pool_count = 5authentication_timeout = 900subdomain_host = www.wbqcactus.xyz[ssh]listen_port = 6000auth_token = 和客服端 token 对应 简单解释： [common]必填的 bind_port Frp 服务端口（可自定义）vhost_http_port http 访问端口（可自定义）dashboard_port dashboard 界面端口dashboard_user 登录 dashboard 用户名dashboard_pwd 登录 dashboard 密码max_pool_count 最大连接池数量authentication_timeout 超时验证时间subdomain_host 自定义二级域名 [ssh] listen_port ssh 访问端口auth_token 用户身份认证 详细配置 点击官方 保存上面配置的文件，启动 frp 服务器 1./frps -c ./frps.ini 用root用户启动 客户端配置客户端就是需要映射到外网的设备，比如说：windows、Mac、linux等。 下载 frp ,删除服务端文件（和服务端配置基本相似） 1234wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gztar -zxvf frp_0.32.1_linux_amd64.tar.gzcd frp_0.32.1_linux_amd64rm -f frps frps_full.ini frps.ini 编辑 frpc.ini 文件（客户端配置文件） 1vim frpc.ini 编辑配置文件如下 123456789101112131415161718192021[common]server_addr = ipserver_port = 7000auth_token = 和服务器端对应pool_count = 1[ssh]type = tcplocal_ip = 局域网iplocal_port = 22remote_port = 6000[nas]type = httplocal_port = 5000subdomain = nas[web]type = httplocal_port = 80subdomain = web 简单解释： [common]必填的 server_addr 服务器端公网server_port frp 服务端口，和服务器端 bind_port 一致auth_token 和前面服务器端 [ssh] auth_token 一致pool_count 连接池数量 [ssh] type 服务类型（tcp、http、https、udp）local_ip NAS 本地局域网内网 iplocal_port NAS 开启 ssh 服务端口号，默认 22remote_port 服务器端 ssh 端口，和服务器端 [ssh] listen_port 配置一致 [web]web 服务，没有可以不用设置 type = http 类型为 httplocal_port = 80 NAS web 服务端口subdomain = web 二级域名 web.lekee.cc使用自定义二级域名的时候，域名 www.wbqcactus.xyz 要解析到服务器 IP 详细配置 点击官方 保存，运行。 1./frpc -c ./frpc.ini 此时在服务端会看到”start proxy sucess”字样，即连接成功。 测试运行1ssh -p 6000 user@服务器ip 后台运行后台运行服务的方法有很多，这里只说一种可以在服务器端（Linux）和客户端都可以用的 nohup指令 1nohup ./frps -c ./frps.ini &amp; 客户端1nohup ./frpc -c ./frpc.ini &amp;","link":"/2020/04/12/frp%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF/"},{"title":"Java反射机制","text":"","link":"/2020/05/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"Java网络编程","text":"​ Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。 网络基础 计算机网络： 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。 网络编程的目的： 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 网络编程中有两个主要的问题： 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 网络通信要素概述 IP和端口号 网络通信协议 如何实现网络中的主机互相通信 通信双方地址 IP 端口号 一定规则（即：网络通信协议。有两套参考模型） OSI 参考模型：模型过去理想化，未能在因特网上进行广泛推广 TCP/IP 参考模型（或TCP/IP）协议：事实上的国际标准 网络通信协议 参考模型 TCP/IP参考模型 TCP/IP参考模型各层对应协议 应用层 应用层 HTTP、FTP、Telnet、DNS… 表示层 应用层 HTTP、FTP、Telnet、DNS… 会话层 应用层 HTTP、FTP、Telnet、DNS… 传输层 传输层 TCP、UDP、… 网络层 网络层 IP、ICMP、ARP… 数据链路层 物理+数据链路层 Link 通信要素1：IP和端口号 IP 地址：InetAddress 唯一的标识 Internet 上的计算机（通信实体） 本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost IP地址分类方式1：IPV4 和 IPV6 IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1 IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984 特点：不宜记忆 端口号标识正在计算机上运行的进程（程序） 不同的进程有不同的端口号 被规定为一个 16 位的整数 0~65535。 端口分类： 公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23 注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。 动态/私有端口：49152~65535。 端口号与IP地址的组合得出一个网络套接字：Socket。 InetAddress 类 Internet上的主机有两种方式表示地址： 域名(hostName)：www.xxx.com IP 地址(hostAddress)：202.108.35.210 InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。 InetAddress 类对象含有一个 Internet 主机地址的域名和 IP 地址：www.xxx.com 和 202.108.35.210。 域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 域名解析 InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例 public static InetAddress getLocalHost() public static InetAddress getByName(String host) InetAddress提供了如下几个常用的方法 public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）。 public String getHostName()：获取此 IP 地址的主机名 public boolean isReachable(int timeout)：测试是否可以达到该地址 【InetAdress 代码示例】 1234567891011InetAddress address_1 = InetAddress.getByName(\"www.xxx.com\");System.out.println(address_1);// 获取 InetAddress 对象包含域名System.out.println(address_1.getHostname());// 获取InetAddress 对象所含的IP地址System.out.println(address_1.getHostAddress());// 获取本机的域名和 IP 地址InetAddress address_2 = InetAddress.getLocalHost();System.out.println(address_2); 通信要素2：网络协议 网络通信协议 计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。 问题：网络协议太复杂 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？ 通信协议分层的思想 在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。 TCP/IP协议簇 传输层协议中有两个非常重要的协议： 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol) TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。 IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层 TCP 和 UDP TCP协议： 使用TCP协议前，须先建立TCP连接，形成传输数据通道 传输前，采用“三次握手”方式，点对点通信，是可靠的 TCP协议进行通信的两个应用进程：客户端、服务端 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 UDP协议： 将数据、源、目的封装成数据包，不需要建立连接 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 可以广播发送 发送数据结束时无需释放资源，开销小，速度快 Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 通信的两端都要有Socket，是两台机器间通信的端点。 网络通信其实就是Socket间的通信。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类 流套接字（stream socket）：使用TCP提供可依赖的字节流服务 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务 Socket类的常用构造器： public Socket(InetAddress address,int port)创建一个流套接字并将其连接到指定IP 地址的指定端口号。 public Socket(String host,int port)创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket类的常用方法： public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息 public OutputStream getOutputStream()返回此套接字的输出流。可以用于发送网络消息 public InetAddress getInetAddress()此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。 public InetAddress getLocalAddress()获取套接字绑定的本地地址。 即本端的IP地址 public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。 public int getLocalPort()返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。 public void close()关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream。 public void shutdownInput()如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。 public void shutdownOutput()禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流， 则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。 TCP网络编程基于Socket的TCP编程 Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模型如图所示： 基于TCP的Socket通信： 客户端Socket的工作过程包含以下四个基本的步骤： 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 打开连接到Socket 的输入/出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输。 按照一定的协议对Socket 进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。 关闭 Socket：断开客户端到服务器的连接，释放线路。 客户端创建Socket对象 客户端程序可以使用Socket 类创建对象，创建的同时会自动向服务器方发起链接。Socket 的构造器是： Socket(String host,int port)throws UnknownHostException,IOException：向服务器(域名是host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。 Socket(InetAddress address,int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接。 客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求 1234Socket s = new Socket(“192.168.1.216”,8888);OutputStream out = s.getOutputStream();out.write(\" hello\".getBytes());s.close(); 基于Socket的TCP编程 服务器程序的工作过程包含以下四个基本的步骤： 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept()：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。 调用 该Socket类对象的 getOutputStream() 和 getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收。 关闭ServerSocket和Socket对象：客户端访问结束，关闭通信套接字。 服务器建立 ServerSocket 对象 ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的ServerSocket对象。 所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象。 12345678ServerSocket ss = new ServerSocket(8888); Socket s = ss.accept ();InputStream in = s.getInputStream(); byte[] buf = new byte[1024];int num = in.read(buf);String str = new String(buf,0,num); System.out.println(s.getInetAddress().toString()+”:”+str); s.close();ss.close(); 【例题】 客户端发送内容给服务端，服务端将内容打印到控制台上。 客户端发送文件给服务端，服务端将文件保存在本地。 从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。 【练习】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 实现TCP的网络编程 * 例子1：客户端发送信息给服务端，服务端将数据显示在控制台上 * */public class TCPTest1 { //客户端 @Test public void client() { Socket socket = null; OutputStream os = null; try { //1.创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(\"192.168.14.100\"); socket = new Socket(inet,8899); //2.获取一个输出流，用于输出数据 os = socket.getOutputStream(); //3.写出数据的操作 os.write(\"你好，我是客户端mm\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { //4.资源的关闭 if(os != null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } //服务端 @Test public void server() { ServerSocket ss = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.创建服务器端的ServerSocket，指明自己的端口号 ss = new ServerSocket(8899); //2.调用accept()表示接收来自于客户端的socket socket = ss.accept(); //3.获取输入流 is = socket.getInputStream(); //不建议这样写，可能会有乱码// byte[] buffer = new byte[1024];// int len;// while((len = is.read(buffer)) != -1){// String str = new String(buffer,0,len);// System.out.print(str);// } //4.读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while((len = is.read(buffer)) != -1){ baos.write(buffer,0,len); } System.out.println(baos.toString()); System.out.println(\"收到了来自于：\" + socket.getInetAddress().getHostAddress() + \"的数据\"); } catch (IOException e) { e.printStackTrace(); } finally { if(baos != null){ //5.关闭资源 try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if(is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(ss != null){ try { ss.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * * 实现TCP的网络编程 * 例题2：客户端发送文件给服务端，服务端将文件保存在本地。 * */public class TCPTest2 { /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void client() throws IOException { //1. Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(\"beauty.jpg\")); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1){ os.write(buffer,0,len); } //5. fis.close(); os.close(); socket.close(); } /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void server() throws IOException { //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(\"beauty1.jpg\")); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } //6. fos.close(); is.close(); socket.close(); ss.close(); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 实现TCP的网络编程 * 例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。 * 并关闭相应的连接。 */public class TCPTest3 { /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void client() throws IOException { //1. Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(\"beauty.jpg\")); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1){ os.write(buffer,0,len); } //关闭数据的输出 socket.shutdownOutput(); //5.接收来自于服务器端的数据，并显示到控制台上 InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] bufferr = new byte[20]; int len1; while((len1 = is.read(buffer)) != -1){ baos.write(buffer,0,len1); } System.out.println(baos.toString()); //6. fis.close(); os.close(); socket.close(); baos.close(); } /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void server() throws IOException { //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(\"beauty2.jpg\")); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(\"图片传输完成\"); //6.服务器端给予客户端反馈 OutputStream os = socket.getOutputStream(); os.write(\"你好，美女，照片我已收到，非常漂亮！\".getBytes()); //7. fos.close(); is.close(); socket.close(); ss.close(); os.close(); }} UDP网络编程UDP网络通信 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。 UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。 DatagramSocket 类的常用方法 public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。 public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 public void close()关闭此数据报套接字。 public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 public InetAddress getLocalAddress()获取套接字绑定的本地地址。 public int getLocalPort()返回此套接字绑定的本地主机上的端口号。 public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回null。 public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。 DatagramPacket类的常用方法 public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为length 的数据包。 length 参数必须小于等于 buf.length。 public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于buf.length。 public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。 public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。 public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续length 长度。 public int getLength()返回将要发送或接收到的数据的长度。 UDP网络通信 流 程： DatagramSocket与DatagramPacket 建立发送端，接收端 建立数据包 调用Socket的发送、接收方法 关闭Socket 发送端与接收端是两个独立的运行程序 【发送端】 123456789101112DatagramSocket ds = null;try { ds = new DatagramSocket(); byte[] by = \"hello,atguigu.com\".getBytes(); DatagramPacket dp = new DatagramPacket(by, 0, by.length, InetAddress.getByName(\"127.0.0.1\"), 10000); ds.send(dp);} catch (Exception e) { e.printStackTrace();} finally { if (ds != null) ds.close();} 【接收端】 在接收端，要指定监听的端口。 12345678910111213DatagramSocket ds = null; try { ds = new DatagramSocket(10000); byte[] by = new byte[1024]; DatagramPacket dp = new DatagramPacket(by, by.length); ds.receive(dp); String str = new String(dp.getData(), 0, dp.getLength()); System.out.println(str + \"--\" + dp.getAddress());} catch (Exception e) { e.printStackTrace();} finally { if (ds != null) ds.close();} 【练习】 123456789101112131415161718192021222324252627282930313233343536373839/** * UDPd协议的网络编程 */public class UDPTest { //发送端 @Test public void sender() throws IOException { DatagramSocket socket = new DatagramSocket(); String str = \"我是UDP方式发送的导弹\"; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090); socket.send(packet); socket.close(); } //接收端 @Test public void receiver() throws IOException { DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close(); }} URL编程URL类 URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 URL的基本结构由5部分组成： &lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表 例 如 : http://192.168.1.100:8080/helloworld/index.jsp#a?username=cactus&amp;password=123 #片段名：即锚点，例如看小说，直接定位到章节 参数列表格式：参数名=参数值&amp;参数名=参数值…. URL类构造器 为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象： public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。 例如：URL url = new URL (“http://www. xxx.com/“); public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。 例如：URL downloadUrl = new URL(url, “download.html”) public URL(String protocol, String host, String file); 例如：new URL(“http”, “www.xxx.com&quot;, “download. html”); public URL(String protocol, String host, int port, String file); 例如: URL gamelan = new URL(“http”, “www.xxx.com&quot;, 80, “download.html”); URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。 URL类常用方法 一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性： public String getProtocol( ) 获取该URL的协议名 public String getHost( ) 获取该URL的主机名 public String getPort( ) 获取该URL的端口号 public String getPath( ) 获取该URL的文件路径 public String getFile( ) 获取该URL的文件名 public String getQuery() 获取该URL的查询名 12345URL url = new URL(\"http://localhost:8080/examples/myTest.txt\"); System.out.println(\"getProtocol() :\"+url.getProtocol()); System.out.println(\"getHost() :\"+url.getHost()); System.out.println(\"getPort() :\"+url.getPort()); System.out.println(\"getPath() :\"+url.getPath()); System.out.println(\"getFile() :\"+url.getFile());System.out.println(\"getQuery() :\"+url.getQuery()); URLConnection类针对HTTP协议的URLConnection类 URL的方法 openStream()：能从网络上读取数据 若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用URLConnection 。 URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException。 URL netchinaren = new URL (“http://www.xxx.com/index.html&quot;); URLConnectonn u = netchinaren.openConnection( ); 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。 public Object getContent( ) throws IOException public int getContentLength( ) public String getContentType( ) public long getDate( ) public long getLastModified( ) public InputStream getInputStream( )throws IOException public OutputSteram getOutputStream( )throws IOException URI、URL和URN的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。而URL是uniform resource locator，统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。 客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。 Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。 类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。 【练习】 12345678910111213141516171819202122232425262728293031323334353637383940/** * URL网络编程 * 1.URL:统一资源定位符，对应着互联网的某一资源地址 * 2.格式： * http://localhost:8080/examples/beauty.jpg?username=Tom * 协议 主机名 端口号 资源地址 参数列表 * */public class URLTest { public static void main(String[] args) { try { URL url = new URL(\"http://localhost:8080/examples/beauty.jpg?username=Tom\");// public String getProtocol( ) 获取该URL的协议名 System.out.println(url.getProtocol());// public String getHost( ) 获取该URL的主机名 System.out.println(url.getHost());// public String getPort( ) 获取该URL的端口号 System.out.println(url.getPort());// public String getPath( ) 获取该URL的文件路径 System.out.println(url.getPath());// public String getFile( ) 获取该URL的文件名 System.out.println(url.getFile());// public String getQuery( ) 获取该URL的查询名 System.out.println(url.getQuery()); } catch (MalformedURLException e) { e.printStackTrace(); } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class URLTest1 { public static void main(String[] args) { HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try { URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg&quot;); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(&quot;cvb\\\\beauty3.jpg&quot;); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(&quot;下载完成&quot;); } catch (IOException e) { e.printStackTrace(); } finally { //关闭资源 if(is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(urlConnection != null){ urlConnection.disconnect(); } } }}","link":"/2020/05/02/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"title":"JavaEE面试题","text":"3. Java SE3.1 你是怎样理解面向对象的面向对象是利用编程语言对现实事物进行抽象。面向对象具有以下四大特征： （1）继承：继承是从已有类得到继承信息创建新类的过程 （2）封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。 （3）多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。 （4）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。 3.2 int和Integer有什么区别，以及以下程序结果（1）Integer是int的包装类，int则是java的一种基本数据类型 （2）Integer变量必须实例化后才能使用，而int变量不需要 （3）Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 （4）Integer的默认值是null，int的默认值是0 12345678910111213141516171819202122 package com.cactus.interview.chapter03; /** */ public class Test01 { public static void main(String[] args) { Integer a = 127; Integer b = 127; Integer c = 128; Integer d = 128;/** * @author : atguigu.com * @since 2019/7/28 Integer内部维护了一个IntegerCache缓冲区，范围是从-128到+127范围的 Integer类型数组。只要Integer赋值在-128到+127范围内，统一都是用次缓 冲区中的数据。如果不在此范围，则新创建对象。 */ System.out.println(a == b); //true System.out.println(c == d); //false } } 3.3 ==和Equals区别（1） == 如果比较的是基本数据类型，那么比较的是变量的值 如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存） （2）equals 如果没重写equals方法比较的是两个对象的地址值 如果重写了equals方法后我们往往比较的是对象中的属性的内容 equals()方法最初在Object类中定义的，默认的实现就是使用== 3.4 谈谈你对反射的理解（1）反射机制: 所谓的反射机制就是java语言在运行时拥有一项自观的能力。通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。 Java的反射机制的实现要借助于4个类：Class，Constructor，Field，Method; 其中Class代表的是类对 象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组 成部分。 （2）Java反射的作用： 在Java运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。 （3）Java 反射机制提供功能 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法 3.5 ArrarList和LinkedList区别（1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （2）对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。 （3）对于插入和删除操作add和remove，LinkedList比较占优势，因为ArrayList每插入或删除一条数据，都要移动插入点或删除点及之后的所有数据。 3.6 HashMap底层源码，数据结构HashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现，以数组+链表的结构为例。 JDK1.8之前put方法： JDK1.8之后put方法： 3.7 HashMap和Hashtable区别（1）线程安全性不同 HashMap是线程不安全的，Hashtable是线程安全的，其中的方法是Synchronized的，在多线程并发的情况下，可以直接使用Hashtable，但是使用HashMap时必须自己增加同步处理。 （2）是否提供contains方法 HashMap只有containsValue和containsKey方法；Hashtable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。 （3）key和value是否允许null值 Hashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 （4）数组初始化和扩容机制 Hashtable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。 Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 3.8 TreeSet和HashSet区别HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。 TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。 3.9 StringBuffer和StringBuilder区别（1）StringBuffer 与 StringBuilder 中的方法和功能完全是等价的， （2）只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 （3）在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低 3.10 Final、Finally、Finalizefinal：修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract（abstract修饰的类通常都需要子类来继承）在使用上可以理解为互斥的。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。 3.11 什么是 java 序列化，如何实现 java 序列化？序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 序 列 化 的 实 现 ： 将 需 要 被 序 列 化 的 类 实 现 Serializable 接 口 ， 该 接 口 没 有 需 要 实 现 的 方 法 ， implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用 ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。 3.12 Object中有哪些方法（1）protected Object clone()—&gt;创建并返回此对象的一个副本。（2）boolean equals(Object obj)—&gt;指示某个其他对象是否与此对象“相等”。（3）protected void finalize()—&gt;当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。（4）Class&lt;? extends Object&gt; getClass()—&gt;返回一个对象的运行时类。（5）int hashCode()—&gt;返回该对象的哈希码值。（6）void notify()—&gt;唤醒在此对象监视器上等待的单个线程。（7）void notifyAll()—&gt;唤醒在此对象监视器上等待的所有线程。（8）String toString()—&gt;返回该对象的字符串表示。（9）void wait()—&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 void wait(long timeout)—&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll()方法，或者超过指定的时间量。 void wait(long timeout, int nanos)—&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 3.13 线程有几种状态，产生的条件是什么 3.14 产生死锁的基本条件产生死锁的原因：（1） 因为系统资源不足。（2） 进程运行推进的顺序不合适。（3） 资源分配不当等。 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。**产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。**死锁的解除与预防： 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 3.15 什么是线程池，如何使用？线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。 在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。 ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4); ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4); ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); 然后调用他们的 execute 方法即可。 优点： 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 3.16 Java自带有哪几种线程池？一、ThreadPoolExecutorThreadPoolExecutor提供了四个构造方法： 我们以最后一个构造方法（参数最多的那个），对其参数进行解释： 12345678910111213141516171819public ThreadPoolExecutor(int corePoolSize, // 1 int maximumPoolSize, // 2 long keepAliveTime, // 3 TimeUnit unit, // 4 BlockingQueue &lt; Runnable &gt; workQueue, // 5 ThreadFactory threadFactory, // 6 RejectedExecutionHandler handler) { // 7 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;} 二、预定义线程池JDK给我们预定义的几种线程池 1、FixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} ePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势； keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程； workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势； FixedThreadPool的任务执行是无序的； 适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。 2、CachedThreadPool12345public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制； keepAliveTime = 60s，线程空闲60s后自动结束。 workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue； 适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。 3、SingleThreadExecutor12345public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService( new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } 这里多了一层FinalizableDelegatedExecutorService包装，以下代码解释一下其作用： 12345678910 public static void main(String[] args) { ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1); ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService; System.out.println(threadPoolExecutor.getMaximumPoolSize()); threadPoolExecutor.setCorePoolSize(8); ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();// 运行时异常 java.lang.ClassCastException//ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService; } 对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。 4、ScheduledThreadPool123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。 public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } 三、自定义线程池以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ThreadTest { public static void main(String[] args) throws InterruptedException, IOException { int corePoolSize = 2; int maximumPoolSize = 4; long keepAliveTime = 10; TimeUnit unit = TimeUnit.SECONDS; BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(2); ThreadFactory threadFactory = new NameTreadFactory(); RejectedExecutionHandler handler = new MyIgnorePolicy(); ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); executor.prestartAllCoreThreads(); // 预启动所有核心线程 for (int i = 1; i &lt;= 10; i++) { MyTask task = new MyTask(String.valueOf(i)); executor.execute(task); } System.in.read(); //阻塞主线程 } static class NameTreadFactory implements ThreadFactory { private final AtomicInteger mThreadNum = new AtomicInteger(1); @Override public Thread newThread(Runnable r) { Thread t = new Thread(r, \"my-thread-\" + mThreadNum.getAndIncrement()); System.out.println(t.getName() + \" has been created\"); return t; } } public static class MyIgnorePolicy implements RejectedExecutionHandler { public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { doLog(r, e); } private void doLog(Runnable r, ThreadPoolExecutor e) { // 可做日志记录等 System.err.println( r.toString() + \" rejected\");// System.out.println(\"completedTaskCount: \" + e.getCompletedTaskCount()); } } static class MyTask implements Runnable { private String name; public MyTask(String name) { this.name = name; } @Override public void run() { try { System.out.println(this.toString() + \" is running!\"); Thread.sleep(3000); //让任务执行慢点 } catch (InterruptedException e) { e.printStackTrace(); } } public String getName() { return name; } @Override public String toString() { return \"MyTask [name=\" + name + \"]\"; }}} 3.17 Java 中有几种类型的流 3.18 字节流如何转为字符流字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。 字符输出流转字节输出流通过OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。 3.19 请写出你最常见的5个Exception（1）java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。 （2）java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。 （3）java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符。 （4）java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。 （5）java.lang.IllegalArgumentException 方法传递参数错误。 （6）java.lang.ClassCastException 数据类型转换异常。 4. JVM4.1 JVM内存分哪几个区，每个区的作用是什么? java虚拟机主要分为以下几个区: （1）方法区： a. JDK7中称为永久代，JDK8及之后称为元空间，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载 b. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。 c. 该区域是被线程共享的。 d. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。 （2）虚拟机栈: a. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 b. 虚拟机栈是线程私有的，它的生命周期与线程相同。 c. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 d. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 e. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。 （3）本地方法栈：本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。 （4）堆： java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。 （5）程序计数器： 内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。 4.2 heap 和stack 有什么区别（1）申请方式 stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间 heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟 （2）申请后系统的响应 stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 （3）申请大小的限制 stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。 （4）申请效率的比较 stack：由系统自动分配，速度较快。但程序员是无法控制的。 heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 （5）heap和stack中的存储内容 stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 4.3 java类加载过程?Java类加载需要经历一下几个过程： （1）加载 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情： a. 通过一个类的全限定名获取该类的二进制流。 b. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 c. 在内存中生成该类的Class对象，作为该类的数据访问入口。 （2）链接 2.1）验证 验证的目的是为了确保Class文件的字节流中的信息不会危害到虚拟机.在该阶段主要完成以下四钟验证: a. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. b. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否继承了不被继承的类等。 c. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。 d. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。 2.2）准备 准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 2.3）解析 该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。 （3）初始化 初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。 4.4 什么是类加载器，类加载器有哪些?实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有以下四种类加载器: （1）启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。 （2）扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 （3）系统类加载器（system class loader）也叫应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 （4）用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。 4.5 java中垃圾收集的方法有哪些?1）引用计数法算法 应用于：微软的COM/ActionScrip3/Python等 a) 如果对象没有被引用，就会被回收，缺点：需要维护一个引用计算器 2）可达性分析算法 以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 3)复制算法 年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying) a) 效率高，缺点：需要内存容量大，比较耗内存 b) 使用在占空间比较小、刷新次数多的新生区 4）标记-清除算法 老年代一般是由标记清除或者是标记清除与标记整理的混合实现 a) 效率比较低，会产生碎片。 5）标记-压缩算法 老年代一般是由标记清除或者是标记清除与标记整理的混合实现 a) 效率低速度慢，需要移动对象，但不会产生碎片。 6）标记-清除-压缩算法 标记清除-标记压缩的集合，多次GC后才Compact a) 使用于占空间大刷新次数少的养老区，是4)和5)的集合体 4.6 如何判断一个对象是否存活?(或者GC对象的判定方法)判断一个对象是否存活有两种方法: （1）引用计数法 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。 （2）可达性算法(引用链法) 该算法的基本思路就是通过以GC Roots对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为引用链（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。 在java中可以作为GC Roots的对象有以下几种：虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象。 4.7 简述java内存分配与回收策略以及Minor GC和Major GC（full GC）内存分配： （1）栈区：栈分为java虚拟机栈和本地方法栈 （2）堆区：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。 （3）方法区：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯上也叫它永久代（permanment generation） （4）程序计数器：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。 回收策略以及Minor GC和Major GC： （1）对象优先在堆的Eden区分配。 （2）大对象直接进入老年代。 （3）长期存活的对象将直接进入老年代。 当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。 5. 设计模式5.1 你所知道的设计模式有哪些Java 中一般认为有 23 种设计模式，我们不需要所有的都会，但是其中常用的几种设计模式应该去掌握。下面列出了所有的设计模式。需要掌握的设计模式我单独列出来了，当然能掌握的越多越好。 总体来说设计模式分为三大类： 创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 5.2 单例设计模式见【第2章 手写代码 2.5】 5.3 工厂设计模式（Factory）5.3.1 什么是工厂设计模式？工厂设计模式，顾名思义，就是用来生产对象的，在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则，如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦 5.3.2 简单工厂（Simple Factory）定义： 一个工厂方法，依据传入的参数，生成对应的产品对象；角色：1、抽象产品2、具体产品3、具体工厂4、产品使用者使用说明： 先将产品类抽象出来，比如，苹果和梨都属于水果，抽象出来一个水果类Fruit，苹果和梨就是具体的产品类，然后创建一个水果工厂，分别用来创建苹果和梨。代码如下： 水果接口： 123public interface Fruit { void whatIm(); } 苹果类： 123456public class Apple implements Fruit { @Override public void whatIm() { System.out.println(\"苹果\"); } } 梨类： 123456public class Pear implements Fruit { @Override public void whatIm() { System.out.println(\"梨\"); } } 水果工厂： 12345678910111213public class FruitFactory { public Fruit createFruit(String type) { if (type.equals(\"apple\")) {//生产苹果 return new Apple(); } else if (type.equals(\"pear\")) {//生产梨 return new Pear(); } return null; } } 使用工厂生产产品： 12345678910public class FruitApp { public static void main(String[] args) { FruitFactory mFactory = new FruitFactory(); Apple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果 Pear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨 apple.whatIm(); pear.whatIm(); } } 以上的这种方式，每当添加一种水果，就必然要修改工厂类，违反了开闭原则； 所以简单工厂只适合于产品对象较少，且产品固定的需求，对于产品变化无常的需求来说显然不合适。 5.3.3 工厂方法（Factory Method）定义： 将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；角色：1、抽象产品2、具体产品3、抽象工厂4、具体工厂使用说明： 和上例中一样，产品类抽象出来，这次我们把工厂类也抽象出来，生产什么样的产品由子类来决定。代码如下：水果接口、苹果类和梨类： 代码和上例一样 抽象工厂接口： 123public interface FruitFactory { Fruit createFruit();//生产水果 } 苹果工厂： 123456public class AppleFactory implements FruitFactory { @Override public Apple createFruit() { return new Apple(); } } 梨工厂： 123456public class PearFactory implements FruitFactory { @Override public Pear createFruit() { return new Pear(); } } 使用工厂生产产品： 1234567891011public class FruitApp { public static void main(String[] args){ AppleFactory appleFactory = new AppleFactory(); PearFactory pearFactory = new PearFactory(); Apple apple = appleFactory.createFruit();//获得苹果 Pear pear = pearFactory.createFruit();//获得梨 apple.whatIm(); pear.whatIm(); } } 以上这种方式，虽然解耦了，也遵循了开闭原则，但是如果我需要的产品很多的话，需要创建非常多的工厂，所以这种方式的缺点也很明显。 5.3.4 抽象工厂（Abstract Factory）定义： 为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。角色： 1、抽象产品2、具体产品3、抽象工厂4、具体工厂 使用说明： 抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；举个例子，假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了。用抽象工厂来实现： cpu接口和实现类： 123456789101112131415public interface Cpu { void run(); class Cpu650 implements Cpu { @Override public void run() { System.out.println(\"650 也厉害\"); } } class Cpu825 implements Cpu { @Override public void run() { System.out.println(\"825 更强劲\"); } } } 屏幕接口和实现类： 123456789101112131415161718public interface Screen { void size(); class Screen5 implements Screen { @Override public void size() { System.out.println(\"\" + \"5寸\"); } } class Screen6 implements Screen { @Override public void size() { System.out.println(\"6寸\"); } } } 抽象工厂接口： 1234public interface PhoneFactory { Cpu getCpu();//使用的cpu Screen getScreen();//使用的屏幕 } 小米手机工厂： 12345678910public class XiaoMiFactory implements PhoneFactory { @Override public Cpu.Cpu825 getCpu() { return new Cpu.Cpu825();//高性能处理器 } @Override public Screen.Screen6 getScreen() { return new Screen.Screen6();//6寸大屏 } } 红米手机工厂： 1234567891011public class HongMiFactory implements PhoneFactory { @Override public Cpu.Cpu650 getCpu() { return new Cpu.Cpu650();//高效处理器 } @Override public Screen.Screen5 getScreen() { return new Screen.Screen5();//小屏手机 } } 使用工厂生产产品： 1234567891011121314public class PhoneApp { public static void main(String[] args){ HongMiFactory hongMiFactory = new HongMiFactory(); XiaoMiFactory xiaoMiFactory = new XiaoMiFactory(); Cpu.Cpu650 cpu650 = hongMiFactory.getCpu(); Cpu.Cpu825 cpu825 = xiaoMiFactory.getCpu(); cpu650.run(); cpu825.run(); Screen.Screen5 screen5 = hongMiFactory.getScreen(); Screen.Screen6 screen6 = xiaoMiFactory.getScreen(); screen5.size(); screen6.size(); } } 以上例子可以看出，抽象工厂可以解决一系列的产品生产的需求，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展。 5.3.5三种工厂方式总结1、对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式； 2、抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产。 5.4 代理模式（Proxy）5.4.1什么是代理模式？代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下： 5.4.2 为什么要用代理模式？中介隔离作用： 在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能： 代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要修改已经封装好的委托类。 5.4.3 有哪几种代理模式？我们有多种不同的方式来实现代理。 如果按照代理创建的时期来进行分类的话，可以分为两种：静态代理、动态代理。 ● 静态代理是由程序员创建或特定工具自动生成源代码，再对其编译。在程序员运行之前，代理类.class文件就已经被创建了。 ● 动态代理是在程序运行时通过反射机制动态创建的。 5.4.4 静态代理（Static Proxy）第一步：创建服务类接口 123public interface BuyHouse { void buyHouse(); } 第二步：实现服务接口 123456public class BuyHouseImpl implements BuyHouse { @Override public void buyHouse() { System.out.println(\"我要买房\"); } } 第三步：创建代理类 123456789101112131415 public class BuyHouseProxy implements BuyHouse { private BuyHouse buyHouse; public BuyHouseProxy(final BuyHouse buyHouse) { this.buyHouse = buyHouse; } @Override public void buyHouse() { System.out.println(\"买房前准备\"); buyHouse.buyHouse(); System.out.println(\"买房后装修\"); } } 第四步：编写测试类 12345678public class HouseApp { public static void main(String[] args) { BuyHouse buyHouse = new BuyHouseImpl(); BuyHouseProxy buyHouseProxy = new BuyHouseProxy(buyHouse); buyHouseProxy.buyHouse(); } } Proxy是所有动态生成的代理的共同的父类，这个类有一个静态方法Proxy.newProxyInstance()，接收三个参数： ● ClassLoader loader：指定当前目标对象使用的类加载器,获取加载器的方法是固定的 ● Class&lt;?&gt;[] interfaces：指定目标对象实现的接口的类型,使用泛型方式确认类型 ● InvocationHandler：指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法 JDK动态代理总结： 优点：相对于静态代理，动态代理大大减少了开发任务，同时减少了对业务接口的依赖，降低了耦合度。 缺点：Proxy是所有动态生成的代理的共同的父类，因此服务类必须是接口的形式，不能是普通类的形式，因为Java无法实现多继承。 5.4.6 CGLib动态代理（CGLib Proxy）JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。 Cglib子类代理实现方法： （1）引入cglib的jar文件，asm的jar文件 （2）代理的类不能为final （3）目标业务对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法 第一步：创建服务类 123456public class BuyHouse2 { public void buyHouse() { System.out.println(\"我要买房\"); } } 第二步：创建CGLIB代理类 1234567891011121314151617181920212223242526272829303132public class CglibProxy implements MethodInterceptor { private Object target; public CglibProxy(Object target) { this.target = target; } /** * 给目标对象创建一个代理对象 * @return 代理对象 */ public Object getProxyInstance() { //1.工具类 Enhancer enhancer = new Enhancer(); //2.设置父类 enhancer.setSuperclass(target.getClass()); //3.设置回调函数 enhancer.setCallback(this); //4.创建子类(代理对象) return enhancer.create(); } public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\"买房前准备\"); //执行目标对象的方法 Object result = method.invoke(target, args); System.out.println(\"买房后装修\"); return result; } } 第三步：创建测试类 12345678910public class HouseApp { public static void main(String[] args) { BuyHouse2 target = new BuyHouse2(); CglibProxy cglibProxy = new CglibProxy(target); BuyHouse2 buyHouseCglibProxy = (BuyHouse2) cglibProxy.getProxyInstance(); buyHouseCglibProxy.buyHouse(); } } CGLib代理总结： CGLib创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。 5.4.7 简述动态代理的原理， 常用的动态代理的实现方式动态代理的原理: 使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。 代理对象决定是否以及何时将方法调 用转到原始对象上 动态代理的方式 基于接口实现动态代理： JDK动态代理 基于继承实现动态代理： Cglib、Javassist动态代理 6. MySql6.1 jdbc 操作数据库流程第一步：Class.forName()加载数据库连接驱动； 第二步：DriverManager.getConnection()获取数据连接对象; 第三步：根据SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ; 第四步：执行SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX(); 第五步：关闭结果集、关闭会话、关闭连接。 6.2 关系数据库中连接池的机制是什么？前提：为数据库连接建立一个缓冲池。 （1）从连接池获取或创建可用连接 （2）使用完毕之后，把连接返回给连接池 （3）在系统关闭前，断开所有连接并释放连接占用的系统资源 （4）能够处理无效连接，限制连接池中的连接总数不低于或者不超过某个限定值。 其中有几个概念需要大家理解： 最小连接数是连接池一直保持的数据连接。如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费掉。 最大连接数是连接池能申请的最大连接数。如果数据连接请求超过此数，后面的数据连接请求将被加入到等待队列中，这会影响之后的数据库操作。 如果最小连接数与最大连接数相差太大，那么，最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。 上面的解释，可以这样理解：数据库池连接数量一直保持一个不少于最小连接数的数量，当数量不够时，数据库会创建一些连接，直到一个最大连接数，之后连接数据库就会等待。 6.3 SQL 的select 语句完整的执行顺序SQL Select 语句完整的执行顺序： （1）from 子句组装来自不同数据源的数据； （2）where 子句基于指定的条件对记录行进行筛选； （3）group by 子句将数据划分为多个分组； （4）使用聚集函数进行计算； （5）使用 having 子句筛选分组； （6）计算所有的表达式； （7）select 的字段； （8）使用order by 对结果集进行排序。 6.4 MySQL的事务事务的基本要素（ACID）： ● 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。● 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。● 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。● 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 事务的并发问题： ● 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 ● 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致 ● 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结： 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 MySQL事务隔离级别： 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 6.5 行锁，表锁 MyISAM InnoDB 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作 6.6 索引数据结构：B+Tree 一般来说能够达到range就可以算是优化了 口诀： 全值匹配我最爱，最左前缀要遵守； 带头大哥不能死，中间兄弟不能断； 索引列上少计算，范围之后全失效； LIKE百分写最右，覆盖索引不写*； 不等空值还有OR，索引影响要注意； VAR引号不可丢，SQL优化有诀窍。 6.7 b-tree和b+tree的区别（1）非叶子节点只存储键值信息 （2）所有叶子节点之间都有一个链指针 （3）数据记录都存放在叶子节点中 6.8 简述在MySQL数据库中MyISAM和InnoDB的区别InnoDB 存储引擎 主要面向OLTP(Online Transaction Processing，在线事务处理)方面的应用 特点： 行锁设计、支持外键； MyISAM 存储引擎 主要面向OLAP(Online Analytical Processing,在线分析处理)方面的应用。 特点： 不支持事务，支持表锁和全文索引。操作速度快。 6.9 你们公司有哪些数据库设计规范（一）基础规范 1、表存储引擎必须使用InnoDB，表字符集默认使用utf8，必要时候使用utf8mb4 解读： （1）通用，无乱码风险，汉字3字节，英文1字节 （2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它 2、禁止使用存储过程，视图，触发器，Event 解读： （1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层 （2）调试，排错，迁移都比较困难，扩展性较差 3、禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径 4、禁止在线上环境做数据库压力测试 5、测试，开发，线上数据库环境必须隔离 （二）命名规范 1、库名，表名，列名必须用小写，采用下划线分隔 解读：abc，Abc，ABC都是给自己埋坑 2、库名，表名，列名必须见名知义，长度不要超过32字符 解读：tmp，wushan谁知道这些库是干嘛的 3、库备份必须以bak为前缀，以日期为后缀 4、从库必须以-s为后缀 5、备库必须以-ss为后缀 （三）表设计规范 1、单实例表个数必须控制在2000个以内 2、单表分表个数必须控制在1024个以内 3、表必须有主键，推荐使用UNSIGNED整数为主键 潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住 4、禁止使用外键，如果要保证完整性，应由应用程式实现 解读：外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈 5、建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据 （四）列设计规范 1、根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节 2、根据业务区分使用char/varchar 解读： （1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高 （2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间 3、根据业务区分使用datetime/timestamp 解读：前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime 4、必须把字段定义为NOT NULL并设默认值 解读： （1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化 （2）NULL需要更多的存储空间 （3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑 5、使用INT UNSIGNED存储IPv4，不要用char(15) 6、使用varchar(20)存储手机号，不要使用整数 解读： （1）牵扯到国家代号，可能出现+/-/()等字符，例如+86 （2）手机号不会用来做数学运算 （3）varchar可以模糊查询，例如like ‘138%’ 7、使用TINYINT来代替ENUM 解读：ENUM增加新值要进行DDL操作 （五）索引规范 1、唯一索引使用uniq_[字段名]来命名 2、非唯一索引使用idx_[字段名]来命名 3、单张表索引数量建议控制在5个以内 解读： （1）互联网高并发业务，太多索引会影响写性能 （2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引 （3）异常复杂的查询需求，可以选择ES等更为适合的方式存储 4、组合索引字段数不建议超过5个 解读：如果5个字段还不能极大缩小row范围，八成是设计有问题 5、不建议在频繁更新的字段上建立索引 6、非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引 解读：踩过因为JOIN字段类型不一致，而导致全表扫描的坑么？ 7、理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c) （六）SQL 规范 1、禁止使用select *，只获取必要字段 解读： （1）select *会增加cpu/io/内存/带宽的消耗 （2）指定字段能有效利用索引覆盖 （3）指定字段查询，在表结构变更时，能保证对应用程序无影响 2、insert必须指定字段，禁止使用insert into T values() 解读：指定字段插入，在表结构变更时，能保证对应用程序无影响 3、隐式类型转换会使索引失效，导致全表扫描 4、禁止在where条件列使用函数或者表达式 解读：导致不能命中索引，全表扫描 5、禁止负向查询以及%开头的模糊查询 解读：导致不能命中索引，全表扫描 6、禁止大表JOIN和子查询 7、同一个字段上的OR必须改写为IN，IN的值必须少于50个 8、应用程序必须捕获SQL异常 解读：方便定位线上问题 说明：本规范适用于并发量大，数据量大的典型互联网业务，可直接参考。 6.10 MySQL性能优化（1）尽量选择较小的列 （2）将where中用的比较频繁的字段建立索引 （3）select子句中避免使用‘*’ （4）避免在索引列上使用计算、not in 和&lt;&gt;等操作 （5）当只需要一行数据的时候使用limit 1 （6）保证单表数据不超过200W，适时分割表。针对查询较慢的语句，可以使用explain 来分析该语句具体的执行情况。 （7）避免改变索引列的类型。 （8）选择最有效的表名顺序，from字句中写在最后的表是基础表，将被最先处理，在from子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。 （9）避免在索引列上面进行计算。 （10）尽量缩小子查询的结果 6.11 SQL 语句优化案例例1：where 子句中可以对字段进行 null 值判断吗？ 可以，比如 select id from t where num is null 这样的 sql 也是可以的。但是最好不要给数据库留NULL，尽可能的使用 NOT NULL 填充数据库。不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL 也包含在内），都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段，null 不占用空间。可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：select id from t where num= 0。 例2：如何优化?下面的语句？ select * from admin left join log on admin.admin_id = log.admin_id where log.admin_id&gt;10 优化为：select * from (select * from admin where admin_id&gt;10) T1 lef join log on T1.admin_id = log.admin_id。 使用 JOIN 时候，应该用小的结果驱动大的结果（left join 左边表结果尽量小如果有条件应该放到左边先处理， right join 同理反向），同时尽量把牵涉到多表联合的查询拆分多个 query（多个连表查询效率低，容易导致锁表和阻塞）。 例3：limit 的基数比较大时使用 between 例如：select * from admin order by admin_id limit 100000,10 优化为：select * from admin where admin_id between 100000 and 100010 order by admin_id。 例4：尽量避免在列上做运算，这样导致索引失效 例如：select * from admin where year(admin_time)&gt;2014 优化为： select * from admin where admin_time&gt; ‘2014-01-01′ 6.12 常见面试sql例1： 用一条SQL语句查询出每门课都大于80分的学生姓名 name kecheng fenshu张三 语文 81张三 数学 75李四 语文 76李四 数学 90王五 语文 81王五 数学 100王五 英语 90 答1： select distinct name from table where name not in (select distinct name from table where fenshu&lt;=80) 答2： select name from table group by name having min(fenshu)&gt;80 例2： 学生表 如下:自动编号 学号 姓名 课程编号 课程名称 分数1 2005001 张三 0001 数学 692 2005002 李四 0001 数学 893 2005001 张三 0001 数学 69删除除了自动编号不同，其他都相同的学生冗余信息答： delete tablename where 自动编号 not in (select min(自动编号) from tablename group by学号, 姓名, 课程编号, 课程名称, 分数) 例3： 一个叫team的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合. 答： select a.name, b.name from team a, team b where a.name &lt; b.name 例4： 怎么把这样一个表year month amount1991 1 1.11991 2 1.21991 3 1.31991 4 1.41992 1 2.11992 2 2.21992 3 2.31992 4 2.4查成这样一个结果year m1 m2 m3 m41991 1.1 1.2 1.3 1.41992 2.1 2.2 2.3 2.4答： select year, (select amount from aaa m where month=1 and m.year=aaa.year) as m1, (select amount from aaa m where month=2 and m.year=aaa.year) as m2, (select amount from aaa m where month=3 and m.year=aaa.year) as m3, (select amount from aaa m where month=4 and m.year=aaa.year) as m4 from aaa group by year例5： 说明：复制表(只复制结构,源表名：a新表名：b) 答：SQL: select *** into b from a where 1&lt;&gt;1 **(where1=1，拷贝表结构和数据内容) ORACLE: create table b As Select ***** from a where 1=2 [&lt;&gt;（不等于）(SQL Server Compact) 比较两个表达式。 当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为 TRUE。 否则，结果为 FALSE。] 例6： 原表：courseid coursename score1 java 702 oracle 903 xml 404 jsp 305 servlet 80 为了便于阅读,查询此表后的结果显式如下(及格分数为60):courseid coursename score mark1 java 70 pass2 oracle 90 pass3 xml 40 fail4 jsp 30 fail5 servlet 80 pass写出此查询语句 答： select courseid, coursename ,score ,if (score&gt;=60, “pass”,”fail”) as mark from course 例7： 表名：购物信息 购物人 商品名称 数量 A 甲 2 B 乙 4 C 丙 1 A 丁 2 B 丙 5 给出所有购入商品为两种或两种以上的购物人记录 答： select *** from 购物信息 where 购物人 **in (select 购物人 from 购物信息 group by 购物人 having count(***)** &gt;= 2); 例8： info 表 date result 2005-05-09 win 2005-05-09 lose 2005-05-09 lose 2005-05-09 lose 2005-05-10 win 2005-05-10 lose 2005-05-10 lose 如果要生成下列结果, 该如何写sql语句? date win lose 2005-05-09 2 2 2005-05-10 1 2 答1： select date, sum(case when result = “win” then 1 else 0 end) as “win”, sum(case when result = “lose” then 1 else 0 end) as “lose” from info group by date; 答2： select a.date, a.result as win, b.result as lose from (select date, count(result) as result from info where result = “win” group by date) as a join (select date, count(result) as result from info where result = “lose” group by date) as b on a.date = b.date; 7. Java Web7.1 http 的长连接和短连接HTTP 协议有 HTTP/1.0 版本和 HTTP/1.1 版本。HTTP1.1 默认保持长连接（HTTP persistent connection，也翻译为持久连接），数据传输完成了保持 TCP 连接不断开（不发 RST 包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。 在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。从 HTTP/1.1 起，默认使用的是长连接，用以保持连接特性。 7.2 http 常见的状态码有哪些？200 OK //客户端请求成功 301 Moved Permanently（永久移除)，请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置 302 found 重定向 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的 URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 7.3 GET 和POST 的区别？（1）GET 请求的数据会附在URL 之后（就是把数据放置在 HTTP 协议头中），以?分割URL 和传输数据，参数之间以&amp;相连，如：login.action?name=zhagnsan&amp;password=123456。POST 把提交的数据则放置在是 HTTP 包的包体中。 （2）GET 方式提交的数据最多只能是 1024 字节，理论上POST 没有限制，可传较大量的数据。其实这样说是错误的，不准确的：“GET 方式提交的数据最多只能是 1024 字节”，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对URL 长度的限制是2083 字节(2K+35)。对于其他浏览器，如Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。 （3）POST 的安全性要比GET 的安全性高。注意：这里所说的安全性和上面 GET 提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的 Security 的含义，比如：通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻击。 Get 是向服务器发索取数据的一种请求，而 Post 是向服务器提交数据的一种请求，在 FORM（表单）中，Method 默认为”GET”，实质上，GET 和 POST 只是发送机制不同，并不是一个取一个发！ 7.4 Cookie 和Session 的区别Cookie 是 web 服务器发送给浏览器的一块信息，浏览器会在本地一个文件中给每个 web 服务器存储 cookie。以后浏览器再给特定的 web 服务器发送请求时，同时会发送所有为该服务器存储的 cookie。 Session 是存储在 web 服务器端的一块信息。session 对象存储特定用户会话所需的属性及配置信息。当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。 Cookie 和session 的不同点： （1）无论客户端做怎样的设置，session 都能够正常工作。当客户端禁用 cookie 时将无法使用 cookie。 （2）在存储的数据量方面：session 能够存储任意的java 对象，cookie 只能存储 String 类型的对象。 7.5 在单点登录中，如果 cookie 被禁用了怎么办？单点登录的原理是后端生成一个 session ID，然后设置到 cookie，后面的所有请求浏览器都会带上 cookie， 然后服务端从 cookie 里获取 session ID，再查询到用户信息。所以，保持登录的关键不是 cookie，而是通过cookie 保存和传输的 session ID，其本质是能获取用户信息的数据。除了 cookie，还通常使用 HTTP 请求头来传输。但是这个请求头浏览器不会像 cookie 一样自动携带，需要手工处理。 7.6 什么是jsp，什么是Servlet？jsp 和Servlet 有什么区别？jsp 本质上就是一个Servlet，它是 Servlet 的一种特殊形式（由 SUN 公司推出），每个 jsp 页面都是一个servlet实例。 Servlet 是由 Java 提供用于开发 web 服务器应用程序的一个组件，运行在服务端，由 servlet 容器管理，用来生成动态内容。一个 servlet 实例是实现了特殊接口 Servlet 的 Java 类，所有自定义的 servlet 均必须实现 Servlet 接口。 区别： jsp 是 html 页面中内嵌的Java 代码，侧重页面显示； Servlet 是 html 代码和 Java 代码分离，侧重逻辑控制，mvc 设计思想中jsp 位于视图层，servlet 位于控制层 Jsp 运行机制：如下图 JVM 只能识别 Java 类，并不能识别 jsp 代码！web 容器收到以.jsp 为扩展名的 url 请求时，会将访问请求交给tomcat 中 jsp 引擎处理，每个 jsp 页面第一次被访问时，jsp 引擎将 jsp 代码解释为一个 servlet 源程序，接着编译servlet 源程序生成.class 文件，再web 容器 servlet 引擎去装载执行servlet 程序，实现页面交互。 7.7 servlet生命周期Servlet 加载—&gt;实例化—&gt;服务—&gt;销毁。 生命周期详解： init（）： 在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init（）。 service（）： 它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。 destroy（）： 仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。 如何与Tomcat 结合工作步骤： （1）Web Client 向Servlet容器（Tomcat）发出Http请求 （2）Servlet容器接收Web Client的请求 （3）Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。 （4）Servlet容器创建一个HttpResponse对象 （5）Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet 对象。 （6）HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。 （7）HttpServlet调用HttpResponse对象的有关方法，生成响应数据。 7.8 servlet特性单例多线程 7.9 servlet是单实例的吗？servlet是单实例的 7.10 servlet是线程安全的吗？为什么？Servlet对象并不是一个线程安全的对象。 Servlet第一次被调用的时候，init()方法会被调用，然后调用service() 方法，从第二次被请求开始，就直接调用service()方法。 因为servlet是单实例的，所以后面再次请求同一个Servlet的时候都不会创建Servlet实例， 而且web容器会针对每个请求创建一个独立的线程，这样多个并发请求会导致多个线程同时调用 service() 方法，这样就会存在线程不安全的问题。 7.11 如何解决Servlet线程不安全的问题？（1）不要在servlet中使用成员变量。 （2）可以给servlet中的方法添加同步锁，Synchronized，但是不提倡，数据并发访问会造成阻塞等待。 （3）可以实现 SingleThreadModel 接口，如下。这样可以避免使用成员变量的问题，但是也不提倡，原因同上。 Public class Servlet1 extends HttpServlet implements SingleThreadModel{ …….. } 7.12 谈谈过滤器的作用过滤器，是在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符 7.13 谈谈拦截器的作用拦截器，是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。 7.14 拦截器和过滤器有什么区别拦截器基于反射机制，而过滤器基于函数回调拦截器基于Strust2或SpringMVC这样的表述层框架，而过滤器基于Servlet容器拦截器只能在框架内部生效，而过滤器可以对所有请求生效拦截器可以访问框架内的资源对象（例如Spring IOC容器中的对象），而过滤器不能直接访问框架内的资源对象 7.15 拦截器和过滤器的执行顺序过滤前 – 拦截前 – Action处理 – 拦截后 – 过滤后。 过滤是一个横向的过程，首先把客户端提交的内容进行过滤(例如未登录用户不能访问内部页面的处理)；过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的Action；Action处理完成返回后，拦截器还可以做其他过程(还没想到要做啥)，再向上返回到过滤器的后续操作。 8. SSM8.1 请写出 spring 中常用的依赖注入方式。通过 setter 方法注入 通过构造方法注入 8.2 简述Spring中IOC容器常用的接口和具体的实现类 ● BeanFactory SpringIOC容器的基本设置，是最底层的实现， 面向框架本身的. ● ApplicationContext BeanFactory的子接口, 提供了更多高级的特定. 面向开发者的. ● ConfigurableApplicationContext, ApplicationContext的子接口，扩展出了 close 和 refresh等 关闭 刷新容器的方法 ● ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。 ● FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。 ● XmlWebApplicationContext：由Web应用的XML文件读取上下文。 8.3 简述Spring中如何基于注解配置Bean和装配Bean,（1）首先要在Spring中配置开启注解扫描 1&lt;context:component-scan base-package=” ”&gt;&lt;/ context:component-scan&gt; （2）在具体的类上加上具体的注解 （3）Spring 中通常使用@Autowired 或者是@Resource 等注解进行bean的装配 8.4 说出Spring 或者 Springmvc中常用的5个注解，并解释含义@Component 基本注解，标识一个受Spring管理的组件 @Controller 标识为一个表示层的组件 @Service 标识为一个业务层的组件 @Repository 标识为一个持久层的组件 @Autowired 自动装配 @Qualifier(“”) 具体指定要装配的组件的id值 @RequestMapping() 完成请求映射 @PathVariable 映射请求URL中占位符到请求处理方法的形参 只要说出机几个注解并解释含义即可，如上答案只做参考 8.5 请解释Spring Bean的生命周期？（1）默认情况下，IOC容器中bean的生命周期分为五个阶段: ​ ● 调用构造器 或者是通过工厂的方式创建Bean对象 ​ ● bean对象的属性注入值 ​ ● 调用初始化方法，进行初始化，初始化方法是通过init-method来指定的. ​ ● 使用 ​ ● IOC容器关闭时， 销毁Bean对象. （2）当加入了Bean的后置处理器后，IOC容器中bean的生命周期分为七个阶段: ​ ● 调用构造器 或者是通过工厂的方式创建Bean对象 ​ ● 给bean对象的属性注入值 ​ ● 执行Bean后置处理器中的 postProcessBeforeInitialization ​ ● 调用初始化方法，进行初始化，初始化方法是通过init-method来指定的. ​ ● 执行Bean的后置处理器中 postProcessAfterInitialization ​ ● 使用 ​ ● IOC容器关闭时， 销毁Bean对象 ​ 只需要回答出第一点即可，第二点也回答可适当 加分。 8.6 简单的谈一下SpringMVC的工作流程？​ ● 用户发送请求至前端控制器DispatcherServlet ​ ● DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ​ ● 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ​ ● DispatcherServlet调用HandlerAdapter处理器适配器 ​ ● HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ​ ● Controller执行完成返回ModelAndView ​ ● HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet ​ ● DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ​ ● ViewReslover解析后返回具体View ​ ● DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 ​ ● DispatcherServlet响应用户 8.7 SpringMVC中如何解决POST请求中文乱码问题Springmvc中通过CharacterEncodingFilter解决中文乱码问题. 在web.xml中加入： 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 8.8 简述SpringMvc里面拦截器是如何定义，如何配置，拦截器中三个重要的方法定义：有两种方式 ​ ● 实现HandlerInterceptor接口 ​ ● 继承HandlerInterceptorAdapter 配置： 12345678910&lt;mvc:interceptors&gt; &lt;!--默认是对所有请求都拦截 --&gt; &lt;bean id=\"myFirstInterceptor\" class=\"com.atguigu.interceptor.MyFirstInterceptor\"&gt; &lt;/bean&gt; &lt;!-- 只针对部分请求拦截或者不拦截 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\" \" /&gt; &lt;!—指定拦截--&gt; &lt;mvc:exclude-mapping path=””/&gt; &lt;!—指定不拦截--&gt; &lt;bean class=\" com.atguigu.interceptor.MySecondInterceptor \" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器中三个重要的方法： ​ ● preHandle ​ ● postHandle ​ ● afterCompletion 8.9 MyBatis中 #{}和${}的区别是什么？#{}是预编译处理，${}是字符串替换； Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； Mybatis在处理${}时，就是把${}替换成变量的值； 使用#{}可以有效的防止SQL注入，提高系统安全性。 8.10 Mybatis 结果集的映射方式有几种，并分别解释每种映射方式如何使用。自动映射 ，通过resultType来指定要映射的类型即可。 自定义映射 通过resultMap来完成具体的映射规则，指定将结果集中的哪个列映射到对象的哪个属性。 8.11 简述MyBatis的单个参数、多个参数如何传递及如何取值。MyBatis传递单个参数，如果是普通类型(String+8个基本)的，取值时在#{}中可以任意指定，如果是对象类型的，则在#{}中使用对象的属性名来取值 MyBatis传递多个参数，默认情况下，MyBatis会对多个参数进行封装Map，取值时在#{}可以使用0 1 2 .. 或者是param1 param2.. MyBatis传递多个参数，建议使用命名参数，在Mapper接口的方法的形参前面使用 @Param() 来指定封装Map时用的key. 取值时在#{}中使用@Param指定的key 8.12 MyBatis如何获取自动生成的(主)键值?在标签中使用 useGeneratedKeys 和 keyProperty 两个属性来获取自动生成的主键值。 示例: 123&lt;insert id=”insertname” usegeneratedkeys=”true” keyproperty=”id”&gt; insert into names (name) values (#{name}) &lt;/insert&gt; 述Mybatis的动态SQL，列出常用的6个标签及作用动态SQL是MyBatis的强大特性之一 基于功能强大的OGNL表达式。 动态SQL主要是来解决查询条件不确定的情况，在程序运行期间，根据提交的条件动态的完成查询 常用的标签: : 进行条件的判断 ：在判断后的SQL语句前面添加WHERE关键字，并处理SQL语句开始位置的AND 或者OR的问题 ：可以在SQL语句前后进行添加指定字符 或者去掉指定字符. : 主要用于修改操作时出现的逗号问题 ：类似于java中的switch语句.在所有的条件中选择其一 ：迭代操作 8.14 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复。 8.15 Mybatis 如何完成MySQL的批量操作,举例说明MyBatis完成MySQL的批量操作主要是通过标签来拼装相应的SQL语句. 例如: 123456&lt;insert id=\"insertBatch\" &gt; insert into tbl_employee(last_name,email,gender,d_id) values &lt;foreach collection=\"emps\" item=\"curr_emp\" separator=\",\"&gt; (#{curr_emp.lastName},#{curr_emp.email},#{curr_emp.gender},#{curr_emp.dept.id}) &lt;/foreach&gt; &lt;/insert&gt; 8.16 简述Spring中如何给bean对象注入集合类型的属性Spring使用 等标签给对应类型的集合注入值 8.17 简述Spring 中bean的作用域总共有四种作用域: ● Singleton 单例的 ● Prototype 原型的 ● Request ● Session 8.18 简述Spring中自动装配常用的两种装配模式byName: 根据bean对象的属性名进行装配 byType： 根据bean对象的属性的类型进行装配,需要注意匹配到多个兼容类型的bean对象时，会抛出异常。 8.19 请解释@Autowired注解的工作机制及required属性的作用（1）首先会使用byType的方式进行自动装配，如果能唯一匹配，则装配成功， 如果匹配到多个兼容类型的bean, 还会尝试使用byName的方式进行唯一确定. 如果能唯一确定，则装配成功，如果不能唯一确定，则装配失败，抛出异常. （2）默认情况下， 使用@Autowired标注的属性必须被装配，如果装配不了，也会抛出异常. 可以使用required=false来设置不是必须要被装配. 8.20 简述Springmvc中ContextLoaderListener的作用以及实现原理作用： ContextLoaderListener的作用是通过监听的方式在WEB应用服务器启动时将Spring的容器对象进行初始化. 原理： ContextLoaderListener 实现了ServletContextListener接口，用于监听 ServletContext的创建，当监听到ServletContext创建时，在对应contextInitialized 方法中，将Spring的容器对象进行创建，并将创建好的容器对象设置到ServletContext域对象中， 目的是让各个组件可以通过ServletContext共享到Spring的容器对象 8.21 简述Mybatis提供的两级缓存，以及缓存的查找顺序（1）MyBatis的缓存分为一级缓存和 二级缓存。 一级缓存是SqlSession级别的缓存，默认开启。 二级缓存是NameSpace级别(Mapper)的缓存，多个SqlSession可以共享，使用时需要进行配置开启。 （2）缓存的查找顺序：二级缓存 =&gt; 一级缓存 =&gt; 数据库 8.22 简述Spring与Springmvc整合时，如何解决bean被创建两次的问题Bean被创建两次的问题是在组建扫描的配置中指定Springmvc只负责扫描WEB相关的组件，Spring扫描除了Springmvc之外的组件。 8.23 简述Spring与Mybatis整合时，主要整合的两个地方（1）SqlSession创建的问题，通过SqlSessionFactoryBean来配置用于创建SqlSession的信息。例如: Mybatis的核心配置文件、Mapper映射文件、数据源等 （2）Mapper接口创建的问题， 使用MapperScannerConfigurer批量为MyBatis的Mapper接口生成代理实现类并将具体的对象交给Spring容器管理 8.24 简述Spring声明式事务中@Transaction中常用的两种事务传播行为通过propagation来执行事务的传播行为 REQUIRED：使用调用者的事务，如果调用者没有事务，则启动新的事务运行 REQUIRES_NEW：将调用者的事务挂起，开启新的事务运行。 8.25 简述@RequestMapping注解的作用，可标注的位置，常用的属性（1）该注解的作用是用来完成请求 与 请求处理方法的映射 （2）该注解可以标注在类上或者是方法上 （3）常用的属性: value: 默认属性， 用于指定映射的请求URL method: 指定映射的请求方式 params: 指定映射的请求参数 headers: 指定映射的请求头信息 8.26 简述Springmvc中处理模型数据的两种方式 ● 使用ModelAndView 作为方法的返回值，将模型数据和视图信息封装到ModelAndView中 ● 使用Map或者是Model 作为方法的形参，将模型数据添加到Map或者是Model中 8.27 简述REST中的四种请求方式及对应的操作GET 查询操作 POST 添加操作 DELETE 删除操作 PUT 修改操作 8.28 简述视图和视图解析的关系及作用 ● 视图是由视图解析器解析得到的。 ● 视图解析器的作用是根据ModelAndView中的信息解析得到具体的视图对象 ● 视图的作用是完成模型数据的渲染工作，最终完成转发或者是重定向的操作 8.29 说出三个 常用的视图类InternalResourceView JstlView RedirectView 8.30 简述REST中HiddenHttpMethodFilter过滤器的作用该过滤器主要负责转换客户端请求的方式，当浏览器的请求方式为POST，并且在请求中能通过 _method获取到请求参数值。该过滤器就会进行请求方式的转换。 一般在REST中，都是将POST请求转换为对应的DELETE 或者是PUT 8.31 简述Springmvc中如何返回JSON数据Step1：在项目中加入json转换的依赖，例如jackson，fastjson，gson等 Step2：在请求处理方法中将返回值改为具体返回的数据的类型， 例如数据的集合类List等 Step3：在请求处理方法上使用@ResponseBody注解 这里再补充一个注意点：使用@ResponseBody注解需要开启注解驱动功能，也就是需要配置 8.32 简述如何在myBatis中的增删改操作获取到对数据库的影响条数直接在Mapper接口的方法中声明返回值即可 8.33 Springmvc中的控制器的注解用哪个，可以是否用别的注解代替使用@Controller注解来标注控制器，不能使用别的注解代替。 8.34 如何在Springmvc中获取客户端提交的请求参数直接在请求处理方法中声明对应的形参，也可以是用@RequestParam注解来具体指定将那些请求参数映射到方法中对应的形参。 8.35 简述Springmvc中InternalResourceViewResolver解析器的工作机制使用prefix + 方法的返回值 + suffix 生成一个物理视图路径。 8.36 Springmvc中如何完成重定向在请求处理方法的返回值前面加 redirect: 前缀, 最终会解析得到RedirectView，RedirectView会完成重定向的操作。 8.37 简述Spring中切面中常用的几种通知，并简单解释前置通知 在目标方法执行之前执行 后置通知 在目标方法执行之后执行，不管目标方法有没有抛出异常 返回通知 在目标方法成功返回之后执行， 可以获取到目标方法的返回值 异常通知 在目标方法抛出异常后执行 环绕通知 环绕着目标方法执行 8.38 解释MyBatis中 @Param注解的作用通过该注解来指定Mybatis底层在处理参数时封装Map使用的key，方便在SQL映射文件中取参数。 8.39 简述Mybatis中使用Mapper接口开发，如何完成Mapper接口与SQL映射文件、方法与SQL语句的绑定Mapper接口与SQL映射文件绑定：SQL映射文件中的namespace的值指定成Mapper接口的全类名 接口中方法与SQL语句的绑定：SQL语句的id 指定成接口中的方法名。 8.40 SpringMVC的工作原理（1）用户向服务器发送请求，请求被springMVC 前端控制器 DispatchServlet 捕获； （2）DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping将请求映射到处理器 HandlerExcutionChain； （3）DispatchServlet 根据获得 Handler 选择一个合适的HandlerAdapter 适配器处理； （4）Handler 对数据处理完成以后将返回一个 ModelAndView（）对象给 DisPatchServlet; （5）Handler 返回的 ModelAndView() 只是一个逻辑视图并不是一个正式的视图， DispatcherSevlet 通过ViewResolver 试图解析器将逻辑视图转化为真正的视图View; （6）DispatcherServle 通过 model 解析出 ModelAndView()中的参数进行解析最终展现出完整的 view 并返回给客户端; 8.41 谈谈你对Spring 的理解Spring 是一个开源框架，为简化企业级应用开发而生。Spring 可以是使简单的JavaBean 实现以前只有EJB 才能实现的功能。Spring 是一个 IOC 和 AOP 容器框架。 Spring 容器的主要核心是： 控制反转（IOC），传统的 java 开发模式中，当需要一个对象时，我们会自己使用 new 或者 getInstance 等直接或者间接调用构造方法创建一个对象。而在 spring 开发模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring 提供的对象就可以了，这是控制反转的思想。 依赖注入（DI），spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。 面向切面编程（AOP），在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用CGLIB 方式实现动态代理。 8.42 Spring中常用的设计模式（1）代理模式——spring 中两种代理方式，若目标对象实现了若干接口，spring 使用jdk 的java.lang.reflect.Proxy类代理。若目标兑现没有实现任何接口，spring 使用 CGLIB 库生成目标类的子类。 （2）单例模式——在 spring 的配置文件中设置 bean 默认为单例模式。 （3）模板方式模式——用来解决代码重复的问题。 比如：RestTemplate、JmsTemplate、JpaTemplate （4）工厂模式——在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用同一个接口来指向新创建的对象。Spring 中使用 beanFactory 来创建对象的实例。 8.43 请描述一下Spring的事务管理（1）声明式事务管理的定义：用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。这样的好处是，事务管理不侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可，这样维护起来极其方便。 基于 TransactionInterceptor 的声明式事务管理：两个次要的属性： transactionManager，用来指定一个事务治理器， 并将具体事务相关的操作请托给它； 其他一个是 Properties 类型的transactionAttributes 属性，该属性的每一个键值对中，键指定的是方法名，方法名可以行使通配符， 而值就是表现呼应方法的所运用的事务属性。 （2）基于 @Transactional 的声明式事务管理：Spring 2.x 还引入了基于 Annotation 的体式格式，具体次要触及@Transactional 标注。@Transactional 可以浸染于接口、接口方法、类和类方法上。算作用于类上时，该类的一切public 方法将都具有该类型的事务属性。 （3）编程式事物管理的定义：在代码中显式挪用 beginTransaction()、commit()、rollback()等事务治理相关的方法， 这就是编程式事务管理。Spring 对事物的编程式管理有基于底层 API 的编程式管理和基于 TransactionTemplate 的编程式事务管理两种方式。 9. SpringBoot9.1 什么是 Spring Boot？Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。 9.2 为什么要用 Spring Boot？Spring Boot 的优点 ● 独立运行 Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。 ● 简化配置 spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。除此之外，还提供了各种启动器，开发者能快速上手。 ● 自动配置 Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。 ● 无代码生成和XML配置 Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。 ● 应用监控 Spring Boot提供一系列端点可以监控服务及应用，做健康检测。 9.3 Spring Boot有哪些缺点？Spring Boot虽然上手很容易，但如果你不了解其核心技术及流程，所以一旦遇到问题就很棘手，而且现在的解决方案也不是很多，需要一个完善的过程。 9.4 Spring Boot 的核心配置文件有哪几个？它们的区别是什么？Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。 application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。 bootstrap 配置文件的特性： ​ ● boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载 ​ ● boostrap 里面的属性不能被覆盖 bootstrap 配置文件有以下几个应用场景： ​ ● 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息； ​ ● 一些固定的不能被覆盖的属性； ​ ● 一些加密/解密的场景； 9.5 Spring Boot 的配置文件有哪几种格式？它们有什么区别？.properties 和 .yml，它们的区别主要是书写格式不同。 1).properties 1app.user.name = javastack 2).yml 123app: user: name: javastack 9.6 Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解： @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。 @ComponentScan：Spring组件扫描。 9.7 开启 Spring Boot 特性有哪几种方式？ 继承spring-boot-starter-parent项目 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt; 2.0.7.RELEASE &lt;/version&gt; &lt;/parent&gt; ● 如果项目已经继承了其他父项目，则可以导入spring-boot-dependencies项目依赖 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 导入SpringBoot需要使用的依赖信息 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 9.8 Spring Boot 需要独立的容器运行吗？可以不需要，内置了 Tomcat/ Jetty 等容器。 9.9 运行 Spring Boot 有哪几种方式？1）打包命令或者放到容器中运行 2）用 Maven/ Gradle 插件运行 3）直接执行 main 方法运行 9.10 Spring Boot 自动配置原理是什么？SpringBoot的自动化配置原理可以从以下7点介绍：与自动化配置相关的jar包是spring-boot-autoconfigure-2.1.6.RELEASE.jar在spring-boot-autoconfigure-2.1.6.RELEASE.jar这个jar包里有个META-INF目录META-INF目录下有个spring.factories文件spring.factories文件中有个配置项是org.springframework.boot.autoconfigure.EnableAutoConfiguration这个配置项对应的值就是各个具体的自动化配置类在具体的自动化配置类上有四个（组）相关注解@Configuration注解表示当前类是一个“配置”类@ConditionalOnXxx注解表示当前类需要满足指定条件才会加载到IOC容器中@EnableConfigurationProperties注解用于加载XxxProperties类@Import注解加载运行过程中用到的类XxxProperties类这个类中封装了当前starter范围内常用的自动化配置信息，例如整合Redis时使用的主机地址、端口号等等。有些有默认值。SpringBoot会读取这个类中的数据作为默认配置。这个类同时还指定了在application.properties或application.yml中针对当前starter可以使用的配置项。所以这个类其实是SpringBoot配置文件中配置项的依据。在application.properties或application.yml中所做的配置本质上是对XxxProperties类中默认值的覆盖。XxxProperties类需要标记@ConfigurationProperties注解才能够被SpringBoot识别@ConfigurationProperties注解通过prefix属性指定在application.properties或application.yml中做相关配置时使用的前缀 11、你如何理解 Spring Boot 中的 Starters？ SpringBoot的starter我们翻译成“场景启动器”，是SpringBoot的一个重要特色和优势。在一个starter中SpringBoot不仅提供了这个场景下所需要的所有依赖包而且通过版本仲裁保证所引入的依赖包版本正确，最大限度降低了jar包冲突隐患。不仅如此SpringBoot还在starter中封装了该场景在实际开发中总结出来的最佳实践，以自动化配置的形式把常用默认配置给我们直接配置好。例如我们在使用SpringMVC时需要配置mvc:annotation-driven开启注解驱动，在引入spring-boot-web-starter后就不需要了，注解支持已经作为最佳实践整合到了starter中。还有spring-boot-web-starter里面也加入了对JSON数据解析能力的支持，这在SpringMVC中是需要程序员自己引入相关jar包的。所以SpringBoot的starter几乎做到了想要的功能一键开启、自动运行。 12、如何在 Spring Boot 启动的时候运行一些特定的代码？ 可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法，实现上述接口的类加入IOC容器即可生效。 13、Spring Boot 有哪几种读取配置的方式？ Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量。 14、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？ Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架。 15、SpringBoot 实现热部署有哪几种方式？ 主要有两种方式： Spring Loaded Spring-boot-devtools 16、你如何理解 Spring Boot 配置加载顺序？ 1、开发者工具 Devtools 全局配置参数；2、单元测试上的 @TestPropertySource 注解指定的参数；3、单元测试上的 @SpringBootTest 注解指定的参数；4、命令行指定的参数，如 java -jar springboot.jar --name=&quot;Java技术栈&quot;；5、命令行中的 SPRING_APPLICATION_JSONJSON 指定参数, 如 java -Dspring.application.json='{&quot;name&quot;:&quot;Java技术栈&quot;}' -jar springboot.jar6、ServletConfig 初始化参数；7、ServletContext 初始化参数；8、JNDI参数（如 java:comp/env/spring.application.json）；9、Java系统参数（来源：System.getProperties()）；10、操作系统环境变量参数；11、RandomValuePropertySource 随机数，仅匹配：ramdom.*；12、JAR包外面的配置文件参数（application-{profile}.properties（YAML））13、JAR包里面的配置文件参数（application-{profile}.properties（YAML））14、JAR包外面的配置文件参数（application.properties（YAML））15、JAR包里面的配置文件参数（application.properties（YAML））16、@Configuration配置文件上 @PropertySource 注解加载的参数；17、默认参数（通过 SpringApplication.setDefaultProperties 指定）； 数字越小优先级越高，即数字小的会覆盖数字大的参数值。 17、Spring Boot 如何定义多套不同环境配置？ 开发阶段基于properties配置文件第一步创建各环境对应的properties配置文件applcation.propertiesapplication-dev.propertiesapplication-test.propertiesapplication-prod.properties第二步然后在applcation.properties文件中指定当前的环境spring.profiles.active=test,这时候读取的就是application-test.properties文件。基于yml配置文件只需要一个applcation.yml文件就能搞定，推荐此方式。spring:profiles: active: prodspring:profiles: devserver: port: 8080spring:profiles: testserver: port: 8081spring.profiles: prodspring.profiles.include: proddb prodmqserver: port: 8082spring:profiles: proddbdb: name: mysqlspring:profiles: prodmqmq:address: localhost运行阶段指定profile通过main方法启动// 在Eclipse Arguments里面添加–spring.profiles.active=prod通过插件启动spring-boot:run -Drun.profiles=prod通过java -jar命令启动java -jar xx.jar –spring.profiles.active=prod 9.18 Spring Boot 可以兼容老 Spring 项目吗，如何做？可以兼容，使用 @ImportResource 注解导入老 Spring 项目配置文件。 9.19 Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？ 依赖 JDK 版本升级：2.x 里面的许多方法应用了 JDK 8 的许多高级新特性，至少需要 JDK 8 的支持； 第三方类库升：2.x 对第三方类库升级了所有能升级的稳定版本，例如：Spring Framework 5+、Tomcat 8.5+、Hibernate 5.2+、Thymeleaf 3+； 响应式 Spring 编程：2.x 通过启动器和自动配置全面支持 Spring 的响应式编程，响应式编程是完全异步和非阻塞的，它是基于事件驱动模型，而不是传统的线程模型； 连接池：2.x 默认使用 HikariCP 连接池； json：提供了一个 spring-boot-starter-json 启动器对 JSON 读写的支持； Quartz：2.x 提供了一个 spring-boot-starter-quartz 启动器对定时任务框架 Quartz 的支持； HTTP/2 支持：提供对HTTP/2 的支持，如：Tomcat, Undertow, Jetty； Actuator加强：在 2.x 中，对执行器端点进行了许多改进，所有的 HTTP 执行端点现在都暴露在 /actuator路径下，并对 JSON 结果集也做了改善。 10. SpringCloud10.1 Spring Boot和Spring 是什么关系SpringBoot底层就是Spring，简化使用Spring的方式而已，多加了好多的自动配置 10.2 Spring Boot和Spring Cloud是什么关系Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约定大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，必须基于Spring Boot开发。 可以单独使用Spring Boot开发项目，但是Spring Cloud离不开 Spring Boot。 10.3 Eureka和zookeeper的区别著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 Zookeeper 保证CP 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。 Eureka 保证AP Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。 总结 Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。不过Eureka目前1.X版本的实现是基于servlet的java web应用，它的极限性能肯定会受到影响。期待正在开发之中的2.X版本能够从servlet中独立出来成为单独可部署执行的服务。 11. Redis11.1 什么是Redis？Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 11.2 Redis的全称是什么？Remote Dictionary Server 11.3 redis有哪些数据类型 string 字符串 list 可以重复的集合 set 不可以重复的集合 hash 类似于Map&lt;String,String&gt; zset(sorted set） 带分数的set 11.4 一个字符串类型的值能存储最大容量是多少？512M 11.5 怎么理解Redis事务？Redis无法做到像关系型数据库事务那样严格的ACID属性，特别是Redis官网明确指出了Redis为什么不支持回滚。 为了内部结构简单、运行效率更高，Redis舍弃了事务控制过程中的回滚支持。一个队列中的多个命令除非是在加入队列时发现错误会做到整个事务都不执行，否则所有命令都会执行，哪怕是队列中有的命令执行失败——显然Redis并没有在这里对队列中的多条命令进行回滚处理。Redis认为这些错误都应该在开发过程中被发现，而不是产品上线之后。 配合WATCH命令之后Redis的事务可以实现乐观锁效果：一个队列中的命令在执行时如果检测到碰撞，则放弃自己的操作。 11.6 Redis事务相关的命令有哪几个？MULTI、EXEC、DISCARD、WATCH 11.7 Redis key的过期时间和永久有效分别怎么设置？EXPIRE和PERSIST命令。 11.8 Redis持久化数据和缓存怎么做扩容？如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。4、Redis主要消耗什么物理资源？ 内存。 11.9 为什么Redis需要把所有数据放到内存中？Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 11.10 Redis如何做内存优化？尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面. 11.11 缓存穿透缓存系统定义： 按照KEY去查询VALUE，当KEY对应的VALUE一定不存在的时候并对KEY并发请求量很大的时候，就会对后端造成很大的压力。（查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。） 由于缓存不命中，每次都要查询持久层。从而失去缓存的意义。 解决方法： （1）缓存层缓 存空值。 缓存太多空值，占用更多空间。（优化：给个空值过 期时间） 存储层更新代码了，缓存层还是空值。（优化：后台设置时主动删除空值，并缓存把值进去） （2）将数据库中所有的查询条件，放布隆过滤器中。当一个查询请求来临的时候，先经过布隆过滤器进行查，如果请求存在这个条件中，那么继续执行，如果不在，直接丢弃。 备注 ： 比如数据库中有10000个条件，那么布隆过滤器的容量size设置的要稍微比10000大一些，比如12000. 对于误判率的设置，根据实际项目，以及硬件设施来具体定。但一定不能设置为0，并且误判率设置的越小，哈希函数跟数组长度都会更多跟更长，那么对硬件，内存中间的要求就会相应 的高 private st atic BloomFilter bloomFi lt er = BloomFilter.create(Funnels.integerFue l(), s ize, 000 01) ; 有了siz跟误判率，那么布隆过滤器会产相应的哈希函数跟数组。 综上：我们可以利用布隆过滤器，将redis缓存击穿制在一个可容的范围内。 11.12 哨兵模式如果Master异常，则会进行Master-Slave切换，将其中一Slae作为Master，将之前的Master作为Slave 下线： ①主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。 ②客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN 判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，然后开启failover. 工作原理： （1）每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令 ； （2）如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线； （3）如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态； （4）当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 ； （5）在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 （6）当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 ； （7）若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除； 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除； 11.13 悲观锁执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰。 Redis不支持悲观锁。Redis作为缓存服务器使用时，以读操作为主，很少写操作，相应的操作被打断的几率较少。不采用悲观锁是为了防止降低性能。 11.14 乐观锁执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。 11.15 持久化（1）RDB持久化： 每隔一段时间，将内存中的数据集写到磁盘 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。 保存策略： save 9 00 1 900 秒内如果至少有 1 个 key 的值变化，则保存 save 300 10 300 秒内如果至少有 10 个 key 的值变化，则保存 save 60 1 0000 60 秒内如果至10000 个 key 的值变化，则保存 （2）AOF 持久化: 以日志形式记录每个更新（(总结、改）操作 Redis重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。 保存策略： appendfsync always：每次产生一条新的修改数据的命令都执行保存操作；效率低，但是安全！ appendfsync everysec：每秒执行一次保存操作。如果在未保存当前秒内操作时发生了断电，仍然会导致一部分数据丢失（即1秒钟的数据）。 appendfsync no：将数据库保存操作的触发时机交给操作系统来进行调度更快，也更不安全的选择。 推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。 缺点： 1 比起RDB占用更多的磁盘空间 2 恢复备份速度要慢 3 每次读写都同步的话，有一定的性能压力 4 存在个别Bug，造成恢复不能 （3）选择策略： 可读的日志文本，通过操作AOF 官方推荐： 如果对数据不敏感，可以选单独用RDB；不建议单独用AOF，因为可能出现Bug;如果只是做纯内存缓存，可以都不用 11.16 Redis提供了哪几种持久化方式？RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。 AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。 你也可以同时开启两种持久化方式，在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 11.17 如何选择合适的持久化方式？一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。 有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的bug。 11.18 分布式Redis是前期做还是后期规模上来了再做好？为什么？既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。 一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。 这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。 11.19 Redis的内存占用情况怎么样？给你举个例子： 100万个键值对（键是0到999999值是字符串“hello world”）在我的32位的Mac笔记本上 用了100MB。同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。 当然，大键值对时两者的比例要好很多。 64位的系统比32位的需要更多的内存开销，尤其是键值对都较小时，这是因为64位的系统里指针占用了8个字节。 但是，当然，64位系统支持更大的内存，所以为了运行大型的Redis服务器或多或少的需要使用64位的系统。 11.20 都有哪些办法可以降低Redis的内存使用情况呢？如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。 11.21 查看Redis使用情况及状态信息用什么命令？info 11.22 Redis的内存用完了会发生什么？如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 11.23 redis是单线程的，为什么那么快1)完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 2)数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的 3)采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 4)使用多路I/O复用模型，非阻塞IO 5)使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求 11.24 Redis是单线程的，如何提高多核CPU的利用率？可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。 11.25 一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？理论上Redis可以处理多达 的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。 任何list、set、和sorted set都可以放 个元素。 换句话说，Redis的存储极限是系统中的可用内存值。 11.26 Redis常见性能问题和解决方案？(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 (2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 (3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 (4) 尽量避免在压力很大的主库上增加从库 (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 11.27 Redis相比memcached有哪些优势？(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 (2) redis的速度比memcached快很多 redis可以持久化其数据 11.28 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 11.29 Redis有哪几种数据淘汰策略？noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 11.30 Redis集群方案应该怎么做？都有哪些方案？（1）twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本地需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。 （2）codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。 （3）redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。 （4）在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。 11.31 说说Redis哈希槽的概念？Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 11.32 Redis集群最大节点个数是多少？16384个。 11.33 怎么测试Redis的连通性？ping 11.34 修改配置不重启Redis会实时生效吗？针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。 但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。 11.35 Redis有哪些适合的场景？（1）会话缓存（Session Cache） 最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 （2）全页缓存（FPC） 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 （3）队列 Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。 （4）排行榜/计数器 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 （5）发布/订阅 最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。 12. MQ12.1 ActiveMQ 如果消息发送失败怎么办？Activemq 有两种通信方式，点到点形式和发布订阅模式。 如果是点到点模式的话，如果消息发送不成功此 消息默认会保存到 activemq 服务端直到有消费者将其消费，所以此时消息是不会丢失的。 如果是发布订阅模式的通信方式，默认情况下只通知一次，如果接收不到此消息就没有了。这种场景只适 用于对消息送达率要求不高的情况。如果要求消息必须送达不可以丢失的话，需要配置持久订阅。每个订阅端定义一个 id， 在订阅是向 activemq 注册。发布消息和接收消息时需要配置发送模式为持久化。此时 如果客户端接收不到消息，消息会持久化到服务端，直到客户端正常接收后为止。 12.2 如何使用ActiveMQ 解决分布式事务？在互联网应用中，基本都会有用户注册的功能。在注册的同时，我们会做出如下操作： 收集用户录入信息，保存到数据库向用户的手机或邮箱发送验证码等等… 如果是传统的集中式架构，实现这个功能非常简单：开启一个本地事务，往本地数据库中插入一条用户数据，发送验证码，提交事务。 但是在分布式架构中，用户和发送验证码是两个独立的服务，它们都有各自的数据库，那么就不能通过本地事务保证操作的原子性。这时我们就需要用到 ActiveMQ（消息队列）来为我们实现这个需求。 在用户进行注册操作的时候，我们为该操作创建一条消息，当用户信息保存成功时，把这条消息发送到消息队列。验证码系统会监听消息，一旦接受到消息，就会给该用户发送验证码。 12.3 如何防止ActiveMQ消息重复发送？解决方法很简单：增加消息状态表。通俗来说就是一个账本，用来记录消息的处理状态，每次处理消息之前，都去状态表中查询一次，如果已经有相同的消息存在，那么不处理，可以防止重复发送。 13. ElasticSearch13.1 什么是ElasticSearch？Elasticsearch是一个基于Lucene的搜索引擎。它提供了具有HTTP Web界面和无架构JSON文档的分布式，多租户能力的全文搜索引擎。Elasticsearch是用Java开发的，根据Apache许可条款作为开源发布。 13.2 Elasticsearch中的倒排索引是什么？倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。倒排索引是一种像数据结构一样的散列图，可将用户从单词导向文档或网页。它是搜索引擎的核心。其主要目标是快速搜索从数百万文件中查找数据。 14. Dubbo14.1 Dubbo 的连接方式有哪些？Dubbo 的客户端和服务端有三种连接方式，分别是：广播，直连和使用 zookeeper 注册中心。 14.2 Dubbo 的容错机制有哪些？（1）Failover Cluster 模 式 失败自动切换，当出现失败，重试其它服务器。(默认) 2）Failfast Cluster 快速失败，只发起一次调用，失败立即报错。 通常用于非幂等性的写操作，比如新增记录。 （2）Failsafe Cluster 失败安全，出现异常时，直接忽略。 通常用于写入审计日志等操作。 （3）Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。 通常用于消息通知操作。 （4）Forking Cluster 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2”来设置最大并行数。 （5）Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0 开始支持) 通常用于通知所有提供者更新缓存或日志等本地资源信息。 总结： 在实际应用中查询语句容错策略建议使用默认Failover Cluster ，而增删改建议使用 Failfast Cluster 或者 使用 Failover Cluster（retries=”0”） 策略 防止出现数据 重复添加等等其它问题！建议在设计接口时候把查询接口方法单独做一个接口提供查询。 14.3 使用dubbo 遇到过哪些问题？（1）增加提供服务版本号和消费服务版本号 这个具体来说不算是一个问题,而是一种问题的解决方案,在我们的实际工作中会面临各种环境资源短缺的问题,也是很实际的问题,刚开始我们还可以提供一个服务进行相关的开发和测试,但是当有多个环境多个版本,多个任务的时候就不满足我们的需求,这时候我们可以通过给提供方增加版本的方式来区分.这样能够剩下很多的物理资源,同时为今后更换接口定义发布在线时，可不停机发布，使用版本号. 引用只会找相应版本的服务,例如： &lt;dubbo:serviceinterface=“com.xxx.XxxService”ref=“xxxService” version=“1.0” /&gt; &lt;dubbo:referenceid=“xxxService”interface=“com.xxx.XxxService” version=“1.0”/&gt; （2）dubbo reference 注解问题 @Reference 只能在 springbean 实例对应的当前类中使用，暂时无法在父类使用；如果确实要在父类声明一个引用，可通过配置文件配置 dubbo:reference，然后在需要引用的地方跟引用 springbean 一样就可以了. （3）出现 RpcException: No provider available for remote service 异常，表示没有可用的服务提供者 检查连接的注册中心是否正确 到注册中心查看相应的服务提供者是否存在 检查服务提供者是否正常运行 （4）服务提供者没挂，但在注册中心里看不到 首先，确认服务提供者是否连接了正确的注册中心，不只是检查配置中的注册中心地址，而且要检查实际的网络连接。 其次，看服务提供者是否非常繁忙，比如压力测试，以至于没有CPU 片段向注册中心发送心跳，这种情况，减小压力，将自动恢复。 15. Zookeeper15.1 ZooKeeper是什么？ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。 Zookeeper保证了如下分布式一致性特性： 顺序一致性 原子性 单一视图 可靠性 实时性（最终一致性） 客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。 有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。 15.2 Zookeeper Watcher 机制 — 数据变更通知Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。 工作机制： 客户端注册watcher 服务端处理watcher 客户端回调watcher Watcher 特性总结： （1）一次性无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。 （2）客户端串行执行客户端Watcher回调的过程是一个串行同步的过程。 （3）轻量 Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。 客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。 watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不同的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。 注册watcher getData、exists、getChildren 触发watcher create、delete、setData 当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。 16. Git16.1 reset 与 rebase, pull 与 fetch 的区别git reset 不修改commit相关的东西，只会去修改.git目录下的东西。 git rebase 会试图修改你已经commit的东西，比如覆盖commit的历史等，但是不能使用rebase来修改已经push过的内容，容易出现兼容性问题。rebase还可以来解决内容的冲突，解决两个人修改了同一份内容，然后失败的问题。 git pull pull=fetch+merge, 使用git fetch是取回远端更新，不会对本地执行merge操作，不会去动你的本地的内容。 pull会更新你本地代码到服务器上对应分支的最新版本 16.2 git merge和git rebase的区别git merge把本地代码和已经取得的远程仓库代码合并。 git rebase是复位基底的意思，gitmerge会生成一个新的节点，之前的提交会分开显示，而rebase操作不会生成新的操作，将两个分支融合成一个线性的提交。 16.3 git如何解决代码冲突git stash git pull git stash pop 这个操作就是把自己修改的代码隐藏，然后把远程仓库的代码拉下来，然后把自己隐藏的修改的代码释放出来，让git自动合并。 如果要代码库的文件完全覆盖本地版本。 git reset –hard git pull 17. Linux17.1 Linux常用命令 序号 命令 命令解释 1 top 查看内存 2 df -h 查看磁盘存储情况 3 iotop 查看磁盘IO读写(yum install iotop安装） 4 iotop -o 直接查看比较高的磁盘读写程序 5 netstat -tunlp | grep 端口号 查看端口占用情况 6 uptime 查看报告系统运行时长及平均负载 7 ps aux 查看进程 17.2 如何查看所有java进程grep是搜索关键字 &gt;ps -ef | grep java -aux 显示所有状态 &gt;ps -aux | grep java 17.3 如何杀掉某个服务的进程kill 命令用于终止进程 -9 强迫进程立即停止 &gt;kill -9 [PID] 这里pid需要用 ps -ef | grep 查询pid 17.4 启动/停止服务以启动Tomcat为例,先cd到启动的.sh文件目录 &gt; cd /java/tomcat/bin &gt; ./startup.sh 停止Tomcat服务命令 &gt;./shutdown.sh 17.5 如何查看测试项目的日志一般测试的项目里面，有个logs的目录文件，会存放日志文件，有个xxx.out的文件，可以用tail -f 动态实时查看后端日志 先cd 到logs目录(里面有xx.out文件) &gt;tail -f xx.out 这时屏幕上会动态实时显示当前的日志，ctr+c停止 17.6 如何查看最近1000行日志&gt;tail -1000 xx.out 17.7 LINUX中如何查看某个端口是否被占用&gt;netstat -anp | grep 端口号 图中主要看监控状态为LISTEN表示已经被占用，最后一列显示被服务mysqld占用，查看具体端口号，只要有如图这一行就表示被占用了 查看82端口的使用情况，如图 &gt;netstat -anp |grep 82 可以看出并没有LISTEN那一行，所以就表示没有被占用。此处注意，图中显示的LISTENING并不表示端口被占用，不要和LISTEN混淆哦，查看具体端口时候，必须要看到tcp，端口号，LISTEN那一行，才表示端口被占用了 17.8 查看当前所有已经使用的端口情况如图： netstat -nultp（此处不用加端口号） 17.9 如何查找一个文件大小超过5M的文件&gt;find . -type f -size +100M 17.10 如果知道一个文件名称，怎么查这个文件在linux下的哪个目录如：要查找tnsnames.ora文件 &gt;find / -name tnsnames.ora 查到： /opt/app/oracle/product/10.2/network/admin/tnsnames.ora /opt/app/oracle/product/10.2/network/admin/samples/tnsnames.ora 还可以用locate 来查找 &gt;locate tnsnames.ora 结果是： /opt/app/oracle/product/10.2/hs/admin/tnsnames.ora.sample /opt/app/oracle/product/10.2/network/admin/tnsnames.ora /opt/app/oracle/product/10.2/network/admin/samples/tnsnames.ora 17.11 find查找文件find / -name httpd.conf #在根目录下查找文件httpd.conf，表示在整个硬盘查找 find /etc -name httpd.conf #在/etc目录下文件httpd.conf find /etc -name ‘srm’ #使用通配符(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 find . -name ‘srm’ #表示当前目录下查找文件名开头是字符串‘srm’的文件 按照文件特征查找 find / -amin -10 # 查找在系统中最后10分钟访问的文件(access time) find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -group cat # 查找在系统中属于 group为cat的文件 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件(modify time) find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -user fred #查找在系统中属于fred这个用户的文件 find / -size +10000c #查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB) find / -size -1000k #查找出小于1000KB的文件 17.12 vim（vi）编辑器有命令模式、输入模式、末行模式三种模式。 ● 命令模式：查找内容(/abc、跳转到指定行(20gg)、跳转到尾行(G)、跳转到首行(gg)、删除行(dd)、插入行(o)、复制粘贴(yy,p) ● 输入模式：编辑文件内容 ● 末行模式：保存退出(wq)、强制退出(q!)、显示文件行号(set nu) 在命令模式下，输入a或i即可切换到输入模式，输入冒号(:)即可切换到末行模式；在输入模式和末行模式下，按esc键切换到命令模式","link":"/2020/06/12/JavaEE%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"git windows Linux","slug":"git-windows-Linux","link":"/tags/git-windows-Linux/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"idea IntelliJ IDEA jetbrains","slug":"idea-IntelliJ-IDEA-jetbrains","link":"/tags/idea-IntelliJ-IDEA-jetbrains/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"java高级","slug":"java高级","link":"/tags/java%E9%AB%98%E7%BA%A7/"},{"name":"Java 多线程","slug":"Java-多线程","link":"/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"IO 流","slug":"IO-流","link":"/tags/IO-%E6%B5%81/"},{"name":"enum annotation","slug":"enum-annotation","link":"/tags/enum-annotation/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Ps","slug":"Ps","link":"/tags/Ps/"},{"name":"Sketch","slug":"Sketch","link":"/tags/Sketch/"},{"name":"vagrant","slug":"vagrant","link":"/tags/vagrant/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"frp","slug":"frp","link":"/tags/frp/"},{"name":"Java反射射机制","slug":"Java反射射机制","link":"/tags/Java%E5%8F%8D%E5%B0%84%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"name":"Java网络编程","slug":"Java网络编程","link":"/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"categories":[{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"注册码破解idea","slug":"注册码破解idea","link":"/categories/%E6%B3%A8%E5%86%8C%E7%A0%81%E7%A0%B4%E8%A7%A3idea/"},{"name":"java中常用的类","slug":"java中常用的类","link":"/categories/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB/"},{"name":"泛型","slug":"泛型","link":"/categories/%E6%B3%9B%E5%9E%8B/"},{"name":"线程的基本概念以及使用","slug":"线程的基本概念以及使用","link":"/categories/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"name":"Java高级","slug":"Java高级","link":"/categories/Java%E9%AB%98%E7%BA%A7/"},{"name":"List Set Map","slug":"List-Set-Map","link":"/categories/List-Set-Map/"},{"name":"enum annotation","slug":"enum-annotation","link":"/categories/enum-annotation/"},{"name":"破解Sketch方法及安装包","slug":"破解Sketch方法及安装包","link":"/categories/%E7%A0%B4%E8%A7%A3Sketch%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/"},{"name":"vagrant","slug":"vagrant","link":"/categories/vagrant/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"frp","slug":"frp","link":"/categories/frp/"},{"name":"面试题","slug":"面试题","link":"/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]}